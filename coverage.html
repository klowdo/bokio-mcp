
<!DOCTYPE html>
<html>
	<head>
		<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
		<title>bokio: Go Coverage Report</title>
		<style>
			body {
				background: black;
				color: rgb(80, 80, 80);
			}
			body, pre, #legend span {
				font-family: Menlo, monospace;
				font-weight: bold;
			}
			#topbar {
				background: black;
				position: fixed;
				top: 0; left: 0; right: 0;
				height: 42px;
				border-bottom: 1px solid rgb(80, 80, 80);
			}
			#content {
				margin-top: 50px;
			}
			#nav, #legend {
				float: left;
				margin-left: 10px;
			}
			#legend {
				margin-top: 12px;
			}
			#nav {
				margin-top: 10px;
			}
			#legend span {
				margin: 0 5px;
			}
			.cov0 { color: rgb(192, 0, 0) }
.cov1 { color: rgb(128, 128, 128) }
.cov2 { color: rgb(116, 140, 131) }
.cov3 { color: rgb(104, 152, 134) }
.cov4 { color: rgb(92, 164, 137) }
.cov5 { color: rgb(80, 176, 140) }
.cov6 { color: rgb(68, 188, 143) }
.cov7 { color: rgb(56, 200, 146) }
.cov8 { color: rgb(44, 212, 149) }
.cov9 { color: rgb(32, 224, 152) }
.cov10 { color: rgb(20, 236, 155) }

		</style>
	</head>
	<body>
		<div id="topbar">
			<div id="nav">
				<select id="files">
				
				<option value="file0">github.com/klowdo/bokio-mcp/bokio/auth_middleware.go (0.0%)</option>
				
				<option value="file1">github.com/klowdo/bokio-mcp/bokio/client.go (0.0%)</option>
				
				<option value="file2">github.com/klowdo/bokio-mcp/bokio/generated/company/client.go (0.0%)</option>
				
				<option value="file3">github.com/klowdo/bokio-mcp/bokio/generated/company/types.go (0.0%)</option>
				
				<option value="file4">github.com/klowdo/bokio-mcp/bokio/generated/general/client.go (0.0%)</option>
				
				<option value="file5">github.com/klowdo/bokio-mcp/bokio/token_manager.go (0.0%)</option>
				
				<option value="file6">github.com/klowdo/bokio-mcp/bokio/types.go (0.0%)</option>
				
				<option value="file7">github.com/klowdo/bokio-mcp/main.go (0.0%)</option>
				
				<option value="file8">github.com/klowdo/bokio-mcp/tools/auth.go (0.0%)</option>
				
				<option value="file9">github.com/klowdo/bokio-mcp/tools/customers.go (0.0%)</option>
				
				<option value="file10">github.com/klowdo/bokio-mcp/tools/invoices.go (0.0%)</option>
				
				<option value="file11">github.com/klowdo/bokio-mcp/tools/journal.go (0.0%)</option>
				
				<option value="file12">github.com/klowdo/bokio-mcp/tools/uploads.go (0.0%)</option>
				
				</select>
			</div>
			<div id="legend">
				<span>not tracked</span>
			
				<span class="cov0">no coverage</span>
				<span class="cov1">low coverage</span>
				<span class="cov2">*</span>
				<span class="cov3">*</span>
				<span class="cov4">*</span>
				<span class="cov5">*</span>
				<span class="cov6">*</span>
				<span class="cov7">*</span>
				<span class="cov8">*</span>
				<span class="cov9">*</span>
				<span class="cov10">high coverage</span>
			
			</div>
		</div>
		<div id="content">
		
		<pre class="file" id="file0" style="display: none">// Package bokio provides authentication middleware for transparent token management
package bokio

import (
        "context"
        "fmt"
        "html/template"
        "net"
        "net/http"
        "os"
        "os/exec"
        "runtime"
        "strings"
        "sync"
        "time"

        "github.com/go-resty/resty/v2"
)

// AuthMiddleware provides transparent authentication for API requests
type AuthMiddleware struct {
        client       *Client
        tokenManager *TokenManager
        logger       Logger
        authMutex    sync.Mutex
        lastAuthTime time.Time
}

// InteractiveAuthConfig holds configuration for interactive authentication
type InteractiveAuthConfig struct {
        BrowserCommand    string        // Custom browser command
        CallbackTimeout   time.Duration // How long to wait for OAuth callback
        CallbackPort      int           // Port for OAuth callback server
        DisableAutoLaunch bool          // Don't automatically open browser
}

// DefaultInteractiveAuthConfig returns default configuration for interactive auth
func DefaultInteractiveAuthConfig() *InteractiveAuthConfig <span class="cov0" title="0">{
        return &amp;InteractiveAuthConfig{
                CallbackTimeout:   5 * time.Minute,
                CallbackPort:      8080,
                DisableAutoLaunch: false,
        }
}</span>

// NewAuthMiddleware creates a new authentication middleware
func NewAuthMiddleware(client *Client, tokenManager *TokenManager, logger Logger) *AuthMiddleware <span class="cov0" title="0">{
        if logger == nil </span><span class="cov0" title="0">{
                logger = &amp;DefaultLogger{}
        }</span>

        <span class="cov0" title="0">return &amp;AuthMiddleware{
                client:       client,
                tokenManager: tokenManager,
                logger:       logger,
        }</span>
}

// EnsureAuthenticated ensures the client is authenticated, handling the full OAuth flow if needed
func (am *AuthMiddleware) EnsureAuthenticated(ctx context.Context) error <span class="cov0" title="0">{
        am.authMutex.Lock()
        defer am.authMutex.Unlock()

        // Check if we already have valid tokens loaded
        if am.client.IsAuthenticated() </span><span class="cov0" title="0">{
                am.logger.Debug("Client already authenticated with valid tokens")
                return nil
        }</span>

        // Try to load tokens from storage
        <span class="cov0" title="0">if am.tokenManager.HasTokens(am.client.clientID) </span><span class="cov0" title="0">{
                if err := am.loadStoredTokens(); err != nil </span><span class="cov0" title="0">{
                        am.logger.Warn("Failed to load stored tokens, will re-authenticate", "error", err)
                }</span> else<span class="cov0" title="0"> if am.client.IsAuthenticated() </span><span class="cov0" title="0">{
                        am.logger.Info("Successfully loaded stored tokens")
                        return nil
                }</span>
        }

        // Check if we have a refresh token and try to refresh
        <span class="cov0" title="0">_, refreshToken, expiresAt := am.client.GetTokens()
        if refreshToken != "" &amp;&amp; !expiresAt.IsZero() </span><span class="cov0" title="0">{
                if err := am.client.RefreshAccessToken(ctx); err != nil </span><span class="cov0" title="0">{
                        am.logger.Warn("Failed to refresh tokens, will re-authenticate", "error", err)
                }</span> else<span class="cov0" title="0"> {
                        am.logger.Info("Successfully refreshed tokens")
                        // Save the refreshed tokens
                        newAccessToken, newRefreshToken, newExpiresAt := am.client.GetTokens()
                        tenantID, tenantType := am.client.GetTenantInfo()
                        if err := am.tokenManager.SaveTokens(am.client.clientID, newAccessToken, newRefreshToken, newExpiresAt, tenantID, tenantType); err != nil </span><span class="cov0" title="0">{
                                am.logger.Warn("Failed to save refreshed tokens", "error", err)
                        }</span>
                        <span class="cov0" title="0">return nil</span>
                }
        }

        // Need to perform full OAuth flow
        <span class="cov0" title="0">return am.performInteractiveAuth(ctx, DefaultInteractiveAuthConfig())</span>
}

// MakeAuthenticatedRequest performs a request with automatic authentication handling
func (am *AuthMiddleware) MakeAuthenticatedRequest(ctx context.Context, method, path string, body interface{}) (*resty.Response, error) <span class="cov0" title="0">{
        // Ensure we're authenticated before making the request
        if err := am.EnsureAuthenticated(ctx); err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("authentication failed: %w", err)
        }</span>

        // Make the request using the client's existing makeRequest method
        <span class="cov0" title="0">resp, err := am.client.makeRequest(ctx, method, path, body)
        
        // If we get an authentication error, try to refresh and retry once
        if err != nil </span><span class="cov0" title="0">{
                if apiErr, ok := err.(*APIError); ok &amp;&amp; (apiErr.Code == 401 || apiErr.Code == 403) </span><span class="cov0" title="0">{
                        am.logger.Info("Request failed with auth error, attempting token refresh", "status_code", apiErr.Code)
                        
                        // Try to refresh the token
                        if refreshErr := am.client.RefreshAccessToken(ctx); refreshErr != nil </span><span class="cov0" title="0">{
                                am.logger.Warn("Token refresh failed", "error", refreshErr)
                                // Clear stored tokens and require re-authentication
                                if delErr := am.tokenManager.DeleteTokens(am.client.clientID); delErr != nil </span><span class="cov0" title="0">{
                                        am.logger.Error("Failed to clear invalid tokens", "error", delErr)
                                }</span>
                                <span class="cov0" title="0">return nil, fmt.Errorf("authentication failed and token refresh failed: %w", err)</span>
                        }

                        // Save the refreshed tokens
                        <span class="cov0" title="0">accessToken, refreshToken, expiresAt := am.client.GetTokens()
                        tenantID, tenantType := am.client.GetTenantInfo()
                        if saveErr := am.tokenManager.SaveTokens(am.client.clientID, accessToken, refreshToken, expiresAt, tenantID, tenantType); saveErr != nil </span><span class="cov0" title="0">{
                                am.logger.Warn("Failed to save refreshed tokens", "error", saveErr)
                        }</span>

                        // Retry the original request
                        <span class="cov0" title="0">resp, err = am.client.makeRequest(ctx, method, path, body)
                        if err != nil </span><span class="cov0" title="0">{
                                am.logger.Error("Request failed again after token refresh", "error", err)
                                return resp, err
                        }</span>
                }
        }

        <span class="cov0" title="0">return resp, err</span>
}

// loadStoredTokens loads tokens from storage into the client
func (am *AuthMiddleware) loadStoredTokens() error <span class="cov0" title="0">{
        accessToken, refreshToken, expiresAt, tenantID, tenantType, err := am.tokenManager.LoadTokens(am.client.clientID)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to load tokens from storage: %w", err)
        }</span>

        // Set tokens in client
        <span class="cov0" title="0">am.client.SetTokens(accessToken, refreshToken, expiresAt)
        
        // Set tenant info
        am.client.tokenMutex.Lock()
        am.client.tenantID = tenantID
        am.client.tenantType = tenantType
        am.client.tokenMutex.Unlock()

        am.logger.Debug("Loaded tokens from storage", "expires_at", expiresAt, "tenant_id", tenantID)
        return nil</span>
}

// performInteractiveAuth performs the full interactive OAuth flow
func (am *AuthMiddleware) performInteractiveAuth(ctx context.Context, config *InteractiveAuthConfig) error <span class="cov0" title="0">{
        am.logger.Info("Starting interactive OAuth authentication flow")

        // Rate limit authentication attempts
        if time.Since(am.lastAuthTime) &lt; 30*time.Second </span><span class="cov0" title="0">{
                return fmt.Errorf("authentication attempted too recently, please wait")
        }</span>
        <span class="cov0" title="0">am.lastAuthTime = time.Now()

        // Generate state parameter for security
        state := fmt.Sprintf("bokio-mcp-%d", time.Now().Unix())
        authURL := am.client.GetAuthorizationURL(state)

        am.logger.Info("OAuth authorization URL generated", "url", authURL)

        // Start callback server
        callbackServer, callbackChan, err := am.startCallbackServer(config.CallbackPort, state)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to start callback server: %w", err)
        }</span>
        <span class="cov0" title="0">defer func() </span><span class="cov0" title="0">{
                ctx, cancel := context.WithTimeout(context.Background(), 5*time.Second)
                defer cancel()
                if err := callbackServer.Shutdown(ctx); err != nil </span><span class="cov0" title="0">{
                        am.logger.Warn("Failed to shutdown callback server gracefully", "error", err)
                }</span>
        }()

        // Open browser if not disabled
        <span class="cov0" title="0">if !config.DisableAutoLaunch </span><span class="cov0" title="0">{
                if err := am.openBrowser(authURL, config.BrowserCommand); err != nil </span><span class="cov0" title="0">{
                        am.logger.Warn("Failed to open browser automatically", "error", err)
                        fmt.Printf("Please visit this URL to authenticate: %s\n", authURL)
                }</span>
        } else<span class="cov0" title="0"> {
                fmt.Printf("Please visit this URL to authenticate: %s\n", authURL)
        }</span>

        // Wait for callback or timeout
        <span class="cov0" title="0">select </span>{
        case callbackData := &lt;-callbackChan:<span class="cov0" title="0">
                if callbackData.Error != "" </span><span class="cov0" title="0">{
                        return fmt.Errorf("OAuth callback error: %s", callbackData.Error)
                }</span>
                <span class="cov0" title="0">if callbackData.State != state </span><span class="cov0" title="0">{
                        return fmt.Errorf("OAuth state mismatch, possible CSRF attack")
                }</span>

                // Exchange code for tokens
                <span class="cov0" title="0">if err := am.client.ExchangeCodeForToken(ctx, callbackData.Code); err != nil </span><span class="cov0" title="0">{
                        return fmt.Errorf("failed to exchange code for tokens: %w", err)
                }</span>

                // Save tokens to storage
                <span class="cov0" title="0">accessToken, refreshToken, expiresAt := am.client.GetTokens()
                tenantID, tenantType := am.client.GetTenantInfo()
                if err := am.tokenManager.SaveTokens(am.client.clientID, accessToken, refreshToken, expiresAt, tenantID, tenantType); err != nil </span><span class="cov0" title="0">{
                        am.logger.Warn("Failed to save tokens to storage", "error", err)
                }</span>

                <span class="cov0" title="0">am.logger.Info("Interactive authentication completed successfully")
                return nil</span>

        case &lt;-time.After(config.CallbackTimeout):<span class="cov0" title="0">
                return fmt.Errorf("OAuth authentication timed out after %v", config.CallbackTimeout)</span>

        case &lt;-ctx.Done():<span class="cov0" title="0">
                return fmt.Errorf("OAuth authentication cancelled: %w", ctx.Err())</span>
        }
}

// CallbackData represents data received from OAuth callback
type CallbackData struct {
        Code  string
        State string
        Error string
}

// startCallbackServer starts a local HTTP server to handle OAuth callbacks
func (am *AuthMiddleware) startCallbackServer(port int, expectedState string) (server *http.Server, callbackChan chan CallbackData, err error) <span class="cov0" title="0">{
        callbackChan = make(chan CallbackData, 1)
        
        // Create HTTP handler for OAuth callback
        mux := http.NewServeMux()
        mux.HandleFunc("/callback", func(w http.ResponseWriter, r *http.Request) </span><span class="cov0" title="0">{
                am.handleOAuthCallback(w, r, callbackChan, expectedState)
        }</span>)
        
        // Find available port starting from the requested port
        <span class="cov0" title="0">listener, actualPort, err := am.findAvailablePort(port)
        if err != nil </span><span class="cov0" title="0">{
                return nil, nil, fmt.Errorf("failed to find available port: %w", err)
        }</span>
        
        // Create server
        <span class="cov0" title="0">server = &amp;http.Server{
                Handler:      mux,
                ReadTimeout:  10 * time.Second,
                WriteTimeout: 10 * time.Second,
        }
        
        // Start server in background
        go func() </span><span class="cov0" title="0">{
                am.logger.Info("Starting OAuth callback server", "port", actualPort)
                if err := server.Serve(listener); err != nil &amp;&amp; err != http.ErrServerClosed </span><span class="cov0" title="0">{
                        am.logger.Error("OAuth callback server error", "error", err)
                        callbackChan &lt;- CallbackData{Error: fmt.Sprintf("Server error: %v", err)}
                }</span>
        }()
        
        // Update redirect URL if port changed
        <span class="cov0" title="0">if actualPort != port </span><span class="cov0" title="0">{
                am.logger.Info("Using different port for callback server", "requested", port, "actual", actualPort)
                // Note: In a real implementation, you might need to update the OAuth app's
                // redirect URL configuration if the port is different
        }</span>
        
        <span class="cov0" title="0">return server, callbackChan, nil</span>
}

// findAvailablePort finds an available port starting from the preferred port
func (am *AuthMiddleware) findAvailablePort(preferredPort int) (net.Listener, int, error) <span class="cov0" title="0">{
        // Try the preferred port first
        addr := fmt.Sprintf("127.0.0.1:%d", preferredPort)
        listener, err := net.Listen("tcp", addr)
        if err == nil </span><span class="cov0" title="0">{
                return listener, preferredPort, nil
        }</span>
        
        // If preferred port is not available, try a few nearby ports
        <span class="cov0" title="0">for port := preferredPort + 1; port &lt; preferredPort + 10; port++ </span><span class="cov0" title="0">{
                addr := fmt.Sprintf("127.0.0.1:%d", port)
                listener, err := net.Listen("tcp", addr)
                if err == nil </span><span class="cov0" title="0">{
                        return listener, port, nil
                }</span>
        }
        
        // If all else fails, let the OS choose a port
        <span class="cov0" title="0">listener, err = net.Listen("tcp", "127.0.0.1:0")
        if err != nil </span><span class="cov0" title="0">{
                return nil, 0, err
        }</span>
        
        <span class="cov0" title="0">tcpAddr := listener.Addr().(*net.TCPAddr)
        return listener, tcpAddr.Port, nil</span>
}

// handleOAuthCallback handles the OAuth callback request
func (am *AuthMiddleware) handleOAuthCallback(w http.ResponseWriter, r *http.Request, callbackChan chan CallbackData, expectedState string) <span class="cov0" title="0">{
        // Parse query parameters
        code := r.URL.Query().Get("code")
        state := r.URL.Query().Get("state")
        errorParam := r.URL.Query().Get("error")
        errorDescription := r.URL.Query().Get("error_description")
        
        am.logger.Debug("Received OAuth callback", "code_present", code != "", "state", state, "error", errorParam)
        
        // Prepare callback data
        callbackData := CallbackData{
                Code:  code,
                State: state,
        }
        
        if errorParam != "" </span><span class="cov0" title="0">{
                callbackData.Error = errorParam
                if errorDescription != "" </span><span class="cov0" title="0">{
                        callbackData.Error += ": " + errorDescription
                }</span>
        }
        
        // Send callback data (non-blocking)
        <span class="cov0" title="0">select </span>{
        case callbackChan &lt;- callbackData:<span class="cov0" title="0">
                am.logger.Debug("Sent callback data to channel")</span>
        default:<span class="cov0" title="0">
                am.logger.Warn("Callback channel full, dropping data")</span>
        }
        
        // Send response to browser
        <span class="cov0" title="0">var htmlResponse string
        if errorParam != "" </span><span class="cov0" title="0">{
                htmlResponse = am.getErrorPage(errorParam, errorDescription)
        }</span> else<span class="cov0" title="0"> if code != "" </span><span class="cov0" title="0">{
                htmlResponse = am.getSuccessPage()
        }</span> else<span class="cov0" title="0"> {
                htmlResponse = am.getErrorPage("invalid_request", "No authorization code received")
        }</span>
        
        <span class="cov0" title="0">w.Header().Set("Content-Type", "text/html; charset=utf-8")
        w.WriteHeader(http.StatusOK)
        w.Write([]byte(htmlResponse))</span>
}

// getSuccessPage returns HTML for successful OAuth callback
func (am *AuthMiddleware) getSuccessPage() string <span class="cov0" title="0">{
        const successTemplate = `&lt;!DOCTYPE html&gt;
&lt;html&gt;
&lt;head&gt;
    &lt;title&gt;Bokio Authentication Success&lt;/title&gt;
    &lt;style&gt;
        body { font-family: -apple-system, BlinkMacSystemFont, sans-serif; margin: 0; padding: 40px; background: #f5f5f5; }
        .container { max-width: 400px; margin: 0 auto; background: white; padding: 40px; border-radius: 8px; box-shadow: 0 2px 10px rgba(0,0,0,0.1); text-align: center; }
        .success { color: #22c55e; font-size: 48px; margin-bottom: 20px; }
        h1 { color: #1f2937; margin: 0 0 10px 0; font-size: 24px; }
        p { color: #6b7280; margin: 0 0 20px 0; line-height: 1.5; }
        .close-btn { background: #3b82f6; color: white; padding: 12px 24px; border: none; border-radius: 6px; font-size: 14px; cursor: pointer; }
        .close-btn:hover { background: #2563eb; }
    &lt;/style&gt;
&lt;/head&gt;
&lt;body&gt;
    &lt;div class="container"&gt;
        &lt;div class="success"&gt;✓&lt;/div&gt;
        &lt;h1&gt;Authentication Successful!&lt;/h1&gt;
        &lt;p&gt;You have successfully authenticated with Bokio. You can close this window and return to your application.&lt;/p&gt;
        &lt;button class="close-btn" onclick="window.close()"&gt;Close Window&lt;/button&gt;
    &lt;/div&gt;
    &lt;script&gt;
        // Auto-close after 5 seconds
        setTimeout(function() {
            window.close();
        }, 5000);
    &lt;/script&gt;
&lt;/body&gt;
&lt;/html&gt;`
        return successTemplate
}</span>

// getErrorPage returns HTML for OAuth callback error
func (am *AuthMiddleware) getErrorPage(error, description string) string <span class="cov0" title="0">{
        const errorTemplate = `&lt;!DOCTYPE html&gt;
&lt;html&gt;
&lt;head&gt;
    &lt;title&gt;Bokio Authentication Error&lt;/title&gt;
    &lt;style&gt;
        body { font-family: -apple-system, BlinkMacSystemFont, sans-serif; margin: 0; padding: 40px; background: #f5f5f5; }
        .container { max-width: 400px; margin: 0 auto; background: white; padding: 40px; border-radius: 8px; box-shadow: 0 2px 10px rgba(0,0,0,0.1); text-align: center; }
        .error { color: #ef4444; font-size: 48px; margin-bottom: 20px; }
        h1 { color: #1f2937; margin: 0 0 10px 0; font-size: 24px; }
        p { color: #6b7280; margin: 0 0 20px 0; line-height: 1.5; }
        .error-details { background: #fef2f2; color: #991b1b; padding: 12px; border-radius: 6px; margin: 20px 0; font-size: 14px; }
        .close-btn { background: #6b7280; color: white; padding: 12px 24px; border: none; border-radius: 6px; font-size: 14px; cursor: pointer; }
        .close-btn:hover { background: #4b5563; }
    &lt;/style&gt;
&lt;/head&gt;
&lt;body&gt;
    &lt;div class="container"&gt;
        &lt;div class="error"&gt;✗&lt;/div&gt;
        &lt;h1&gt;Authentication Failed&lt;/h1&gt;
        &lt;p&gt;There was an error during the authentication process.&lt;/p&gt;
        &lt;div class="error-details"&gt;
            &lt;strong&gt;Error:&lt;/strong&gt; {{.Error}}&lt;br&gt;
            {{if .Description}}&lt;strong&gt;Description:&lt;/strong&gt; {{.Description}}{{end}}
        &lt;/div&gt;
        &lt;p&gt;Please close this window and try again.&lt;/p&gt;
        &lt;button class="close-btn" onclick="window.close()"&gt;Close Window&lt;/button&gt;
    &lt;/div&gt;
&lt;/body&gt;
&lt;/html&gt;`

        tmpl, err := template.New("error").Parse(errorTemplate)
        if err != nil </span><span class="cov0" title="0">{
                // Fallback to simple HTML if template parsing fails
                return fmt.Sprintf(`&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt;&lt;title&gt;Authentication Error&lt;/title&gt;&lt;/head&gt;&lt;body&gt;&lt;h1&gt;Authentication Failed&lt;/h1&gt;&lt;p&gt;Error: %s&lt;/p&gt;&lt;p&gt;%s&lt;/p&gt;&lt;/body&gt;&lt;/html&gt;`, error, description)
        }</span>

        <span class="cov0" title="0">var result strings.Builder
        data := struct {
                Error       string
                Description string
        }{
                Error:       error,
                Description: description,
        }

        if err := tmpl.Execute(&amp;result, data); err != nil </span><span class="cov0" title="0">{
                // Fallback if template execution fails
                return fmt.Sprintf(`&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt;&lt;title&gt;Authentication Error&lt;/title&gt;&lt;/head&gt;&lt;body&gt;&lt;h1&gt;Authentication Failed&lt;/h1&gt;&lt;p&gt;Error: %s&lt;/p&gt;&lt;p&gt;%s&lt;/p&gt;&lt;/body&gt;&lt;/html&gt;`, error, description)
        }</span>

        <span class="cov0" title="0">return result.String()</span>
}

// openBrowser attempts to open the default browser with the given URL
func (am *AuthMiddleware) openBrowser(url, browserCommand string) error <span class="cov0" title="0">{
        var cmd *exec.Cmd

        if browserCommand != "" </span><span class="cov0" title="0">{
                cmd = exec.Command(browserCommand, url)
        }</span> else<span class="cov0" title="0"> {
                switch runtime.GOOS </span>{
                case "darwin":<span class="cov0" title="0">
                        cmd = exec.Command("open", url)</span>
                case "windows":<span class="cov0" title="0">
                        cmd = exec.Command("rundll32", "url.dll,FileProtocolHandler", url)</span>
                case "linux":<span class="cov0" title="0">
                        cmd = exec.Command("xdg-open", url)</span>
                default:<span class="cov0" title="0">
                        return fmt.Errorf("unsupported operating system: %s", runtime.GOOS)</span>
                }
        }

        // Run in background
        <span class="cov0" title="0">cmd.Stdout = os.Stdout
        cmd.Stderr = os.Stderr
        return cmd.Start()</span>
}

// ClearAuthentication removes all stored authentication data
func (am *AuthMiddleware) ClearAuthentication() error <span class="cov0" title="0">{
        am.authMutex.Lock()
        defer am.authMutex.Unlock()

        // Clear tokens from client
        am.client.SetTokens("", "", time.Time{})
        
        // Clear tenant info
        am.client.tokenMutex.Lock()
        am.client.tenantID = ""
        am.client.tenantType = ""
        am.client.tokenMutex.Unlock()

        // Delete tokens from storage
        if err := am.tokenManager.DeleteTokens(am.client.clientID); err != nil </span><span class="cov0" title="0">{
                am.logger.Error("Failed to delete stored tokens", "error", err)
                return fmt.Errorf("failed to clear stored tokens: %w", err)
        }</span>

        <span class="cov0" title="0">am.logger.Info("Authentication cleared successfully")
        return nil</span>
}

// GetAuthenticationStatus returns the current authentication status
func (am *AuthMiddleware) GetAuthenticationStatus() (authenticated bool, tenantID, tenantType string, expiresAt time.Time, hasRefreshToken bool) <span class="cov0" title="0">{
        // Check in-memory tokens first
        if am.client.IsAuthenticated() </span><span class="cov0" title="0">{
                accessToken, refreshToken, expiry := am.client.GetTokens()
                tid, ttype := am.client.GetTenantInfo()
                return accessToken != "", tid, ttype, expiry, refreshToken != ""
        }</span>

        // Check stored tokens
        <span class="cov0" title="0">if am.tokenManager.HasTokens(am.client.clientID) </span><span class="cov0" title="0">{
                if tid, ttype, expiry, hasRefresh, err := am.tokenManager.GetTokenInfo(am.client.clientID); err == nil </span><span class="cov0" title="0">{
                        return am.tokenManager.IsTokenValid(am.client.clientID), tid, ttype, expiry, hasRefresh
                }</span>
        }

        <span class="cov0" title="0">return false, "", "", time.Time{}, false</span>
}</pre>
		
		<pre class="file" id="file1" style="display: none">// Package bokio provides a client for the Bokio API with OAuth2 authentication support.
package bokio

import (
        "context"
        "encoding/base64"
        "encoding/json"
        "fmt"
        "log"
        "net/http"
        "net/url"
        "strings"
        "sync"
        "time"

        "github.com/go-resty/resty/v2"
        "golang.org/x/oauth2"
)

// Client represents the Bokio API client with Bearer token authentication
type Client struct {
        // HTTP client configuration
        httpClient *resty.Client
        baseURL    string

        // Bearer token authentication
        integrationToken string
        tokenMutex       sync.RWMutex

        // Rate limiting
        rateLimiter chan struct{}

        // Logging
        logger Logger

        // Security
        readOnly bool // When true, prevents all write operations

        // Legacy OAuth2 fields (deprecated, for backward compatibility)
        oauth2Config   *oauth2.Config // Deprecated
        clientID       string         // Deprecated
        clientSecret   string         // Deprecated
        accessToken    string         // Deprecated
        refreshToken   string         // Deprecated
        tokenExpiry    time.Time      // Deprecated
        tenantID       string         // Deprecated
        tenantType     string         // Deprecated
        authMiddleware *AuthMiddleware // Deprecated - will be removed
        tokenManager   *TokenManager  // Deprecated - will be removed
}

// Config holds the configuration for the Bokio API client
type Config struct {
        // Integration token (Bearer authentication)
        IntegrationToken string

        // API configuration
        BaseURL string

        // Client configuration
        Timeout    time.Duration
        MaxRetries int
        RateLimit  int // requests per second
        UserAgent  string

        // Logging
        Logger Logger

        // Security
        ReadOnly bool // When true, prevents all write operations

        // Legacy OAuth2 fields (deprecated, for backward compatibility)
        ClientID     string // Deprecated: Use IntegrationToken instead
        ClientSecret string // Deprecated: Use IntegrationToken instead
        RedirectURI  string // Deprecated: Not needed for Integration tokens
        Scopes       []string // Deprecated: Not needed for Integration tokens
}

// Logger interface for customizable logging
type Logger interface {
        Debug(msg string, fields ...interface{})
        Info(msg string, fields ...interface{})
        Warn(msg string, fields ...interface{})
        Error(msg string, fields ...interface{})
}

// DefaultLogger provides a simple logger implementation
type DefaultLogger struct{}

func (l *DefaultLogger) Debug(msg string, fields ...interface{}) <span class="cov0" title="0">{
        log.Printf("[DEBUG] %s %v", msg, fields)
}</span>

func (l *DefaultLogger) Info(msg string, fields ...interface{}) <span class="cov0" title="0">{
        log.Printf("[INFO] %s %v", msg, fields)
}</span>

func (l *DefaultLogger) Warn(msg string, fields ...interface{}) <span class="cov0" title="0">{
        log.Printf("[WARN] %s %v", msg, fields)
}</span>

func (l *DefaultLogger) Error(msg string, fields ...interface{}) <span class="cov0" title="0">{
        log.Printf("[ERROR] %s %v", msg, fields)
}</span>

// TokenResponse represents the OAuth2 token response from Bokio API
type TokenResponse struct {
        TenantID     string `json:"tenant_id"`
        TenantType   string `json:"tenant_type"`
        AccessToken  string `json:"access_token"`
        TokenType    string `json:"token_type"`
        ExpiresIn    int64  `json:"expires_in"`
        RefreshToken string `json:"refresh_token,omitempty"`
}

// APIError represents an error response from the Bokio API
type APIError struct {
        Code    int    `json:"code"`
        Message string `json:"message"`
        Details string `json:"details,omitempty"`
}

func (e *APIError) Error() string <span class="cov0" title="0">{
        if e.Details != "" </span><span class="cov0" title="0">{
                return fmt.Sprintf("Bokio API error %d: %s (%s)", e.Code, e.Message, e.Details)
        }</span>
        <span class="cov0" title="0">return fmt.Sprintf("Bokio API error %d: %s", e.Code, e.Message)</span>
}

// DefaultConfig returns a default configuration for the Bokio client
func DefaultConfig() *Config <span class="cov0" title="0">{
        return &amp;Config{
                BaseURL:    "https://api.bokio.se",
                Scopes:     []string{"accounting", "invoices"},
                Timeout:    30 * time.Second,
                MaxRetries: 3,
                RateLimit:  10, // 10 requests per second
                UserAgent:  "Bokio-MCP-Client/1.0",
                Logger:     &amp;DefaultLogger{},
        }
}</span>

// NewClient creates a new Bokio API client with the given configuration
func NewClient(config *Config) (*Client, error) <span class="cov0" title="0">{
        if config == nil </span><span class="cov0" title="0">{
                config = DefaultConfig()
        }</span>

        // Check for Integration token (new preferred method)
        <span class="cov0" title="0">if config.IntegrationToken == "" </span><span class="cov0" title="0">{
                // Fallback to legacy OAuth2 fields for backward compatibility
                if config.ClientID == "" || config.ClientSecret == "" </span><span class="cov0" title="0">{
                        return nil, fmt.Errorf("either BOKIO_INTEGRATION_TOKEN or legacy BOKIO_CLIENT_ID/BOKIO_CLIENT_SECRET are required")
                }</span>
        }

        <span class="cov0" title="0">if config.BaseURL == "" </span><span class="cov0" title="0">{
                config.BaseURL = "https://api.bokio.se"
        }</span>

        <span class="cov0" title="0">if config.Logger == nil </span><span class="cov0" title="0">{
                config.Logger = &amp;DefaultLogger{}
        }</span>

        // Initialize OAuth2 configuration (for backward compatibility only)
        <span class="cov0" title="0">var oauth2Config *oauth2.Config
        if config.ClientID != "" &amp;&amp; config.ClientSecret != "" </span><span class="cov0" title="0">{
                oauth2Config = &amp;oauth2.Config{
                        ClientID:     config.ClientID,
                        ClientSecret: config.ClientSecret,
                        Endpoint: oauth2.Endpoint{
                                AuthURL:  config.BaseURL + "/authorize",
                                TokenURL: config.BaseURL + "/token",
                        },
                        RedirectURL: config.RedirectURI,
                        Scopes:      config.Scopes,
                }
        }</span>

        // Initialize HTTP client
        <span class="cov0" title="0">httpClient := resty.New()
        httpClient.SetBaseURL(config.BaseURL)
        httpClient.SetTimeout(config.Timeout)
        httpClient.SetRetryCount(config.MaxRetries)
        httpClient.SetHeader("User-Agent", config.UserAgent)

        // Add retry condition
        httpClient.AddRetryCondition(func(r *resty.Response, err error) bool </span><span class="cov0" title="0">{
                return r.StatusCode() &gt;= 500 || r.StatusCode() == 429
        }</span>)

        // Add debug logging if enabled
        <span class="cov0" title="0">httpClient.OnBeforeRequest(func(c *resty.Client, req *resty.Request) error </span><span class="cov0" title="0">{
                config.Logger.Debug("API Request", "method", req.Method, "url", req.URL, "headers", req.Header)
                return nil
        }</span>)

        <span class="cov0" title="0">httpClient.OnAfterResponse(func(c *resty.Client, resp *resty.Response) error </span><span class="cov0" title="0">{
                config.Logger.Debug("API Response", "status", resp.StatusCode(), "time", resp.Time())
                return nil
        }</span>)

        // Initialize rate limiter
        <span class="cov0" title="0">var rateLimiter chan struct{}
        if config.RateLimit &gt; 0 </span><span class="cov0" title="0">{
                rateLimiter = make(chan struct{}, config.RateLimit)
                // Fill the rate limiter buffer
                for i := 0; i &lt; config.RateLimit; i++ </span><span class="cov0" title="0">{
                        rateLimiter &lt;- struct{}{}
                }</span>
                // Start rate limiter goroutine
                <span class="cov0" title="0">go func() </span><span class="cov0" title="0">{
                        ticker := time.NewTicker(time.Second / time.Duration(config.RateLimit))
                        defer ticker.Stop()
                        for range ticker.C </span><span class="cov0" title="0">{
                                select </span>{
                                case rateLimiter &lt;- struct{}{}:<span class="cov0" title="0"></span>
                                default:<span class="cov0" title="0"></span>
                                }
                        }
                }()
        }

        <span class="cov0" title="0">client := &amp;Client{
                httpClient:       httpClient,
                baseURL:          config.BaseURL,
                integrationToken: config.IntegrationToken,
                rateLimiter:      rateLimiter,
                logger:           config.Logger,
                readOnly:         config.ReadOnly,
                // Legacy OAuth2 fields (for backward compatibility)
                oauth2Config: oauth2Config,
                clientID:     config.ClientID,
                clientSecret: config.ClientSecret,
        }

        // Legacy OAuth2 initialization (for backward compatibility only)
        if config.IntegrationToken == "" &amp;&amp; config.ClientID != "" &amp;&amp; config.ClientSecret != "" </span><span class="cov0" title="0">{
                config.Logger.Warn("Using deprecated OAuth2 authentication. Please migrate to BOKIO_INTEGRATION_TOKEN")
                
                // Initialize token manager for legacy OAuth2
                tokenManager, err := NewTokenManager(config.Logger)
                if err != nil </span><span class="cov0" title="0">{
                        return nil, fmt.Errorf("failed to create token manager: %w", err)
                }</span>
                <span class="cov0" title="0">client.tokenManager = tokenManager

                // Initialize authentication middleware for legacy OAuth2
                client.authMiddleware = NewAuthMiddleware(client, tokenManager, config.Logger)

                // Try to load existing tokens on startup
                if tokenManager.HasTokens(config.ClientID) </span><span class="cov0" title="0">{
                        if accessToken, refreshToken, expiresAt, tenantID, tenantType, err := tokenManager.LoadTokens(config.ClientID); err == nil </span><span class="cov0" title="0">{
                                client.SetTokens(accessToken, refreshToken, expiresAt)
                                client.tokenMutex.Lock()
                                client.tenantID = tenantID
                                client.tenantType = tenantType
                                client.tokenMutex.Unlock()
                                config.Logger.Info("Loaded existing tokens from storage", "expires_at", expiresAt)
                        }</span> else<span class="cov0" title="0"> {
                                config.Logger.Warn("Failed to load existing tokens", "error", err)
                        }</span>
                }
        }

        <span class="cov0" title="0">return client, nil</span>
}

// IsReadOnly returns true if the client is configured in read-only mode
func (c *Client) IsReadOnly() bool <span class="cov0" title="0">{
        return c.readOnly
}</span>

// validateWriteOperation checks if write operations are allowed
func (c *Client) validateWriteOperation(operation string) error <span class="cov0" title="0">{
        if c.readOnly </span><span class="cov0" title="0">{
                return fmt.Errorf("operation '%s' not allowed in read-only mode. Set BOKIO_READ_ONLY=false to enable write operations", operation)
        }</span>
        <span class="cov0" title="0">return nil</span>
}

// GetAuthorizationURL returns the URL for OAuth2 authorization
func (c *Client) GetAuthorizationURL(state string) string <span class="cov0" title="0">{
        return c.oauth2Config.AuthCodeURL(state, oauth2.AccessTypeOffline)
}</span>

// ExchangeCodeForToken exchanges an authorization code for access and refresh tokens
func (c *Client) ExchangeCodeForToken(ctx context.Context, code string) error <span class="cov0" title="0">{
        c.logger.Info("Exchanging authorization code for tokens")

        // Prepare the request body
        data := url.Values{
                "grant_type":   {"authorization_code"},
                "code":         {code},
                "redirect_uri": {c.oauth2Config.RedirectURL},
        }

        // Create basic auth header
        authHeader := base64.StdEncoding.EncodeToString([]byte(c.clientID + ":" + c.clientSecret))

        resp, err := c.httpClient.R().
                SetHeader("Content-Type", "application/x-www-form-urlencoded").
                SetHeader("Authorization", "Basic "+authHeader).
                SetBody(data.Encode()).
                Post("/token")

        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to exchange code for token: %w", err)
        }</span>

        <span class="cov0" title="0">if resp.StatusCode() != http.StatusOK </span><span class="cov0" title="0">{
                return c.handleAPIError(resp)
        }</span>

        <span class="cov0" title="0">var tokenResp TokenResponse
        if err := json.Unmarshal(resp.Body(), &amp;tokenResp); err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to parse token response: %w", err)
        }</span>

        // Store tokens
        <span class="cov0" title="0">c.tokenMutex.Lock()
        c.accessToken = tokenResp.AccessToken
        c.refreshToken = tokenResp.RefreshToken
        c.tokenExpiry = time.Now().Add(time.Duration(tokenResp.ExpiresIn) * time.Second)
        c.tenantID = tokenResp.TenantID
        c.tenantType = tokenResp.TenantType
        c.tokenMutex.Unlock()

        c.logger.Info("Successfully obtained access token", "tenant_id", c.tenantID, "expires_in", tokenResp.ExpiresIn)
        return nil</span>
}

// RefreshAccessToken refreshes the access token using the refresh token
func (c *Client) RefreshAccessToken(ctx context.Context) error <span class="cov0" title="0">{
        c.tokenMutex.RLock()
        refreshToken := c.refreshToken
        c.tokenMutex.RUnlock()

        if refreshToken == "" </span><span class="cov0" title="0">{
                return fmt.Errorf("no refresh token available")
        }</span>

        <span class="cov0" title="0">c.logger.Info("Refreshing access token")

        data := url.Values{
                "grant_type":    {"refresh_token"},
                "refresh_token": {refreshToken},
        }

        authHeader := base64.StdEncoding.EncodeToString([]byte(c.clientID + ":" + c.clientSecret))

        resp, err := c.httpClient.R().
                SetHeader("Content-Type", "application/x-www-form-urlencoded").
                SetHeader("Authorization", "Basic "+authHeader).
                SetBody(data.Encode()).
                Post("/token")

        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to refresh token: %w", err)
        }</span>

        <span class="cov0" title="0">if resp.StatusCode() != http.StatusOK </span><span class="cov0" title="0">{
                return c.handleAPIError(resp)
        }</span>

        <span class="cov0" title="0">var tokenResp TokenResponse
        if err := json.Unmarshal(resp.Body(), &amp;tokenResp); err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to parse token response: %w", err)
        }</span>

        // Update stored tokens
        <span class="cov0" title="0">c.tokenMutex.Lock()
        c.accessToken = tokenResp.AccessToken
        if tokenResp.RefreshToken != "" </span><span class="cov0" title="0">{
                c.refreshToken = tokenResp.RefreshToken
        }</span>
        <span class="cov0" title="0">c.tokenExpiry = time.Now().Add(time.Duration(tokenResp.ExpiresIn) * time.Second)
        c.tokenMutex.Unlock()

        c.logger.Info("Successfully refreshed access token")
        return nil</span>
}

// AuthenticateClientCredentials authenticates using client credentials for General API
func (c *Client) AuthenticateClientCredentials(ctx context.Context) error <span class="cov0" title="0">{
        c.logger.Info("Authenticating with client credentials")

        data := url.Values{
                "grant_type": {"client_credentials"},
        }

        authHeader := base64.StdEncoding.EncodeToString([]byte(c.clientID + ":" + c.clientSecret))

        resp, err := c.httpClient.R().
                SetHeader("Content-Type", "application/x-www-form-urlencoded").
                SetHeader("Authorization", "Basic "+authHeader).
                SetBody(data.Encode()).
                Post("/token")

        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to authenticate with client credentials: %w", err)
        }</span>

        <span class="cov0" title="0">if resp.StatusCode() != http.StatusOK </span><span class="cov0" title="0">{
                return c.handleAPIError(resp)
        }</span>

        <span class="cov0" title="0">var tokenResp TokenResponse
        if err := json.Unmarshal(resp.Body(), &amp;tokenResp); err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to parse token response: %w", err)
        }</span>

        // Store access token (no refresh token for client credentials)
        <span class="cov0" title="0">c.tokenMutex.Lock()
        c.accessToken = tokenResp.AccessToken
        c.tokenExpiry = time.Now().Add(time.Duration(tokenResp.ExpiresIn) * time.Second)
        c.tenantID = tokenResp.TenantID
        c.tenantType = tokenResp.TenantType
        c.tokenMutex.Unlock()

        c.logger.Info("Successfully authenticated with client credentials")
        return nil</span>
}

// ensureValidToken ensures we have a valid access token, refreshing if necessary
func (c *Client) ensureValidToken(ctx context.Context) error <span class="cov0" title="0">{
        c.tokenMutex.RLock()
        hasToken := c.accessToken != ""
        isExpired := time.Now().Add(5 * time.Minute).After(c.tokenExpiry) // Refresh 5 minutes early
        hasRefreshToken := c.refreshToken != ""
        c.tokenMutex.RUnlock()

        if !hasToken </span><span class="cov0" title="0">{
                return fmt.Errorf("no access token available, please authenticate first")
        }</span>

        <span class="cov0" title="0">if isExpired &amp;&amp; hasRefreshToken </span><span class="cov0" title="0">{
                return c.RefreshAccessToken(ctx)
        }</span>

        <span class="cov0" title="0">return nil</span>
}

// makeRequest performs a rate-limited HTTP request with proper authentication
func (c *Client) makeRequest(ctx context.Context, method, path string, body interface{}) (*resty.Response, error) <span class="cov0" title="0">{
        // Check read-only mode for write operations
        if method != "GET" &amp;&amp; method != "HEAD" &amp;&amp; method != "OPTIONS" </span><span class="cov0" title="0">{
                if err := c.validateWriteOperation(fmt.Sprintf("%s %s", method, path)); err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>
        }
        
        // Rate limiting
        <span class="cov0" title="0">if c.rateLimiter != nil </span><span class="cov0" title="0">{
                select </span>{
                case &lt;-c.rateLimiter:<span class="cov0" title="0"></span>
                case &lt;-ctx.Done():<span class="cov0" title="0">
                        return nil, ctx.Err()</span>
                }
        }

        // Ensure we have a valid token
        <span class="cov0" title="0">if err := c.ensureValidToken(ctx); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        // Get current access token
        <span class="cov0" title="0">c.tokenMutex.RLock()
        accessToken := c.accessToken
        c.tokenMutex.RUnlock()

        req := c.httpClient.R().
                SetContext(ctx).
                SetHeader("Authorization", "Bearer "+accessToken).
                SetHeader("Content-Type", "application/json")

        if body != nil </span><span class="cov0" title="0">{
                req.SetBody(body)
        }</span>

        <span class="cov0" title="0">var resp *resty.Response
        var err error

        switch strings.ToUpper(method) </span>{
        case "GET":<span class="cov0" title="0">
                resp, err = req.Get(path)</span>
        case "POST":<span class="cov0" title="0">
                resp, err = req.Post(path)</span>
        case "PUT":<span class="cov0" title="0">
                resp, err = req.Put(path)</span>
        case "DELETE":<span class="cov0" title="0">
                resp, err = req.Delete(path)</span>
        case "PATCH":<span class="cov0" title="0">
                resp, err = req.Patch(path)</span>
        default:<span class="cov0" title="0">
                return nil, fmt.Errorf("unsupported HTTP method: %s", method)</span>
        }

        <span class="cov0" title="0">if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("HTTP request failed: %w", err)
        }</span>

        // Handle API errors
        <span class="cov0" title="0">if resp.StatusCode() &gt;= 400 </span><span class="cov0" title="0">{
                return resp, c.handleAPIError(resp)
        }</span>

        <span class="cov0" title="0">return resp, nil</span>
}

// GET performs a GET request to the specified path
func (c *Client) GET(ctx context.Context, path string) (*resty.Response, error) <span class="cov0" title="0">{
        return c.makeRequest(ctx, "GET", path, nil)
}</span>

// POST performs a POST request to the specified path with the given body
func (c *Client) POST(ctx context.Context, path string, body interface{}) (*resty.Response, error) <span class="cov0" title="0">{
        return c.makeRequest(ctx, "POST", path, body)
}</span>

// PUT performs a PUT request to the specified path with the given body
func (c *Client) PUT(ctx context.Context, path string, body interface{}) (*resty.Response, error) <span class="cov0" title="0">{
        return c.makeRequest(ctx, "PUT", path, body)
}</span>

// DELETE performs a DELETE request to the specified path
func (c *Client) DELETE(ctx context.Context, path string) (*resty.Response, error) <span class="cov0" title="0">{
        return c.makeRequest(ctx, "DELETE", path, nil)
}</span>

// PATCH performs a PATCH request to the specified path with the given body
func (c *Client) PATCH(ctx context.Context, path string, body interface{}) (*resty.Response, error) <span class="cov0" title="0">{
        return c.makeRequest(ctx, "PATCH", path, body)
}</span>

// handleAPIError processes API error responses and returns a structured error
func (c *Client) handleAPIError(resp *resty.Response) error <span class="cov0" title="0">{
        var apiError APIError
        
        // Try to parse the error response
        if err := json.Unmarshal(resp.Body(), &amp;apiError); err != nil </span><span class="cov0" title="0">{
                // If we can't parse the error, create a generic one
                apiError = APIError{
                        Code:    resp.StatusCode(),
                        Message: "API request failed",
                        Details: string(resp.Body()),
                }
        }</span>

        // If no code was set, use the HTTP status code
        <span class="cov0" title="0">if apiError.Code == 0 </span><span class="cov0" title="0">{
                apiError.Code = resp.StatusCode()
        }</span>

        <span class="cov0" title="0">c.logger.Error("API error", "status", resp.StatusCode(), "error", apiError.Message)
        return &amp;apiError</span>
}

// GetTenantInfo returns the current tenant information
func (c *Client) GetTenantInfo() (tenantID, tenantType string) <span class="cov0" title="0">{
        c.tokenMutex.RLock()
        defer c.tokenMutex.RUnlock()
        return c.tenantID, c.tenantType
}</span>

// IsAuthenticated returns whether the client has a valid access token
func (c *Client) IsAuthenticated() bool <span class="cov0" title="0">{
        c.tokenMutex.RLock()
        defer c.tokenMutex.RUnlock()
        return c.accessToken != "" &amp;&amp; time.Now().Before(c.tokenExpiry)
}</span>

// SetTokens manually sets the access and refresh tokens (useful for token persistence)
func (c *Client) SetTokens(accessToken, refreshToken string, expiresAt time.Time) <span class="cov0" title="0">{
        c.tokenMutex.Lock()
        defer c.tokenMutex.Unlock()
        c.accessToken = accessToken
        c.refreshToken = refreshToken
        c.tokenExpiry = expiresAt
}</span>

// GetTokens returns the current tokens (useful for token persistence)
func (c *Client) GetTokens() (accessToken, refreshToken string, expiresAt time.Time) <span class="cov0" title="0">{
        c.tokenMutex.RLock()
        defer c.tokenMutex.RUnlock()
        return c.accessToken, c.refreshToken, c.tokenExpiry
}</span>

// GetConfig returns the client configuration
func (c *Client) GetConfig() Config <span class="cov0" title="0">{
        return Config{
                ClientID:     c.clientID,
                ClientSecret: c.clientSecret,
                BaseURL:      c.baseURL,
                RedirectURI:  c.oauth2Config.RedirectURL,
                Scopes:       c.oauth2Config.Scopes,
                ReadOnly:     c.readOnly,
                Logger:       c.logger,
        }
}</span>

// AuthenticatedGET performs a GET request with Bearer token authentication
func (c *Client) AuthenticatedGET(ctx context.Context, path string) (*resty.Response, error) <span class="cov0" title="0">{
        return c.makeAuthenticatedRequest(ctx, "GET", path, nil)
}</span>

// AuthenticatedPOST performs a POST request with Bearer token authentication  
func (c *Client) AuthenticatedPOST(ctx context.Context, path string, body interface{}) (*resty.Response, error) <span class="cov0" title="0">{
        return c.makeAuthenticatedRequest(ctx, "POST", path, body)
}</span>

// AuthenticatedPUT performs a PUT request with Bearer token authentication
func (c *Client) AuthenticatedPUT(ctx context.Context, path string, body interface{}) (*resty.Response, error) <span class="cov0" title="0">{
        return c.makeAuthenticatedRequest(ctx, "PUT", path, body)
}</span>

// AuthenticatedDELETE performs a DELETE request with Bearer token authentication
func (c *Client) AuthenticatedDELETE(ctx context.Context, path string) (*resty.Response, error) <span class="cov0" title="0">{
        return c.makeAuthenticatedRequest(ctx, "DELETE", path, nil)
}</span>

// AuthenticatedPATCH performs a PATCH request with Bearer token authentication
func (c *Client) AuthenticatedPATCH(ctx context.Context, path string, body interface{}) (*resty.Response, error) <span class="cov0" title="0">{
        return c.makeAuthenticatedRequest(ctx, "PATCH", path, body)
}</span>

// makeAuthenticatedRequest performs a request with Bearer token authentication
func (c *Client) makeAuthenticatedRequest(ctx context.Context, method, path string, body interface{}) (*resty.Response, error) <span class="cov0" title="0">{
        // Use Integration token if available (new method)
        if c.integrationToken != "" </span><span class="cov0" title="0">{
                return c.makeRequestWithBearerToken(ctx, method, path, body, c.integrationToken)
        }</span>

        // Fallback to legacy OAuth2 middleware for backward compatibility
        <span class="cov0" title="0">if c.authMiddleware != nil </span><span class="cov0" title="0">{
                return c.authMiddleware.MakeAuthenticatedRequest(ctx, method, path, body)
        }</span>

        <span class="cov0" title="0">return nil, fmt.Errorf("no authentication method configured - please provide BOKIO_INTEGRATION_TOKEN")</span>
}

// makeRequestWithBearerToken performs a request with Bearer token authentication
func (c *Client) makeRequestWithBearerToken(ctx context.Context, method, path string, body interface{}, token string) (*resty.Response, error) <span class="cov0" title="0">{
        // Rate limiting
        if c.rateLimiter != nil </span><span class="cov0" title="0">{
                select </span>{
                case &lt;-c.rateLimiter:<span class="cov0" title="0"></span>
                case &lt;-ctx.Done():<span class="cov0" title="0">
                        return nil, ctx.Err()</span>
                }
        }

        // Create request
        <span class="cov0" title="0">req := c.httpClient.R().SetContext(ctx)
        
        // Set Bearer token
        req.SetAuthToken(token)
        
        // Set body if provided
        if body != nil </span><span class="cov0" title="0">{
                req.SetBody(body)
        }</span>

        // Make request based on method
        <span class="cov0" title="0">var resp *resty.Response
        var err error

        switch method </span>{
        case "GET":<span class="cov0" title="0">
                resp, err = req.Get(path)</span>
        case "POST":<span class="cov0" title="0">
                resp, err = req.Post(path)</span>
        case "PUT":<span class="cov0" title="0">
                resp, err = req.Put(path)</span>
        case "DELETE":<span class="cov0" title="0">
                resp, err = req.Delete(path)</span>
        case "PATCH":<span class="cov0" title="0">
                resp, err = req.Patch(path)</span>
        default:<span class="cov0" title="0">
                return nil, fmt.Errorf("unsupported HTTP method: %s", method)</span>
        }

        <span class="cov0" title="0">if err != nil </span><span class="cov0" title="0">{
                return resp, &amp;APIError{
                        Message: fmt.Sprintf("HTTP request failed: %s", err.Error()),
                        Code:    0,
                }
        }</span>

        // Check for API errors
        <span class="cov0" title="0">if resp.StatusCode() &gt;= 400 </span><span class="cov0" title="0">{
                return resp, c.parseAPIError(resp)
        }</span>

        <span class="cov0" title="0">return resp, nil</span>
}

// parseAPIError parses API error responses
func (c *Client) parseAPIError(resp *resty.Response) error <span class="cov0" title="0">{
        var apiErrorResponse APIErrorResponse
        if err := json.Unmarshal(resp.Body(), &amp;apiErrorResponse); err != nil </span><span class="cov0" title="0">{
                // If we can't parse the error response, create a generic error
                return &amp;APIError{
                        Code:    resp.StatusCode(),
                        Message: fmt.Sprintf("API request failed with status %d: %s", resp.StatusCode(), resp.String()),
                }
        }</span>

        // Convert APIErrorResponse to APIError
        <span class="cov0" title="0">details := ""
        if len(apiErrorResponse.Errors) &gt; 0 </span><span class="cov0" title="0">{
                var detailMessages []string
                for _, detail := range apiErrorResponse.Errors </span><span class="cov0" title="0">{
                        detailMessages = append(detailMessages, fmt.Sprintf("%s: %s", detail.Field, detail.Message))
                }</span>
                <span class="cov0" title="0">details = strings.Join(detailMessages, "; ")</span>
        }

        <span class="cov0" title="0">return &amp;APIError{
                Code:    resp.StatusCode(),
                Message: apiErrorResponse.Message,
                Details: details,
        }</span>
}

// EnsureAuthenticated ensures the client is authenticated
func (c *Client) EnsureAuthenticated(ctx context.Context) error <span class="cov0" title="0">{
        // Check if Integration token is available (new method)
        if c.integrationToken != "" </span><span class="cov0" title="0">{
                c.logger.Debug("Using Integration token authentication")
                return nil // Integration tokens don't expire, no validation needed
        }</span>

        // Fallback to legacy OAuth2 authentication for backward compatibility
        <span class="cov0" title="0">if c.authMiddleware != nil </span><span class="cov0" title="0">{
                return c.authMiddleware.EnsureAuthenticated(ctx)
        }</span>

        <span class="cov0" title="0">return fmt.Errorf("no authentication method configured - please provide BOKIO_INTEGRATION_TOKEN")</span>
}

// ClearAuthentication clears all authentication data
func (c *Client) ClearAuthentication() error <span class="cov0" title="0">{
        return c.authMiddleware.ClearAuthentication()
}</span>

// GetAuthenticationStatus returns current authentication status
func (c *Client) GetAuthenticationStatus() (authenticated bool, tenantID, tenantType string, expiresAt time.Time, hasRefreshToken bool) <span class="cov0" title="0">{
        return c.authMiddleware.GetAuthenticationStatus()
}</pre>
		
		<pre class="file" id="file2" style="display: none">//go:build !ignore

// Package company provides primitives to interact with the openapi HTTP API.
//
// Code generated by github.com/deepmap/oapi-codegen version v1.16.3 DO NOT EDIT.
//
package company

import (
        "bytes"
        "context"
        "encoding/json"
        "fmt"
        "io"
        "net/http"
        "net/url"
        "strings"

        "github.com/oapi-codegen/runtime"
        openapi_types "github.com/oapi-codegen/runtime/types"
)

// RequestEditorFn  is the function signature for the RequestEditor callback function
type RequestEditorFn func(ctx context.Context, req *http.Request) error

// Doer performs HTTP requests.
//
// The standard http.Client implements this interface.
type HttpRequestDoer interface {
        Do(req *http.Request) (*http.Response, error)
}

// Client which conforms to the OpenAPI3 specification for this service.
type Client struct {
        // The endpoint of the server conforming to this interface, with scheme,
        // https://api.deepmap.com for example. This can contain a path relative
        // to the server, such as https://api.deepmap.com/dev-test, and all the
        // paths in the swagger spec will be appended to the server.
        Server string

        // Doer for performing requests, typically a *http.Client with any
        // customized settings, such as certificate chains.
        Client HttpRequestDoer

        // A list of callbacks for modifying requests which are generated before sending over
        // the network.
        RequestEditors []RequestEditorFn
}

// ClientOption allows setting custom parameters during construction
type ClientOption func(*Client) error

// Creates a new Client, with reasonable defaults
func NewClient(server string, opts ...ClientOption) (*Client, error) <span class="cov0" title="0">{
        // create a client with sane default values
        client := Client{
                Server: server,
        }
        // mutate client and add all optional params
        for _, o := range opts </span><span class="cov0" title="0">{
                if err := o(&amp;client); err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>
        }
        // ensure the server URL always has a trailing slash
        <span class="cov0" title="0">if !strings.HasSuffix(client.Server, "/") </span><span class="cov0" title="0">{
                client.Server += "/"
        }</span>
        // create httpClient, if not already present
        <span class="cov0" title="0">if client.Client == nil </span><span class="cov0" title="0">{
                client.Client = &amp;http.Client{}
        }</span>
        <span class="cov0" title="0">return &amp;client, nil</span>
}

// WithHTTPClient allows overriding the default Doer, which is
// automatically created using http.Client. This is useful for tests.
func WithHTTPClient(doer HttpRequestDoer) ClientOption <span class="cov0" title="0">{
        return func(c *Client) error </span><span class="cov0" title="0">{
                c.Client = doer
                return nil
        }</span>
}

// WithRequestEditorFn allows setting up a callback function, which will be
// called right before sending the request. This can be used to mutate the request.
func WithRequestEditorFn(fn RequestEditorFn) ClientOption <span class="cov0" title="0">{
        return func(c *Client) error </span><span class="cov0" title="0">{
                c.RequestEditors = append(c.RequestEditors, fn)
                return nil
        }</span>
}

// The interface specification for the client above.
type ClientInterface interface {
        // GetCustomer request
        GetCustomer(ctx context.Context, companyId openapi_types.UUID, params *GetCustomerParams, reqEditors ...RequestEditorFn) (*http.Response, error)

        // PostCustomerWithBody request with any body
        PostCustomerWithBody(ctx context.Context, companyId openapi_types.UUID, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

        PostCustomer(ctx context.Context, companyId openapi_types.UUID, body PostCustomerJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

        // DeleteCustomer request
        DeleteCustomer(ctx context.Context, companyId openapi_types.UUID, customerId openapi_types.UUID, reqEditors ...RequestEditorFn) (*http.Response, error)

        // GetCustomersCustomerId request
        GetCustomersCustomerId(ctx context.Context, companyId openapi_types.UUID, customerId openapi_types.UUID, reqEditors ...RequestEditorFn) (*http.Response, error)

        // PutCustomerWithBody request with any body
        PutCustomerWithBody(ctx context.Context, companyId openapi_types.UUID, customerId openapi_types.UUID, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

        PutCustomer(ctx context.Context, companyId openapi_types.UUID, customerId openapi_types.UUID, body PutCustomerJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

        // GetFiscalYears request
        GetFiscalYears(ctx context.Context, companyId openapi_types.UUID, params *GetFiscalYearsParams, reqEditors ...RequestEditorFn) (*http.Response, error)

        // GetFiscalYearWithId request
        GetFiscalYearWithId(ctx context.Context, companyId openapi_types.UUID, fiscalYearId openapi_types.UUID, reqEditors ...RequestEditorFn) (*http.Response, error)

        // GetInvoice request
        GetInvoice(ctx context.Context, companyId openapi_types.UUID, params *GetInvoiceParams, reqEditors ...RequestEditorFn) (*http.Response, error)

        // PostInvoiceWithBody request with any body
        PostInvoiceWithBody(ctx context.Context, companyId openapi_types.UUID, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

        PostInvoice(ctx context.Context, companyId openapi_types.UUID, body PostInvoiceJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

        // GetInvoicesInvoiceId request
        GetInvoicesInvoiceId(ctx context.Context, companyId openapi_types.UUID, invoiceId openapi_types.UUID, reqEditors ...RequestEditorFn) (*http.Response, error)

        // PutInvoiceWithBody request with any body
        PutInvoiceWithBody(ctx context.Context, companyId openapi_types.UUID, invoiceId openapi_types.UUID, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

        PutInvoice(ctx context.Context, companyId openapi_types.UUID, invoiceId openapi_types.UUID, body PutInvoiceJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

        // GetInvoiceAttachments request
        GetInvoiceAttachments(ctx context.Context, companyId openapi_types.UUID, invoiceId openapi_types.UUID, params *GetInvoiceAttachmentsParams, reqEditors ...RequestEditorFn) (*http.Response, error)

        // PostInvoiceAttachmentWithBody request with any body
        PostInvoiceAttachmentWithBody(ctx context.Context, companyId openapi_types.UUID, invoiceId openapi_types.UUID, params *PostInvoiceAttachmentParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

        // DeleteInvoiceAttachment request
        DeleteInvoiceAttachment(ctx context.Context, companyId openapi_types.UUID, invoiceId openapi_types.UUID, attachmentId openapi_types.UUID, reqEditors ...RequestEditorFn) (*http.Response, error)

        // GetInvoiceAttachment request
        GetInvoiceAttachment(ctx context.Context, companyId openapi_types.UUID, invoiceId openapi_types.UUID, attachmentId openapi_types.UUID, reqEditors ...RequestEditorFn) (*http.Response, error)

        // DownloadInvoiceAttachment request
        DownloadInvoiceAttachment(ctx context.Context, companyId openapi_types.UUID, invoiceId openapi_types.UUID, attachmentId openapi_types.UUID, reqEditors ...RequestEditorFn) (*http.Response, error)

        // PostInvoiceLineItemWithBody request with any body
        PostInvoiceLineItemWithBody(ctx context.Context, companyId openapi_types.UUID, invoiceId openapi_types.UUID, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

        PostInvoiceLineItem(ctx context.Context, companyId openapi_types.UUID, invoiceId openapi_types.UUID, body PostInvoiceLineItemJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

        // GetItems request
        GetItems(ctx context.Context, companyId openapi_types.UUID, params *GetItemsParams, reqEditors ...RequestEditorFn) (*http.Response, error)

        // PostItemWithBody request with any body
        PostItemWithBody(ctx context.Context, companyId openapi_types.UUID, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

        PostItem(ctx context.Context, companyId openapi_types.UUID, body PostItemJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

        // DeleteItem request
        DeleteItem(ctx context.Context, companyId openapi_types.UUID, itemId openapi_types.UUID, reqEditors ...RequestEditorFn) (*http.Response, error)

        // GetItemsItemId request
        GetItemsItemId(ctx context.Context, companyId openapi_types.UUID, itemId openapi_types.UUID, reqEditors ...RequestEditorFn) (*http.Response, error)

        // PutItemWithBody request with any body
        PutItemWithBody(ctx context.Context, companyId openapi_types.UUID, itemId openapi_types.UUID, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

        PutItem(ctx context.Context, companyId openapi_types.UUID, itemId openapi_types.UUID, body PutItemJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

        // GetJournalentry request
        GetJournalentry(ctx context.Context, companyId openapi_types.UUID, params *GetJournalentryParams, reqEditors ...RequestEditorFn) (*http.Response, error)

        // PostJournalentryWithBody request with any body
        PostJournalentryWithBody(ctx context.Context, companyId openapi_types.UUID, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

        PostJournalentry(ctx context.Context, companyId openapi_types.UUID, body PostJournalentryJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

        // GetJournalentriesJournalId request
        GetJournalentriesJournalId(ctx context.Context, companyId openapi_types.UUID, journalEntryId openapi_types.UUID, reqEditors ...RequestEditorFn) (*http.Response, error)

        // ReverseJournalentry request
        ReverseJournalentry(ctx context.Context, companyId openapi_types.UUID, journalEntryId openapi_types.UUID, reqEditors ...RequestEditorFn) (*http.Response, error)

        // DownloadSieFile request
        DownloadSieFile(ctx context.Context, companyId openapi_types.UUID, fiscalYearId openapi_types.UUID, reqEditors ...RequestEditorFn) (*http.Response, error)

        // GetUploads request
        GetUploads(ctx context.Context, companyId openapi_types.UUID, params *GetUploadsParams, reqEditors ...RequestEditorFn) (*http.Response, error)

        // AddUploadWithBody request with any body
        AddUploadWithBody(ctx context.Context, companyId openapi_types.UUID, params *AddUploadParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

        // GetUpload request
        GetUpload(ctx context.Context, companyId openapi_types.UUID, uploadId openapi_types.UUID, reqEditors ...RequestEditorFn) (*http.Response, error)

        // DownloadUpload request
        DownloadUpload(ctx context.Context, companyId openapi_types.UUID, uploadId openapi_types.UUID, reqEditors ...RequestEditorFn) (*http.Response, error)
}

func (c *Client) GetCustomer(ctx context.Context, companyId openapi_types.UUID, params *GetCustomerParams, reqEditors ...RequestEditorFn) (*http.Response, error) <span class="cov0" title="0">{
        req, err := NewGetCustomerRequest(c.Server, companyId, params)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">req = req.WithContext(ctx)
        if err := c.applyEditors(ctx, req, reqEditors); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">return c.Client.Do(req)</span>
}

func (c *Client) PostCustomerWithBody(ctx context.Context, companyId openapi_types.UUID, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) <span class="cov0" title="0">{
        req, err := NewPostCustomerRequestWithBody(c.Server, companyId, contentType, body)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">req = req.WithContext(ctx)
        if err := c.applyEditors(ctx, req, reqEditors); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">return c.Client.Do(req)</span>
}

func (c *Client) PostCustomer(ctx context.Context, companyId openapi_types.UUID, body PostCustomerJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) <span class="cov0" title="0">{
        req, err := NewPostCustomerRequest(c.Server, companyId, body)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">req = req.WithContext(ctx)
        if err := c.applyEditors(ctx, req, reqEditors); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">return c.Client.Do(req)</span>
}

func (c *Client) DeleteCustomer(ctx context.Context, companyId openapi_types.UUID, customerId openapi_types.UUID, reqEditors ...RequestEditorFn) (*http.Response, error) <span class="cov0" title="0">{
        req, err := NewDeleteCustomerRequest(c.Server, companyId, customerId)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">req = req.WithContext(ctx)
        if err := c.applyEditors(ctx, req, reqEditors); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">return c.Client.Do(req)</span>
}

func (c *Client) GetCustomersCustomerId(ctx context.Context, companyId openapi_types.UUID, customerId openapi_types.UUID, reqEditors ...RequestEditorFn) (*http.Response, error) <span class="cov0" title="0">{
        req, err := NewGetCustomersCustomerIdRequest(c.Server, companyId, customerId)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">req = req.WithContext(ctx)
        if err := c.applyEditors(ctx, req, reqEditors); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">return c.Client.Do(req)</span>
}

func (c *Client) PutCustomerWithBody(ctx context.Context, companyId openapi_types.UUID, customerId openapi_types.UUID, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) <span class="cov0" title="0">{
        req, err := NewPutCustomerRequestWithBody(c.Server, companyId, customerId, contentType, body)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">req = req.WithContext(ctx)
        if err := c.applyEditors(ctx, req, reqEditors); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">return c.Client.Do(req)</span>
}

func (c *Client) PutCustomer(ctx context.Context, companyId openapi_types.UUID, customerId openapi_types.UUID, body PutCustomerJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) <span class="cov0" title="0">{
        req, err := NewPutCustomerRequest(c.Server, companyId, customerId, body)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">req = req.WithContext(ctx)
        if err := c.applyEditors(ctx, req, reqEditors); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">return c.Client.Do(req)</span>
}

func (c *Client) GetFiscalYears(ctx context.Context, companyId openapi_types.UUID, params *GetFiscalYearsParams, reqEditors ...RequestEditorFn) (*http.Response, error) <span class="cov0" title="0">{
        req, err := NewGetFiscalYearsRequest(c.Server, companyId, params)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">req = req.WithContext(ctx)
        if err := c.applyEditors(ctx, req, reqEditors); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">return c.Client.Do(req)</span>
}

func (c *Client) GetFiscalYearWithId(ctx context.Context, companyId openapi_types.UUID, fiscalYearId openapi_types.UUID, reqEditors ...RequestEditorFn) (*http.Response, error) <span class="cov0" title="0">{
        req, err := NewGetFiscalYearWithIdRequest(c.Server, companyId, fiscalYearId)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">req = req.WithContext(ctx)
        if err := c.applyEditors(ctx, req, reqEditors); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">return c.Client.Do(req)</span>
}

func (c *Client) GetInvoice(ctx context.Context, companyId openapi_types.UUID, params *GetInvoiceParams, reqEditors ...RequestEditorFn) (*http.Response, error) <span class="cov0" title="0">{
        req, err := NewGetInvoiceRequest(c.Server, companyId, params)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">req = req.WithContext(ctx)
        if err := c.applyEditors(ctx, req, reqEditors); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">return c.Client.Do(req)</span>
}

func (c *Client) PostInvoiceWithBody(ctx context.Context, companyId openapi_types.UUID, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) <span class="cov0" title="0">{
        req, err := NewPostInvoiceRequestWithBody(c.Server, companyId, contentType, body)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">req = req.WithContext(ctx)
        if err := c.applyEditors(ctx, req, reqEditors); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">return c.Client.Do(req)</span>
}

func (c *Client) PostInvoice(ctx context.Context, companyId openapi_types.UUID, body PostInvoiceJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) <span class="cov0" title="0">{
        req, err := NewPostInvoiceRequest(c.Server, companyId, body)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">req = req.WithContext(ctx)
        if err := c.applyEditors(ctx, req, reqEditors); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">return c.Client.Do(req)</span>
}

func (c *Client) GetInvoicesInvoiceId(ctx context.Context, companyId openapi_types.UUID, invoiceId openapi_types.UUID, reqEditors ...RequestEditorFn) (*http.Response, error) <span class="cov0" title="0">{
        req, err := NewGetInvoicesInvoiceIdRequest(c.Server, companyId, invoiceId)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">req = req.WithContext(ctx)
        if err := c.applyEditors(ctx, req, reqEditors); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">return c.Client.Do(req)</span>
}

func (c *Client) PutInvoiceWithBody(ctx context.Context, companyId openapi_types.UUID, invoiceId openapi_types.UUID, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) <span class="cov0" title="0">{
        req, err := NewPutInvoiceRequestWithBody(c.Server, companyId, invoiceId, contentType, body)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">req = req.WithContext(ctx)
        if err := c.applyEditors(ctx, req, reqEditors); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">return c.Client.Do(req)</span>
}

func (c *Client) PutInvoice(ctx context.Context, companyId openapi_types.UUID, invoiceId openapi_types.UUID, body PutInvoiceJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) <span class="cov0" title="0">{
        req, err := NewPutInvoiceRequest(c.Server, companyId, invoiceId, body)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">req = req.WithContext(ctx)
        if err := c.applyEditors(ctx, req, reqEditors); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">return c.Client.Do(req)</span>
}

func (c *Client) GetInvoiceAttachments(ctx context.Context, companyId openapi_types.UUID, invoiceId openapi_types.UUID, params *GetInvoiceAttachmentsParams, reqEditors ...RequestEditorFn) (*http.Response, error) <span class="cov0" title="0">{
        req, err := NewGetInvoiceAttachmentsRequest(c.Server, companyId, invoiceId, params)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">req = req.WithContext(ctx)
        if err := c.applyEditors(ctx, req, reqEditors); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">return c.Client.Do(req)</span>
}

func (c *Client) PostInvoiceAttachmentWithBody(ctx context.Context, companyId openapi_types.UUID, invoiceId openapi_types.UUID, params *PostInvoiceAttachmentParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) <span class="cov0" title="0">{
        req, err := NewPostInvoiceAttachmentRequestWithBody(c.Server, companyId, invoiceId, params, contentType, body)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">req = req.WithContext(ctx)
        if err := c.applyEditors(ctx, req, reqEditors); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">return c.Client.Do(req)</span>
}

func (c *Client) DeleteInvoiceAttachment(ctx context.Context, companyId openapi_types.UUID, invoiceId openapi_types.UUID, attachmentId openapi_types.UUID, reqEditors ...RequestEditorFn) (*http.Response, error) <span class="cov0" title="0">{
        req, err := NewDeleteInvoiceAttachmentRequest(c.Server, companyId, invoiceId, attachmentId)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">req = req.WithContext(ctx)
        if err := c.applyEditors(ctx, req, reqEditors); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">return c.Client.Do(req)</span>
}

func (c *Client) GetInvoiceAttachment(ctx context.Context, companyId openapi_types.UUID, invoiceId openapi_types.UUID, attachmentId openapi_types.UUID, reqEditors ...RequestEditorFn) (*http.Response, error) <span class="cov0" title="0">{
        req, err := NewGetInvoiceAttachmentRequest(c.Server, companyId, invoiceId, attachmentId)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">req = req.WithContext(ctx)
        if err := c.applyEditors(ctx, req, reqEditors); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">return c.Client.Do(req)</span>
}

func (c *Client) DownloadInvoiceAttachment(ctx context.Context, companyId openapi_types.UUID, invoiceId openapi_types.UUID, attachmentId openapi_types.UUID, reqEditors ...RequestEditorFn) (*http.Response, error) <span class="cov0" title="0">{
        req, err := NewDownloadInvoiceAttachmentRequest(c.Server, companyId, invoiceId, attachmentId)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">req = req.WithContext(ctx)
        if err := c.applyEditors(ctx, req, reqEditors); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">return c.Client.Do(req)</span>
}

func (c *Client) PostInvoiceLineItemWithBody(ctx context.Context, companyId openapi_types.UUID, invoiceId openapi_types.UUID, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) <span class="cov0" title="0">{
        req, err := NewPostInvoiceLineItemRequestWithBody(c.Server, companyId, invoiceId, contentType, body)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">req = req.WithContext(ctx)
        if err := c.applyEditors(ctx, req, reqEditors); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">return c.Client.Do(req)</span>
}

func (c *Client) PostInvoiceLineItem(ctx context.Context, companyId openapi_types.UUID, invoiceId openapi_types.UUID, body PostInvoiceLineItemJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) <span class="cov0" title="0">{
        req, err := NewPostInvoiceLineItemRequest(c.Server, companyId, invoiceId, body)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">req = req.WithContext(ctx)
        if err := c.applyEditors(ctx, req, reqEditors); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">return c.Client.Do(req)</span>
}

func (c *Client) GetItems(ctx context.Context, companyId openapi_types.UUID, params *GetItemsParams, reqEditors ...RequestEditorFn) (*http.Response, error) <span class="cov0" title="0">{
        req, err := NewGetItemsRequest(c.Server, companyId, params)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">req = req.WithContext(ctx)
        if err := c.applyEditors(ctx, req, reqEditors); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">return c.Client.Do(req)</span>
}

func (c *Client) PostItemWithBody(ctx context.Context, companyId openapi_types.UUID, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) <span class="cov0" title="0">{
        req, err := NewPostItemRequestWithBody(c.Server, companyId, contentType, body)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">req = req.WithContext(ctx)
        if err := c.applyEditors(ctx, req, reqEditors); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">return c.Client.Do(req)</span>
}

func (c *Client) PostItem(ctx context.Context, companyId openapi_types.UUID, body PostItemJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) <span class="cov0" title="0">{
        req, err := NewPostItemRequest(c.Server, companyId, body)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">req = req.WithContext(ctx)
        if err := c.applyEditors(ctx, req, reqEditors); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">return c.Client.Do(req)</span>
}

func (c *Client) DeleteItem(ctx context.Context, companyId openapi_types.UUID, itemId openapi_types.UUID, reqEditors ...RequestEditorFn) (*http.Response, error) <span class="cov0" title="0">{
        req, err := NewDeleteItemRequest(c.Server, companyId, itemId)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">req = req.WithContext(ctx)
        if err := c.applyEditors(ctx, req, reqEditors); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">return c.Client.Do(req)</span>
}

func (c *Client) GetItemsItemId(ctx context.Context, companyId openapi_types.UUID, itemId openapi_types.UUID, reqEditors ...RequestEditorFn) (*http.Response, error) <span class="cov0" title="0">{
        req, err := NewGetItemsItemIdRequest(c.Server, companyId, itemId)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">req = req.WithContext(ctx)
        if err := c.applyEditors(ctx, req, reqEditors); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">return c.Client.Do(req)</span>
}

func (c *Client) PutItemWithBody(ctx context.Context, companyId openapi_types.UUID, itemId openapi_types.UUID, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) <span class="cov0" title="0">{
        req, err := NewPutItemRequestWithBody(c.Server, companyId, itemId, contentType, body)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">req = req.WithContext(ctx)
        if err := c.applyEditors(ctx, req, reqEditors); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">return c.Client.Do(req)</span>
}

func (c *Client) PutItem(ctx context.Context, companyId openapi_types.UUID, itemId openapi_types.UUID, body PutItemJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) <span class="cov0" title="0">{
        req, err := NewPutItemRequest(c.Server, companyId, itemId, body)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">req = req.WithContext(ctx)
        if err := c.applyEditors(ctx, req, reqEditors); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">return c.Client.Do(req)</span>
}

func (c *Client) GetJournalentry(ctx context.Context, companyId openapi_types.UUID, params *GetJournalentryParams, reqEditors ...RequestEditorFn) (*http.Response, error) <span class="cov0" title="0">{
        req, err := NewGetJournalentryRequest(c.Server, companyId, params)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">req = req.WithContext(ctx)
        if err := c.applyEditors(ctx, req, reqEditors); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">return c.Client.Do(req)</span>
}

func (c *Client) PostJournalentryWithBody(ctx context.Context, companyId openapi_types.UUID, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) <span class="cov0" title="0">{
        req, err := NewPostJournalentryRequestWithBody(c.Server, companyId, contentType, body)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">req = req.WithContext(ctx)
        if err := c.applyEditors(ctx, req, reqEditors); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">return c.Client.Do(req)</span>
}

func (c *Client) PostJournalentry(ctx context.Context, companyId openapi_types.UUID, body PostJournalentryJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) <span class="cov0" title="0">{
        req, err := NewPostJournalentryRequest(c.Server, companyId, body)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">req = req.WithContext(ctx)
        if err := c.applyEditors(ctx, req, reqEditors); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">return c.Client.Do(req)</span>
}

func (c *Client) GetJournalentriesJournalId(ctx context.Context, companyId openapi_types.UUID, journalEntryId openapi_types.UUID, reqEditors ...RequestEditorFn) (*http.Response, error) <span class="cov0" title="0">{
        req, err := NewGetJournalentriesJournalIdRequest(c.Server, companyId, journalEntryId)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">req = req.WithContext(ctx)
        if err := c.applyEditors(ctx, req, reqEditors); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">return c.Client.Do(req)</span>
}

func (c *Client) ReverseJournalentry(ctx context.Context, companyId openapi_types.UUID, journalEntryId openapi_types.UUID, reqEditors ...RequestEditorFn) (*http.Response, error) <span class="cov0" title="0">{
        req, err := NewReverseJournalentryRequest(c.Server, companyId, journalEntryId)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">req = req.WithContext(ctx)
        if err := c.applyEditors(ctx, req, reqEditors); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">return c.Client.Do(req)</span>
}

func (c *Client) DownloadSieFile(ctx context.Context, companyId openapi_types.UUID, fiscalYearId openapi_types.UUID, reqEditors ...RequestEditorFn) (*http.Response, error) <span class="cov0" title="0">{
        req, err := NewDownloadSieFileRequest(c.Server, companyId, fiscalYearId)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">req = req.WithContext(ctx)
        if err := c.applyEditors(ctx, req, reqEditors); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">return c.Client.Do(req)</span>
}

func (c *Client) GetUploads(ctx context.Context, companyId openapi_types.UUID, params *GetUploadsParams, reqEditors ...RequestEditorFn) (*http.Response, error) <span class="cov0" title="0">{
        req, err := NewGetUploadsRequest(c.Server, companyId, params)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">req = req.WithContext(ctx)
        if err := c.applyEditors(ctx, req, reqEditors); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">return c.Client.Do(req)</span>
}

func (c *Client) AddUploadWithBody(ctx context.Context, companyId openapi_types.UUID, params *AddUploadParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) <span class="cov0" title="0">{
        req, err := NewAddUploadRequestWithBody(c.Server, companyId, params, contentType, body)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">req = req.WithContext(ctx)
        if err := c.applyEditors(ctx, req, reqEditors); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">return c.Client.Do(req)</span>
}

func (c *Client) GetUpload(ctx context.Context, companyId openapi_types.UUID, uploadId openapi_types.UUID, reqEditors ...RequestEditorFn) (*http.Response, error) <span class="cov0" title="0">{
        req, err := NewGetUploadRequest(c.Server, companyId, uploadId)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">req = req.WithContext(ctx)
        if err := c.applyEditors(ctx, req, reqEditors); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">return c.Client.Do(req)</span>
}

func (c *Client) DownloadUpload(ctx context.Context, companyId openapi_types.UUID, uploadId openapi_types.UUID, reqEditors ...RequestEditorFn) (*http.Response, error) <span class="cov0" title="0">{
        req, err := NewDownloadUploadRequest(c.Server, companyId, uploadId)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">req = req.WithContext(ctx)
        if err := c.applyEditors(ctx, req, reqEditors); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">return c.Client.Do(req)</span>
}

// NewGetCustomerRequest generates requests for GetCustomer
func NewGetCustomerRequest(server string, companyId openapi_types.UUID, params *GetCustomerParams) (*http.Request, error) <span class="cov0" title="0">{
        var err error

        var pathParam0 string

        pathParam0, err = runtime.StyleParamWithLocation("simple", false, "companyId", runtime.ParamLocationPath, companyId)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">serverURL, err := url.Parse(server)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">operationPath := fmt.Sprintf("/v1/companies/%s/customers", pathParam0)
        if operationPath[0] == '/' </span><span class="cov0" title="0">{
                operationPath = "." + operationPath
        }</span>

        <span class="cov0" title="0">queryURL, err := serverURL.Parse(operationPath)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">if params != nil </span><span class="cov0" title="0">{
                queryValues := queryURL.Query()

                if params.Page != nil </span><span class="cov0" title="0">{

                        if queryFrag, err := runtime.StyleParamWithLocation("form", true, "page", runtime.ParamLocationQuery, *params.Page); err != nil </span><span class="cov0" title="0">{
                                return nil, err
                        }</span> else<span class="cov0" title="0"> if parsed, err := url.ParseQuery(queryFrag); err != nil </span><span class="cov0" title="0">{
                                return nil, err
                        }</span> else<span class="cov0" title="0"> {
                                for k, v := range parsed </span><span class="cov0" title="0">{
                                        for _, v2 := range v </span><span class="cov0" title="0">{
                                                queryValues.Add(k, v2)
                                        }</span>
                                }
                        }

                }

                <span class="cov0" title="0">if params.PageSize != nil </span><span class="cov0" title="0">{

                        if queryFrag, err := runtime.StyleParamWithLocation("form", true, "pageSize", runtime.ParamLocationQuery, *params.PageSize); err != nil </span><span class="cov0" title="0">{
                                return nil, err
                        }</span> else<span class="cov0" title="0"> if parsed, err := url.ParseQuery(queryFrag); err != nil </span><span class="cov0" title="0">{
                                return nil, err
                        }</span> else<span class="cov0" title="0"> {
                                for k, v := range parsed </span><span class="cov0" title="0">{
                                        for _, v2 := range v </span><span class="cov0" title="0">{
                                                queryValues.Add(k, v2)
                                        }</span>
                                }
                        }

                }

                <span class="cov0" title="0">if params.Query != nil </span><span class="cov0" title="0">{

                        if queryFrag, err := runtime.StyleParamWithLocation("form", true, "query", runtime.ParamLocationQuery, *params.Query); err != nil </span><span class="cov0" title="0">{
                                return nil, err
                        }</span> else<span class="cov0" title="0"> if parsed, err := url.ParseQuery(queryFrag); err != nil </span><span class="cov0" title="0">{
                                return nil, err
                        }</span> else<span class="cov0" title="0"> {
                                for k, v := range parsed </span><span class="cov0" title="0">{
                                        for _, v2 := range v </span><span class="cov0" title="0">{
                                                queryValues.Add(k, v2)
                                        }</span>
                                }
                        }

                }

                <span class="cov0" title="0">queryURL.RawQuery = queryValues.Encode()</span>
        }

        <span class="cov0" title="0">req, err := http.NewRequest("GET", queryURL.String(), nil)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">return req, nil</span>
}

// NewPostCustomerRequest calls the generic PostCustomer builder with application/json body
func NewPostCustomerRequest(server string, companyId openapi_types.UUID, body PostCustomerJSONRequestBody) (*http.Request, error) <span class="cov0" title="0">{
        var bodyReader io.Reader
        buf, err := json.Marshal(body)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">bodyReader = bytes.NewReader(buf)
        return NewPostCustomerRequestWithBody(server, companyId, "application/json", bodyReader)</span>
}

// NewPostCustomerRequestWithBody generates requests for PostCustomer with any type of body
func NewPostCustomerRequestWithBody(server string, companyId openapi_types.UUID, contentType string, body io.Reader) (*http.Request, error) <span class="cov0" title="0">{
        var err error

        var pathParam0 string

        pathParam0, err = runtime.StyleParamWithLocation("simple", false, "companyId", runtime.ParamLocationPath, companyId)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">serverURL, err := url.Parse(server)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">operationPath := fmt.Sprintf("/v1/companies/%s/customers", pathParam0)
        if operationPath[0] == '/' </span><span class="cov0" title="0">{
                operationPath = "." + operationPath
        }</span>

        <span class="cov0" title="0">queryURL, err := serverURL.Parse(operationPath)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">req, err := http.NewRequest("POST", queryURL.String(), body)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">req.Header.Add("Content-Type", contentType)

        return req, nil</span>
}

// NewDeleteCustomerRequest generates requests for DeleteCustomer
func NewDeleteCustomerRequest(server string, companyId openapi_types.UUID, customerId openapi_types.UUID) (*http.Request, error) <span class="cov0" title="0">{
        var err error

        var pathParam0 string

        pathParam0, err = runtime.StyleParamWithLocation("simple", false, "companyId", runtime.ParamLocationPath, companyId)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">var pathParam1 string

        pathParam1, err = runtime.StyleParamWithLocation("simple", false, "customerId", runtime.ParamLocationPath, customerId)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">serverURL, err := url.Parse(server)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">operationPath := fmt.Sprintf("/v1/companies/%s/customers/%s", pathParam0, pathParam1)
        if operationPath[0] == '/' </span><span class="cov0" title="0">{
                operationPath = "." + operationPath
        }</span>

        <span class="cov0" title="0">queryURL, err := serverURL.Parse(operationPath)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">req, err := http.NewRequest("DELETE", queryURL.String(), nil)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">return req, nil</span>
}

// NewGetCustomersCustomerIdRequest generates requests for GetCustomersCustomerId
func NewGetCustomersCustomerIdRequest(server string, companyId openapi_types.UUID, customerId openapi_types.UUID) (*http.Request, error) <span class="cov0" title="0">{
        var err error

        var pathParam0 string

        pathParam0, err = runtime.StyleParamWithLocation("simple", false, "companyId", runtime.ParamLocationPath, companyId)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">var pathParam1 string

        pathParam1, err = runtime.StyleParamWithLocation("simple", false, "customerId", runtime.ParamLocationPath, customerId)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">serverURL, err := url.Parse(server)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">operationPath := fmt.Sprintf("/v1/companies/%s/customers/%s", pathParam0, pathParam1)
        if operationPath[0] == '/' </span><span class="cov0" title="0">{
                operationPath = "." + operationPath
        }</span>

        <span class="cov0" title="0">queryURL, err := serverURL.Parse(operationPath)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">req, err := http.NewRequest("GET", queryURL.String(), nil)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">return req, nil</span>
}

// NewPutCustomerRequest calls the generic PutCustomer builder with application/json body
func NewPutCustomerRequest(server string, companyId openapi_types.UUID, customerId openapi_types.UUID, body PutCustomerJSONRequestBody) (*http.Request, error) <span class="cov0" title="0">{
        var bodyReader io.Reader
        buf, err := json.Marshal(body)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">bodyReader = bytes.NewReader(buf)
        return NewPutCustomerRequestWithBody(server, companyId, customerId, "application/json", bodyReader)</span>
}

// NewPutCustomerRequestWithBody generates requests for PutCustomer with any type of body
func NewPutCustomerRequestWithBody(server string, companyId openapi_types.UUID, customerId openapi_types.UUID, contentType string, body io.Reader) (*http.Request, error) <span class="cov0" title="0">{
        var err error

        var pathParam0 string

        pathParam0, err = runtime.StyleParamWithLocation("simple", false, "companyId", runtime.ParamLocationPath, companyId)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">var pathParam1 string

        pathParam1, err = runtime.StyleParamWithLocation("simple", false, "customerId", runtime.ParamLocationPath, customerId)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">serverURL, err := url.Parse(server)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">operationPath := fmt.Sprintf("/v1/companies/%s/customers/%s", pathParam0, pathParam1)
        if operationPath[0] == '/' </span><span class="cov0" title="0">{
                operationPath = "." + operationPath
        }</span>

        <span class="cov0" title="0">queryURL, err := serverURL.Parse(operationPath)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">req, err := http.NewRequest("PUT", queryURL.String(), body)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">req.Header.Add("Content-Type", contentType)

        return req, nil</span>
}

// NewGetFiscalYearsRequest generates requests for GetFiscalYears
func NewGetFiscalYearsRequest(server string, companyId openapi_types.UUID, params *GetFiscalYearsParams) (*http.Request, error) <span class="cov0" title="0">{
        var err error

        var pathParam0 string

        pathParam0, err = runtime.StyleParamWithLocation("simple", false, "companyId", runtime.ParamLocationPath, companyId)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">serverURL, err := url.Parse(server)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">operationPath := fmt.Sprintf("/v1/companies/%s/fiscal-years", pathParam0)
        if operationPath[0] == '/' </span><span class="cov0" title="0">{
                operationPath = "." + operationPath
        }</span>

        <span class="cov0" title="0">queryURL, err := serverURL.Parse(operationPath)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">if params != nil </span><span class="cov0" title="0">{
                queryValues := queryURL.Query()

                if params.Page != nil </span><span class="cov0" title="0">{

                        if queryFrag, err := runtime.StyleParamWithLocation("form", true, "page", runtime.ParamLocationQuery, *params.Page); err != nil </span><span class="cov0" title="0">{
                                return nil, err
                        }</span> else<span class="cov0" title="0"> if parsed, err := url.ParseQuery(queryFrag); err != nil </span><span class="cov0" title="0">{
                                return nil, err
                        }</span> else<span class="cov0" title="0"> {
                                for k, v := range parsed </span><span class="cov0" title="0">{
                                        for _, v2 := range v </span><span class="cov0" title="0">{
                                                queryValues.Add(k, v2)
                                        }</span>
                                }
                        }

                }

                <span class="cov0" title="0">if params.PageSize != nil </span><span class="cov0" title="0">{

                        if queryFrag, err := runtime.StyleParamWithLocation("form", true, "pageSize", runtime.ParamLocationQuery, *params.PageSize); err != nil </span><span class="cov0" title="0">{
                                return nil, err
                        }</span> else<span class="cov0" title="0"> if parsed, err := url.ParseQuery(queryFrag); err != nil </span><span class="cov0" title="0">{
                                return nil, err
                        }</span> else<span class="cov0" title="0"> {
                                for k, v := range parsed </span><span class="cov0" title="0">{
                                        for _, v2 := range v </span><span class="cov0" title="0">{
                                                queryValues.Add(k, v2)
                                        }</span>
                                }
                        }

                }

                <span class="cov0" title="0">if params.Query != nil </span><span class="cov0" title="0">{

                        if queryFrag, err := runtime.StyleParamWithLocation("form", true, "query", runtime.ParamLocationQuery, *params.Query); err != nil </span><span class="cov0" title="0">{
                                return nil, err
                        }</span> else<span class="cov0" title="0"> if parsed, err := url.ParseQuery(queryFrag); err != nil </span><span class="cov0" title="0">{
                                return nil, err
                        }</span> else<span class="cov0" title="0"> {
                                for k, v := range parsed </span><span class="cov0" title="0">{
                                        for _, v2 := range v </span><span class="cov0" title="0">{
                                                queryValues.Add(k, v2)
                                        }</span>
                                }
                        }

                }

                <span class="cov0" title="0">queryURL.RawQuery = queryValues.Encode()</span>
        }

        <span class="cov0" title="0">req, err := http.NewRequest("GET", queryURL.String(), nil)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">return req, nil</span>
}

// NewGetFiscalYearWithIdRequest generates requests for GetFiscalYearWithId
func NewGetFiscalYearWithIdRequest(server string, companyId openapi_types.UUID, fiscalYearId openapi_types.UUID) (*http.Request, error) <span class="cov0" title="0">{
        var err error

        var pathParam0 string

        pathParam0, err = runtime.StyleParamWithLocation("simple", false, "companyId", runtime.ParamLocationPath, companyId)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">var pathParam1 string

        pathParam1, err = runtime.StyleParamWithLocation("simple", false, "fiscalYearId", runtime.ParamLocationPath, fiscalYearId)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">serverURL, err := url.Parse(server)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">operationPath := fmt.Sprintf("/v1/companies/%s/fiscal-years/%s", pathParam0, pathParam1)
        if operationPath[0] == '/' </span><span class="cov0" title="0">{
                operationPath = "." + operationPath
        }</span>

        <span class="cov0" title="0">queryURL, err := serverURL.Parse(operationPath)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">req, err := http.NewRequest("GET", queryURL.String(), nil)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">return req, nil</span>
}

// NewGetInvoiceRequest generates requests for GetInvoice
func NewGetInvoiceRequest(server string, companyId openapi_types.UUID, params *GetInvoiceParams) (*http.Request, error) <span class="cov0" title="0">{
        var err error

        var pathParam0 string

        pathParam0, err = runtime.StyleParamWithLocation("simple", false, "companyId", runtime.ParamLocationPath, companyId)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">serverURL, err := url.Parse(server)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">operationPath := fmt.Sprintf("/v1/companies/%s/invoices", pathParam0)
        if operationPath[0] == '/' </span><span class="cov0" title="0">{
                operationPath = "." + operationPath
        }</span>

        <span class="cov0" title="0">queryURL, err := serverURL.Parse(operationPath)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">if params != nil </span><span class="cov0" title="0">{
                queryValues := queryURL.Query()

                if params.Page != nil </span><span class="cov0" title="0">{

                        if queryFrag, err := runtime.StyleParamWithLocation("form", true, "page", runtime.ParamLocationQuery, *params.Page); err != nil </span><span class="cov0" title="0">{
                                return nil, err
                        }</span> else<span class="cov0" title="0"> if parsed, err := url.ParseQuery(queryFrag); err != nil </span><span class="cov0" title="0">{
                                return nil, err
                        }</span> else<span class="cov0" title="0"> {
                                for k, v := range parsed </span><span class="cov0" title="0">{
                                        for _, v2 := range v </span><span class="cov0" title="0">{
                                                queryValues.Add(k, v2)
                                        }</span>
                                }
                        }

                }

                <span class="cov0" title="0">if params.PageSize != nil </span><span class="cov0" title="0">{

                        if queryFrag, err := runtime.StyleParamWithLocation("form", true, "pageSize", runtime.ParamLocationQuery, *params.PageSize); err != nil </span><span class="cov0" title="0">{
                                return nil, err
                        }</span> else<span class="cov0" title="0"> if parsed, err := url.ParseQuery(queryFrag); err != nil </span><span class="cov0" title="0">{
                                return nil, err
                        }</span> else<span class="cov0" title="0"> {
                                for k, v := range parsed </span><span class="cov0" title="0">{
                                        for _, v2 := range v </span><span class="cov0" title="0">{
                                                queryValues.Add(k, v2)
                                        }</span>
                                }
                        }

                }

                <span class="cov0" title="0">if params.Query != nil </span><span class="cov0" title="0">{

                        if queryFrag, err := runtime.StyleParamWithLocation("form", true, "query", runtime.ParamLocationQuery, *params.Query); err != nil </span><span class="cov0" title="0">{
                                return nil, err
                        }</span> else<span class="cov0" title="0"> if parsed, err := url.ParseQuery(queryFrag); err != nil </span><span class="cov0" title="0">{
                                return nil, err
                        }</span> else<span class="cov0" title="0"> {
                                for k, v := range parsed </span><span class="cov0" title="0">{
                                        for _, v2 := range v </span><span class="cov0" title="0">{
                                                queryValues.Add(k, v2)
                                        }</span>
                                }
                        }

                }

                <span class="cov0" title="0">queryURL.RawQuery = queryValues.Encode()</span>
        }

        <span class="cov0" title="0">req, err := http.NewRequest("GET", queryURL.String(), nil)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">return req, nil</span>
}

// NewPostInvoiceRequest calls the generic PostInvoice builder with application/json body
func NewPostInvoiceRequest(server string, companyId openapi_types.UUID, body PostInvoiceJSONRequestBody) (*http.Request, error) <span class="cov0" title="0">{
        var bodyReader io.Reader
        buf, err := json.Marshal(body)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">bodyReader = bytes.NewReader(buf)
        return NewPostInvoiceRequestWithBody(server, companyId, "application/json", bodyReader)</span>
}

// NewPostInvoiceRequestWithBody generates requests for PostInvoice with any type of body
func NewPostInvoiceRequestWithBody(server string, companyId openapi_types.UUID, contentType string, body io.Reader) (*http.Request, error) <span class="cov0" title="0">{
        var err error

        var pathParam0 string

        pathParam0, err = runtime.StyleParamWithLocation("simple", false, "companyId", runtime.ParamLocationPath, companyId)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">serverURL, err := url.Parse(server)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">operationPath := fmt.Sprintf("/v1/companies/%s/invoices", pathParam0)
        if operationPath[0] == '/' </span><span class="cov0" title="0">{
                operationPath = "." + operationPath
        }</span>

        <span class="cov0" title="0">queryURL, err := serverURL.Parse(operationPath)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">req, err := http.NewRequest("POST", queryURL.String(), body)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">req.Header.Add("Content-Type", contentType)

        return req, nil</span>
}

// NewGetInvoicesInvoiceIdRequest generates requests for GetInvoicesInvoiceId
func NewGetInvoicesInvoiceIdRequest(server string, companyId openapi_types.UUID, invoiceId openapi_types.UUID) (*http.Request, error) <span class="cov0" title="0">{
        var err error

        var pathParam0 string

        pathParam0, err = runtime.StyleParamWithLocation("simple", false, "companyId", runtime.ParamLocationPath, companyId)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">var pathParam1 string

        pathParam1, err = runtime.StyleParamWithLocation("simple", false, "invoiceId", runtime.ParamLocationPath, invoiceId)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">serverURL, err := url.Parse(server)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">operationPath := fmt.Sprintf("/v1/companies/%s/invoices/%s", pathParam0, pathParam1)
        if operationPath[0] == '/' </span><span class="cov0" title="0">{
                operationPath = "." + operationPath
        }</span>

        <span class="cov0" title="0">queryURL, err := serverURL.Parse(operationPath)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">req, err := http.NewRequest("GET", queryURL.String(), nil)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">return req, nil</span>
}

// NewPutInvoiceRequest calls the generic PutInvoice builder with application/json body
func NewPutInvoiceRequest(server string, companyId openapi_types.UUID, invoiceId openapi_types.UUID, body PutInvoiceJSONRequestBody) (*http.Request, error) <span class="cov0" title="0">{
        var bodyReader io.Reader
        buf, err := json.Marshal(body)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">bodyReader = bytes.NewReader(buf)
        return NewPutInvoiceRequestWithBody(server, companyId, invoiceId, "application/json", bodyReader)</span>
}

// NewPutInvoiceRequestWithBody generates requests for PutInvoice with any type of body
func NewPutInvoiceRequestWithBody(server string, companyId openapi_types.UUID, invoiceId openapi_types.UUID, contentType string, body io.Reader) (*http.Request, error) <span class="cov0" title="0">{
        var err error

        var pathParam0 string

        pathParam0, err = runtime.StyleParamWithLocation("simple", false, "companyId", runtime.ParamLocationPath, companyId)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">var pathParam1 string

        pathParam1, err = runtime.StyleParamWithLocation("simple", false, "invoiceId", runtime.ParamLocationPath, invoiceId)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">serverURL, err := url.Parse(server)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">operationPath := fmt.Sprintf("/v1/companies/%s/invoices/%s", pathParam0, pathParam1)
        if operationPath[0] == '/' </span><span class="cov0" title="0">{
                operationPath = "." + operationPath
        }</span>

        <span class="cov0" title="0">queryURL, err := serverURL.Parse(operationPath)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">req, err := http.NewRequest("PUT", queryURL.String(), body)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">req.Header.Add("Content-Type", contentType)

        return req, nil</span>
}

// NewGetInvoiceAttachmentsRequest generates requests for GetInvoiceAttachments
func NewGetInvoiceAttachmentsRequest(server string, companyId openapi_types.UUID, invoiceId openapi_types.UUID, params *GetInvoiceAttachmentsParams) (*http.Request, error) <span class="cov0" title="0">{
        var err error

        var pathParam0 string

        pathParam0, err = runtime.StyleParamWithLocation("simple", false, "companyId", runtime.ParamLocationPath, companyId)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">var pathParam1 string

        pathParam1, err = runtime.StyleParamWithLocation("simple", false, "invoiceId", runtime.ParamLocationPath, invoiceId)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">serverURL, err := url.Parse(server)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">operationPath := fmt.Sprintf("/v1/companies/%s/invoices/%s/attachments", pathParam0, pathParam1)
        if operationPath[0] == '/' </span><span class="cov0" title="0">{
                operationPath = "." + operationPath
        }</span>

        <span class="cov0" title="0">queryURL, err := serverURL.Parse(operationPath)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">if params != nil </span><span class="cov0" title="0">{
                queryValues := queryURL.Query()

                if params.Page != nil </span><span class="cov0" title="0">{

                        if queryFrag, err := runtime.StyleParamWithLocation("form", true, "page", runtime.ParamLocationQuery, *params.Page); err != nil </span><span class="cov0" title="0">{
                                return nil, err
                        }</span> else<span class="cov0" title="0"> if parsed, err := url.ParseQuery(queryFrag); err != nil </span><span class="cov0" title="0">{
                                return nil, err
                        }</span> else<span class="cov0" title="0"> {
                                for k, v := range parsed </span><span class="cov0" title="0">{
                                        for _, v2 := range v </span><span class="cov0" title="0">{
                                                queryValues.Add(k, v2)
                                        }</span>
                                }
                        }

                }

                <span class="cov0" title="0">if params.PageSize != nil </span><span class="cov0" title="0">{

                        if queryFrag, err := runtime.StyleParamWithLocation("form", true, "pageSize", runtime.ParamLocationQuery, *params.PageSize); err != nil </span><span class="cov0" title="0">{
                                return nil, err
                        }</span> else<span class="cov0" title="0"> if parsed, err := url.ParseQuery(queryFrag); err != nil </span><span class="cov0" title="0">{
                                return nil, err
                        }</span> else<span class="cov0" title="0"> {
                                for k, v := range parsed </span><span class="cov0" title="0">{
                                        for _, v2 := range v </span><span class="cov0" title="0">{
                                                queryValues.Add(k, v2)
                                        }</span>
                                }
                        }

                }

                <span class="cov0" title="0">if params.Query != nil </span><span class="cov0" title="0">{

                        if queryFrag, err := runtime.StyleParamWithLocation("form", true, "query", runtime.ParamLocationQuery, *params.Query); err != nil </span><span class="cov0" title="0">{
                                return nil, err
                        }</span> else<span class="cov0" title="0"> if parsed, err := url.ParseQuery(queryFrag); err != nil </span><span class="cov0" title="0">{
                                return nil, err
                        }</span> else<span class="cov0" title="0"> {
                                for k, v := range parsed </span><span class="cov0" title="0">{
                                        for _, v2 := range v </span><span class="cov0" title="0">{
                                                queryValues.Add(k, v2)
                                        }</span>
                                }
                        }

                }

                <span class="cov0" title="0">queryURL.RawQuery = queryValues.Encode()</span>
        }

        <span class="cov0" title="0">req, err := http.NewRequest("GET", queryURL.String(), nil)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">return req, nil</span>
}

// NewPostInvoiceAttachmentRequestWithBody generates requests for PostInvoiceAttachment with any type of body
func NewPostInvoiceAttachmentRequestWithBody(server string, companyId openapi_types.UUID, invoiceId openapi_types.UUID, params *PostInvoiceAttachmentParams, contentType string, body io.Reader) (*http.Request, error) <span class="cov0" title="0">{
        var err error

        var pathParam0 string

        pathParam0, err = runtime.StyleParamWithLocation("simple", false, "companyId", runtime.ParamLocationPath, companyId)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">var pathParam1 string

        pathParam1, err = runtime.StyleParamWithLocation("simple", false, "invoiceId", runtime.ParamLocationPath, invoiceId)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">serverURL, err := url.Parse(server)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">operationPath := fmt.Sprintf("/v1/companies/%s/invoices/%s/attachments", pathParam0, pathParam1)
        if operationPath[0] == '/' </span><span class="cov0" title="0">{
                operationPath = "." + operationPath
        }</span>

        <span class="cov0" title="0">queryURL, err := serverURL.Parse(operationPath)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">req, err := http.NewRequest("POST", queryURL.String(), body)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">req.Header.Add("Content-Type", contentType)

        if params != nil </span><span class="cov0" title="0">{

                var headerParam0 string

                headerParam0, err = runtime.StyleParamWithLocation("simple", false, "Content-Type", runtime.ParamLocationHeader, params.ContentType)
                if err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>

                <span class="cov0" title="0">req.Header.Set("Content-Type", headerParam0)</span>

        }

        <span class="cov0" title="0">return req, nil</span>
}

// NewDeleteInvoiceAttachmentRequest generates requests for DeleteInvoiceAttachment
func NewDeleteInvoiceAttachmentRequest(server string, companyId openapi_types.UUID, invoiceId openapi_types.UUID, attachmentId openapi_types.UUID) (*http.Request, error) <span class="cov0" title="0">{
        var err error

        var pathParam0 string

        pathParam0, err = runtime.StyleParamWithLocation("simple", false, "companyId", runtime.ParamLocationPath, companyId)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">var pathParam1 string

        pathParam1, err = runtime.StyleParamWithLocation("simple", false, "invoiceId", runtime.ParamLocationPath, invoiceId)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">var pathParam2 string

        pathParam2, err = runtime.StyleParamWithLocation("simple", false, "attachmentId", runtime.ParamLocationPath, attachmentId)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">serverURL, err := url.Parse(server)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">operationPath := fmt.Sprintf("/v1/companies/%s/invoices/%s/attachments/%s", pathParam0, pathParam1, pathParam2)
        if operationPath[0] == '/' </span><span class="cov0" title="0">{
                operationPath = "." + operationPath
        }</span>

        <span class="cov0" title="0">queryURL, err := serverURL.Parse(operationPath)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">req, err := http.NewRequest("DELETE", queryURL.String(), nil)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">return req, nil</span>
}

// NewGetInvoiceAttachmentRequest generates requests for GetInvoiceAttachment
func NewGetInvoiceAttachmentRequest(server string, companyId openapi_types.UUID, invoiceId openapi_types.UUID, attachmentId openapi_types.UUID) (*http.Request, error) <span class="cov0" title="0">{
        var err error

        var pathParam0 string

        pathParam0, err = runtime.StyleParamWithLocation("simple", false, "companyId", runtime.ParamLocationPath, companyId)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">var pathParam1 string

        pathParam1, err = runtime.StyleParamWithLocation("simple", false, "invoiceId", runtime.ParamLocationPath, invoiceId)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">var pathParam2 string

        pathParam2, err = runtime.StyleParamWithLocation("simple", false, "attachmentId", runtime.ParamLocationPath, attachmentId)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">serverURL, err := url.Parse(server)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">operationPath := fmt.Sprintf("/v1/companies/%s/invoices/%s/attachments/%s", pathParam0, pathParam1, pathParam2)
        if operationPath[0] == '/' </span><span class="cov0" title="0">{
                operationPath = "." + operationPath
        }</span>

        <span class="cov0" title="0">queryURL, err := serverURL.Parse(operationPath)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">req, err := http.NewRequest("GET", queryURL.String(), nil)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">return req, nil</span>
}

// NewDownloadInvoiceAttachmentRequest generates requests for DownloadInvoiceAttachment
func NewDownloadInvoiceAttachmentRequest(server string, companyId openapi_types.UUID, invoiceId openapi_types.UUID, attachmentId openapi_types.UUID) (*http.Request, error) <span class="cov0" title="0">{
        var err error

        var pathParam0 string

        pathParam0, err = runtime.StyleParamWithLocation("simple", false, "companyId", runtime.ParamLocationPath, companyId)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">var pathParam1 string

        pathParam1, err = runtime.StyleParamWithLocation("simple", false, "invoiceId", runtime.ParamLocationPath, invoiceId)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">var pathParam2 string

        pathParam2, err = runtime.StyleParamWithLocation("simple", false, "attachmentId", runtime.ParamLocationPath, attachmentId)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">serverURL, err := url.Parse(server)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">operationPath := fmt.Sprintf("/v1/companies/%s/invoices/%s/attachments/%s/download", pathParam0, pathParam1, pathParam2)
        if operationPath[0] == '/' </span><span class="cov0" title="0">{
                operationPath = "." + operationPath
        }</span>

        <span class="cov0" title="0">queryURL, err := serverURL.Parse(operationPath)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">req, err := http.NewRequest("GET", queryURL.String(), nil)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">return req, nil</span>
}

// NewPostInvoiceLineItemRequest calls the generic PostInvoiceLineItem builder with application/json body
func NewPostInvoiceLineItemRequest(server string, companyId openapi_types.UUID, invoiceId openapi_types.UUID, body PostInvoiceLineItemJSONRequestBody) (*http.Request, error) <span class="cov0" title="0">{
        var bodyReader io.Reader
        buf, err := json.Marshal(body)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">bodyReader = bytes.NewReader(buf)
        return NewPostInvoiceLineItemRequestWithBody(server, companyId, invoiceId, "application/json", bodyReader)</span>
}

// NewPostInvoiceLineItemRequestWithBody generates requests for PostInvoiceLineItem with any type of body
func NewPostInvoiceLineItemRequestWithBody(server string, companyId openapi_types.UUID, invoiceId openapi_types.UUID, contentType string, body io.Reader) (*http.Request, error) <span class="cov0" title="0">{
        var err error

        var pathParam0 string

        pathParam0, err = runtime.StyleParamWithLocation("simple", false, "companyId", runtime.ParamLocationPath, companyId)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">var pathParam1 string

        pathParam1, err = runtime.StyleParamWithLocation("simple", false, "invoiceId", runtime.ParamLocationPath, invoiceId)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">serverURL, err := url.Parse(server)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">operationPath := fmt.Sprintf("/v1/companies/%s/invoices/%s/line-items", pathParam0, pathParam1)
        if operationPath[0] == '/' </span><span class="cov0" title="0">{
                operationPath = "." + operationPath
        }</span>

        <span class="cov0" title="0">queryURL, err := serverURL.Parse(operationPath)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">req, err := http.NewRequest("POST", queryURL.String(), body)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">req.Header.Add("Content-Type", contentType)

        return req, nil</span>
}

// NewGetItemsRequest generates requests for GetItems
func NewGetItemsRequest(server string, companyId openapi_types.UUID, params *GetItemsParams) (*http.Request, error) <span class="cov0" title="0">{
        var err error

        var pathParam0 string

        pathParam0, err = runtime.StyleParamWithLocation("simple", false, "companyId", runtime.ParamLocationPath, companyId)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">serverURL, err := url.Parse(server)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">operationPath := fmt.Sprintf("/v1/companies/%s/items", pathParam0)
        if operationPath[0] == '/' </span><span class="cov0" title="0">{
                operationPath = "." + operationPath
        }</span>

        <span class="cov0" title="0">queryURL, err := serverURL.Parse(operationPath)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">if params != nil </span><span class="cov0" title="0">{
                queryValues := queryURL.Query()

                if params.Page != nil </span><span class="cov0" title="0">{

                        if queryFrag, err := runtime.StyleParamWithLocation("form", true, "page", runtime.ParamLocationQuery, *params.Page); err != nil </span><span class="cov0" title="0">{
                                return nil, err
                        }</span> else<span class="cov0" title="0"> if parsed, err := url.ParseQuery(queryFrag); err != nil </span><span class="cov0" title="0">{
                                return nil, err
                        }</span> else<span class="cov0" title="0"> {
                                for k, v := range parsed </span><span class="cov0" title="0">{
                                        for _, v2 := range v </span><span class="cov0" title="0">{
                                                queryValues.Add(k, v2)
                                        }</span>
                                }
                        }

                }

                <span class="cov0" title="0">if params.PageSize != nil </span><span class="cov0" title="0">{

                        if queryFrag, err := runtime.StyleParamWithLocation("form", true, "pageSize", runtime.ParamLocationQuery, *params.PageSize); err != nil </span><span class="cov0" title="0">{
                                return nil, err
                        }</span> else<span class="cov0" title="0"> if parsed, err := url.ParseQuery(queryFrag); err != nil </span><span class="cov0" title="0">{
                                return nil, err
                        }</span> else<span class="cov0" title="0"> {
                                for k, v := range parsed </span><span class="cov0" title="0">{
                                        for _, v2 := range v </span><span class="cov0" title="0">{
                                                queryValues.Add(k, v2)
                                        }</span>
                                }
                        }

                }

                <span class="cov0" title="0">if params.Query != nil </span><span class="cov0" title="0">{

                        if queryFrag, err := runtime.StyleParamWithLocation("form", true, "query", runtime.ParamLocationQuery, *params.Query); err != nil </span><span class="cov0" title="0">{
                                return nil, err
                        }</span> else<span class="cov0" title="0"> if parsed, err := url.ParseQuery(queryFrag); err != nil </span><span class="cov0" title="0">{
                                return nil, err
                        }</span> else<span class="cov0" title="0"> {
                                for k, v := range parsed </span><span class="cov0" title="0">{
                                        for _, v2 := range v </span><span class="cov0" title="0">{
                                                queryValues.Add(k, v2)
                                        }</span>
                                }
                        }

                }

                <span class="cov0" title="0">queryURL.RawQuery = queryValues.Encode()</span>
        }

        <span class="cov0" title="0">req, err := http.NewRequest("GET", queryURL.String(), nil)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">return req, nil</span>
}

// NewPostItemRequest calls the generic PostItem builder with application/json body
func NewPostItemRequest(server string, companyId openapi_types.UUID, body PostItemJSONRequestBody) (*http.Request, error) <span class="cov0" title="0">{
        var bodyReader io.Reader
        buf, err := json.Marshal(body)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">bodyReader = bytes.NewReader(buf)
        return NewPostItemRequestWithBody(server, companyId, "application/json", bodyReader)</span>
}

// NewPostItemRequestWithBody generates requests for PostItem with any type of body
func NewPostItemRequestWithBody(server string, companyId openapi_types.UUID, contentType string, body io.Reader) (*http.Request, error) <span class="cov0" title="0">{
        var err error

        var pathParam0 string

        pathParam0, err = runtime.StyleParamWithLocation("simple", false, "companyId", runtime.ParamLocationPath, companyId)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">serverURL, err := url.Parse(server)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">operationPath := fmt.Sprintf("/v1/companies/%s/items", pathParam0)
        if operationPath[0] == '/' </span><span class="cov0" title="0">{
                operationPath = "." + operationPath
        }</span>

        <span class="cov0" title="0">queryURL, err := serverURL.Parse(operationPath)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">req, err := http.NewRequest("POST", queryURL.String(), body)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">req.Header.Add("Content-Type", contentType)

        return req, nil</span>
}

// NewDeleteItemRequest generates requests for DeleteItem
func NewDeleteItemRequest(server string, companyId openapi_types.UUID, itemId openapi_types.UUID) (*http.Request, error) <span class="cov0" title="0">{
        var err error

        var pathParam0 string

        pathParam0, err = runtime.StyleParamWithLocation("simple", false, "companyId", runtime.ParamLocationPath, companyId)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">var pathParam1 string

        pathParam1, err = runtime.StyleParamWithLocation("simple", false, "itemId", runtime.ParamLocationPath, itemId)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">serverURL, err := url.Parse(server)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">operationPath := fmt.Sprintf("/v1/companies/%s/items/%s", pathParam0, pathParam1)
        if operationPath[0] == '/' </span><span class="cov0" title="0">{
                operationPath = "." + operationPath
        }</span>

        <span class="cov0" title="0">queryURL, err := serverURL.Parse(operationPath)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">req, err := http.NewRequest("DELETE", queryURL.String(), nil)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">return req, nil</span>
}

// NewGetItemsItemIdRequest generates requests for GetItemsItemId
func NewGetItemsItemIdRequest(server string, companyId openapi_types.UUID, itemId openapi_types.UUID) (*http.Request, error) <span class="cov0" title="0">{
        var err error

        var pathParam0 string

        pathParam0, err = runtime.StyleParamWithLocation("simple", false, "companyId", runtime.ParamLocationPath, companyId)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">var pathParam1 string

        pathParam1, err = runtime.StyleParamWithLocation("simple", false, "itemId", runtime.ParamLocationPath, itemId)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">serverURL, err := url.Parse(server)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">operationPath := fmt.Sprintf("/v1/companies/%s/items/%s", pathParam0, pathParam1)
        if operationPath[0] == '/' </span><span class="cov0" title="0">{
                operationPath = "." + operationPath
        }</span>

        <span class="cov0" title="0">queryURL, err := serverURL.Parse(operationPath)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">req, err := http.NewRequest("GET", queryURL.String(), nil)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">return req, nil</span>
}

// NewPutItemRequest calls the generic PutItem builder with application/json body
func NewPutItemRequest(server string, companyId openapi_types.UUID, itemId openapi_types.UUID, body PutItemJSONRequestBody) (*http.Request, error) <span class="cov0" title="0">{
        var bodyReader io.Reader
        buf, err := json.Marshal(body)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">bodyReader = bytes.NewReader(buf)
        return NewPutItemRequestWithBody(server, companyId, itemId, "application/json", bodyReader)</span>
}

// NewPutItemRequestWithBody generates requests for PutItem with any type of body
func NewPutItemRequestWithBody(server string, companyId openapi_types.UUID, itemId openapi_types.UUID, contentType string, body io.Reader) (*http.Request, error) <span class="cov0" title="0">{
        var err error

        var pathParam0 string

        pathParam0, err = runtime.StyleParamWithLocation("simple", false, "companyId", runtime.ParamLocationPath, companyId)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">var pathParam1 string

        pathParam1, err = runtime.StyleParamWithLocation("simple", false, "itemId", runtime.ParamLocationPath, itemId)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">serverURL, err := url.Parse(server)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">operationPath := fmt.Sprintf("/v1/companies/%s/items/%s", pathParam0, pathParam1)
        if operationPath[0] == '/' </span><span class="cov0" title="0">{
                operationPath = "." + operationPath
        }</span>

        <span class="cov0" title="0">queryURL, err := serverURL.Parse(operationPath)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">req, err := http.NewRequest("PUT", queryURL.String(), body)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">req.Header.Add("Content-Type", contentType)

        return req, nil</span>
}

// NewGetJournalentryRequest generates requests for GetJournalentry
func NewGetJournalentryRequest(server string, companyId openapi_types.UUID, params *GetJournalentryParams) (*http.Request, error) <span class="cov0" title="0">{
        var err error

        var pathParam0 string

        pathParam0, err = runtime.StyleParamWithLocation("simple", false, "companyId", runtime.ParamLocationPath, companyId)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">serverURL, err := url.Parse(server)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">operationPath := fmt.Sprintf("/v1/companies/%s/journal-entries", pathParam0)
        if operationPath[0] == '/' </span><span class="cov0" title="0">{
                operationPath = "." + operationPath
        }</span>

        <span class="cov0" title="0">queryURL, err := serverURL.Parse(operationPath)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">if params != nil </span><span class="cov0" title="0">{
                queryValues := queryURL.Query()

                if params.Page != nil </span><span class="cov0" title="0">{

                        if queryFrag, err := runtime.StyleParamWithLocation("form", true, "page", runtime.ParamLocationQuery, *params.Page); err != nil </span><span class="cov0" title="0">{
                                return nil, err
                        }</span> else<span class="cov0" title="0"> if parsed, err := url.ParseQuery(queryFrag); err != nil </span><span class="cov0" title="0">{
                                return nil, err
                        }</span> else<span class="cov0" title="0"> {
                                for k, v := range parsed </span><span class="cov0" title="0">{
                                        for _, v2 := range v </span><span class="cov0" title="0">{
                                                queryValues.Add(k, v2)
                                        }</span>
                                }
                        }

                }

                <span class="cov0" title="0">if params.PageSize != nil </span><span class="cov0" title="0">{

                        if queryFrag, err := runtime.StyleParamWithLocation("form", true, "pageSize", runtime.ParamLocationQuery, *params.PageSize); err != nil </span><span class="cov0" title="0">{
                                return nil, err
                        }</span> else<span class="cov0" title="0"> if parsed, err := url.ParseQuery(queryFrag); err != nil </span><span class="cov0" title="0">{
                                return nil, err
                        }</span> else<span class="cov0" title="0"> {
                                for k, v := range parsed </span><span class="cov0" title="0">{
                                        for _, v2 := range v </span><span class="cov0" title="0">{
                                                queryValues.Add(k, v2)
                                        }</span>
                                }
                        }

                }

                <span class="cov0" title="0">if params.Query != nil </span><span class="cov0" title="0">{

                        if queryFrag, err := runtime.StyleParamWithLocation("form", true, "query", runtime.ParamLocationQuery, *params.Query); err != nil </span><span class="cov0" title="0">{
                                return nil, err
                        }</span> else<span class="cov0" title="0"> if parsed, err := url.ParseQuery(queryFrag); err != nil </span><span class="cov0" title="0">{
                                return nil, err
                        }</span> else<span class="cov0" title="0"> {
                                for k, v := range parsed </span><span class="cov0" title="0">{
                                        for _, v2 := range v </span><span class="cov0" title="0">{
                                                queryValues.Add(k, v2)
                                        }</span>
                                }
                        }

                }

                <span class="cov0" title="0">queryURL.RawQuery = queryValues.Encode()</span>
        }

        <span class="cov0" title="0">req, err := http.NewRequest("GET", queryURL.String(), nil)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">return req, nil</span>
}

// NewPostJournalentryRequest calls the generic PostJournalentry builder with application/json body
func NewPostJournalentryRequest(server string, companyId openapi_types.UUID, body PostJournalentryJSONRequestBody) (*http.Request, error) <span class="cov0" title="0">{
        var bodyReader io.Reader
        buf, err := json.Marshal(body)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">bodyReader = bytes.NewReader(buf)
        return NewPostJournalentryRequestWithBody(server, companyId, "application/json", bodyReader)</span>
}

// NewPostJournalentryRequestWithBody generates requests for PostJournalentry with any type of body
func NewPostJournalentryRequestWithBody(server string, companyId openapi_types.UUID, contentType string, body io.Reader) (*http.Request, error) <span class="cov0" title="0">{
        var err error

        var pathParam0 string

        pathParam0, err = runtime.StyleParamWithLocation("simple", false, "companyId", runtime.ParamLocationPath, companyId)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">serverURL, err := url.Parse(server)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">operationPath := fmt.Sprintf("/v1/companies/%s/journal-entries", pathParam0)
        if operationPath[0] == '/' </span><span class="cov0" title="0">{
                operationPath = "." + operationPath
        }</span>

        <span class="cov0" title="0">queryURL, err := serverURL.Parse(operationPath)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">req, err := http.NewRequest("POST", queryURL.String(), body)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">req.Header.Add("Content-Type", contentType)

        return req, nil</span>
}

// NewGetJournalentriesJournalIdRequest generates requests for GetJournalentriesJournalId
func NewGetJournalentriesJournalIdRequest(server string, companyId openapi_types.UUID, journalEntryId openapi_types.UUID) (*http.Request, error) <span class="cov0" title="0">{
        var err error

        var pathParam0 string

        pathParam0, err = runtime.StyleParamWithLocation("simple", false, "companyId", runtime.ParamLocationPath, companyId)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">var pathParam1 string

        pathParam1, err = runtime.StyleParamWithLocation("simple", false, "journalEntryId", runtime.ParamLocationPath, journalEntryId)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">serverURL, err := url.Parse(server)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">operationPath := fmt.Sprintf("/v1/companies/%s/journal-entries/%s", pathParam0, pathParam1)
        if operationPath[0] == '/' </span><span class="cov0" title="0">{
                operationPath = "." + operationPath
        }</span>

        <span class="cov0" title="0">queryURL, err := serverURL.Parse(operationPath)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">req, err := http.NewRequest("GET", queryURL.String(), nil)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">return req, nil</span>
}

// NewReverseJournalentryRequest generates requests for ReverseJournalentry
func NewReverseJournalentryRequest(server string, companyId openapi_types.UUID, journalEntryId openapi_types.UUID) (*http.Request, error) <span class="cov0" title="0">{
        var err error

        var pathParam0 string

        pathParam0, err = runtime.StyleParamWithLocation("simple", false, "companyId", runtime.ParamLocationPath, companyId)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">var pathParam1 string

        pathParam1, err = runtime.StyleParamWithLocation("simple", false, "journalEntryId", runtime.ParamLocationPath, journalEntryId)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">serverURL, err := url.Parse(server)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">operationPath := fmt.Sprintf("/v1/companies/%s/journal-entries/%s/reverse", pathParam0, pathParam1)
        if operationPath[0] == '/' </span><span class="cov0" title="0">{
                operationPath = "." + operationPath
        }</span>

        <span class="cov0" title="0">queryURL, err := serverURL.Parse(operationPath)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">req, err := http.NewRequest("POST", queryURL.String(), nil)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">return req, nil</span>
}

// NewDownloadSieFileRequest generates requests for DownloadSieFile
func NewDownloadSieFileRequest(server string, companyId openapi_types.UUID, fiscalYearId openapi_types.UUID) (*http.Request, error) <span class="cov0" title="0">{
        var err error

        var pathParam0 string

        pathParam0, err = runtime.StyleParamWithLocation("simple", false, "companyId", runtime.ParamLocationPath, companyId)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">var pathParam1 string

        pathParam1, err = runtime.StyleParamWithLocation("simple", false, "fiscalYearId", runtime.ParamLocationPath, fiscalYearId)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">serverURL, err := url.Parse(server)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">operationPath := fmt.Sprintf("/v1/companies/%s/sie/%s/download", pathParam0, pathParam1)
        if operationPath[0] == '/' </span><span class="cov0" title="0">{
                operationPath = "." + operationPath
        }</span>

        <span class="cov0" title="0">queryURL, err := serverURL.Parse(operationPath)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">req, err := http.NewRequest("GET", queryURL.String(), nil)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">return req, nil</span>
}

// NewGetUploadsRequest generates requests for GetUploads
func NewGetUploadsRequest(server string, companyId openapi_types.UUID, params *GetUploadsParams) (*http.Request, error) <span class="cov0" title="0">{
        var err error

        var pathParam0 string

        pathParam0, err = runtime.StyleParamWithLocation("simple", false, "companyId", runtime.ParamLocationPath, companyId)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">serverURL, err := url.Parse(server)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">operationPath := fmt.Sprintf("/v1/companies/%s/uploads", pathParam0)
        if operationPath[0] == '/' </span><span class="cov0" title="0">{
                operationPath = "." + operationPath
        }</span>

        <span class="cov0" title="0">queryURL, err := serverURL.Parse(operationPath)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">if params != nil </span><span class="cov0" title="0">{
                queryValues := queryURL.Query()

                if params.Page != nil </span><span class="cov0" title="0">{

                        if queryFrag, err := runtime.StyleParamWithLocation("form", true, "page", runtime.ParamLocationQuery, *params.Page); err != nil </span><span class="cov0" title="0">{
                                return nil, err
                        }</span> else<span class="cov0" title="0"> if parsed, err := url.ParseQuery(queryFrag); err != nil </span><span class="cov0" title="0">{
                                return nil, err
                        }</span> else<span class="cov0" title="0"> {
                                for k, v := range parsed </span><span class="cov0" title="0">{
                                        for _, v2 := range v </span><span class="cov0" title="0">{
                                                queryValues.Add(k, v2)
                                        }</span>
                                }
                        }

                }

                <span class="cov0" title="0">if params.PageSize != nil </span><span class="cov0" title="0">{

                        if queryFrag, err := runtime.StyleParamWithLocation("form", true, "pageSize", runtime.ParamLocationQuery, *params.PageSize); err != nil </span><span class="cov0" title="0">{
                                return nil, err
                        }</span> else<span class="cov0" title="0"> if parsed, err := url.ParseQuery(queryFrag); err != nil </span><span class="cov0" title="0">{
                                return nil, err
                        }</span> else<span class="cov0" title="0"> {
                                for k, v := range parsed </span><span class="cov0" title="0">{
                                        for _, v2 := range v </span><span class="cov0" title="0">{
                                                queryValues.Add(k, v2)
                                        }</span>
                                }
                        }

                }

                <span class="cov0" title="0">if params.Query != nil </span><span class="cov0" title="0">{

                        if queryFrag, err := runtime.StyleParamWithLocation("form", true, "query", runtime.ParamLocationQuery, *params.Query); err != nil </span><span class="cov0" title="0">{
                                return nil, err
                        }</span> else<span class="cov0" title="0"> if parsed, err := url.ParseQuery(queryFrag); err != nil </span><span class="cov0" title="0">{
                                return nil, err
                        }</span> else<span class="cov0" title="0"> {
                                for k, v := range parsed </span><span class="cov0" title="0">{
                                        for _, v2 := range v </span><span class="cov0" title="0">{
                                                queryValues.Add(k, v2)
                                        }</span>
                                }
                        }

                }

                <span class="cov0" title="0">queryURL.RawQuery = queryValues.Encode()</span>
        }

        <span class="cov0" title="0">req, err := http.NewRequest("GET", queryURL.String(), nil)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">return req, nil</span>
}

// NewAddUploadRequestWithBody generates requests for AddUpload with any type of body
func NewAddUploadRequestWithBody(server string, companyId openapi_types.UUID, params *AddUploadParams, contentType string, body io.Reader) (*http.Request, error) <span class="cov0" title="0">{
        var err error

        var pathParam0 string

        pathParam0, err = runtime.StyleParamWithLocation("simple", false, "companyId", runtime.ParamLocationPath, companyId)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">serverURL, err := url.Parse(server)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">operationPath := fmt.Sprintf("/v1/companies/%s/uploads", pathParam0)
        if operationPath[0] == '/' </span><span class="cov0" title="0">{
                operationPath = "." + operationPath
        }</span>

        <span class="cov0" title="0">queryURL, err := serverURL.Parse(operationPath)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">req, err := http.NewRequest("POST", queryURL.String(), body)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">req.Header.Add("Content-Type", contentType)

        if params != nil </span><span class="cov0" title="0">{

                var headerParam0 string

                headerParam0, err = runtime.StyleParamWithLocation("simple", false, "Content-Type", runtime.ParamLocationHeader, params.ContentType)
                if err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>

                <span class="cov0" title="0">req.Header.Set("Content-Type", headerParam0)</span>

        }

        <span class="cov0" title="0">return req, nil</span>
}

// NewGetUploadRequest generates requests for GetUpload
func NewGetUploadRequest(server string, companyId openapi_types.UUID, uploadId openapi_types.UUID) (*http.Request, error) <span class="cov0" title="0">{
        var err error

        var pathParam0 string

        pathParam0, err = runtime.StyleParamWithLocation("simple", false, "companyId", runtime.ParamLocationPath, companyId)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">var pathParam1 string

        pathParam1, err = runtime.StyleParamWithLocation("simple", false, "uploadId", runtime.ParamLocationPath, uploadId)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">serverURL, err := url.Parse(server)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">operationPath := fmt.Sprintf("/v1/companies/%s/uploads/%s", pathParam0, pathParam1)
        if operationPath[0] == '/' </span><span class="cov0" title="0">{
                operationPath = "." + operationPath
        }</span>

        <span class="cov0" title="0">queryURL, err := serverURL.Parse(operationPath)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">req, err := http.NewRequest("GET", queryURL.String(), nil)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">return req, nil</span>
}

// NewDownloadUploadRequest generates requests for DownloadUpload
func NewDownloadUploadRequest(server string, companyId openapi_types.UUID, uploadId openapi_types.UUID) (*http.Request, error) <span class="cov0" title="0">{
        var err error

        var pathParam0 string

        pathParam0, err = runtime.StyleParamWithLocation("simple", false, "companyId", runtime.ParamLocationPath, companyId)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">var pathParam1 string

        pathParam1, err = runtime.StyleParamWithLocation("simple", false, "uploadId", runtime.ParamLocationPath, uploadId)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">serverURL, err := url.Parse(server)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">operationPath := fmt.Sprintf("/v1/companies/%s/uploads/%s/download", pathParam0, pathParam1)
        if operationPath[0] == '/' </span><span class="cov0" title="0">{
                operationPath = "." + operationPath
        }</span>

        <span class="cov0" title="0">queryURL, err := serverURL.Parse(operationPath)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">req, err := http.NewRequest("GET", queryURL.String(), nil)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">return req, nil</span>
}

func (c *Client) applyEditors(ctx context.Context, req *http.Request, additionalEditors []RequestEditorFn) error <span class="cov0" title="0">{
        for _, r := range c.RequestEditors </span><span class="cov0" title="0">{
                if err := r(ctx, req); err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
        }
        <span class="cov0" title="0">for _, r := range additionalEditors </span><span class="cov0" title="0">{
                if err := r(ctx, req); err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
        }
        <span class="cov0" title="0">return nil</span>
}

// ClientWithResponses builds on ClientInterface to offer response payloads
type ClientWithResponses struct {
        ClientInterface
}

// NewClientWithResponses creates a new ClientWithResponses, which wraps
// Client with return type handling
func NewClientWithResponses(server string, opts ...ClientOption) (*ClientWithResponses, error) <span class="cov0" title="0">{
        client, err := NewClient(server, opts...)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">return &amp;ClientWithResponses{client}, nil</span>
}

// WithBaseURL overrides the baseURL.
func WithBaseURL(baseURL string) ClientOption <span class="cov0" title="0">{
        return func(c *Client) error </span><span class="cov0" title="0">{
                newBaseURL, err := url.Parse(baseURL)
                if err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
                <span class="cov0" title="0">c.Server = newBaseURL.String()
                return nil</span>
        }
}

// ClientWithResponsesInterface is the interface specification for the client with responses above.
type ClientWithResponsesInterface interface {
        // GetCustomerWithResponse request
        GetCustomerWithResponse(ctx context.Context, companyId openapi_types.UUID, params *GetCustomerParams, reqEditors ...RequestEditorFn) (*GetCustomerResponse, error)

        // PostCustomerWithBodyWithResponse request with any body
        PostCustomerWithBodyWithResponse(ctx context.Context, companyId openapi_types.UUID, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PostCustomerResponse, error)

        PostCustomerWithResponse(ctx context.Context, companyId openapi_types.UUID, body PostCustomerJSONRequestBody, reqEditors ...RequestEditorFn) (*PostCustomerResponse, error)

        // DeleteCustomerWithResponse request
        DeleteCustomerWithResponse(ctx context.Context, companyId openapi_types.UUID, customerId openapi_types.UUID, reqEditors ...RequestEditorFn) (*DeleteCustomerResponse, error)

        // GetCustomersCustomerIdWithResponse request
        GetCustomersCustomerIdWithResponse(ctx context.Context, companyId openapi_types.UUID, customerId openapi_types.UUID, reqEditors ...RequestEditorFn) (*GetCustomersCustomerIdResponse, error)

        // PutCustomerWithBodyWithResponse request with any body
        PutCustomerWithBodyWithResponse(ctx context.Context, companyId openapi_types.UUID, customerId openapi_types.UUID, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PutCustomerResponse, error)

        PutCustomerWithResponse(ctx context.Context, companyId openapi_types.UUID, customerId openapi_types.UUID, body PutCustomerJSONRequestBody, reqEditors ...RequestEditorFn) (*PutCustomerResponse, error)

        // GetFiscalYearsWithResponse request
        GetFiscalYearsWithResponse(ctx context.Context, companyId openapi_types.UUID, params *GetFiscalYearsParams, reqEditors ...RequestEditorFn) (*GetFiscalYearsResponse, error)

        // GetFiscalYearWithIdWithResponse request
        GetFiscalYearWithIdWithResponse(ctx context.Context, companyId openapi_types.UUID, fiscalYearId openapi_types.UUID, reqEditors ...RequestEditorFn) (*GetFiscalYearWithIdResponse, error)

        // GetInvoiceWithResponse request
        GetInvoiceWithResponse(ctx context.Context, companyId openapi_types.UUID, params *GetInvoiceParams, reqEditors ...RequestEditorFn) (*GetInvoiceResponse, error)

        // PostInvoiceWithBodyWithResponse request with any body
        PostInvoiceWithBodyWithResponse(ctx context.Context, companyId openapi_types.UUID, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PostInvoiceResponse, error)

        PostInvoiceWithResponse(ctx context.Context, companyId openapi_types.UUID, body PostInvoiceJSONRequestBody, reqEditors ...RequestEditorFn) (*PostInvoiceResponse, error)

        // GetInvoicesInvoiceIdWithResponse request
        GetInvoicesInvoiceIdWithResponse(ctx context.Context, companyId openapi_types.UUID, invoiceId openapi_types.UUID, reqEditors ...RequestEditorFn) (*GetInvoicesInvoiceIdResponse, error)

        // PutInvoiceWithBodyWithResponse request with any body
        PutInvoiceWithBodyWithResponse(ctx context.Context, companyId openapi_types.UUID, invoiceId openapi_types.UUID, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PutInvoiceResponse, error)

        PutInvoiceWithResponse(ctx context.Context, companyId openapi_types.UUID, invoiceId openapi_types.UUID, body PutInvoiceJSONRequestBody, reqEditors ...RequestEditorFn) (*PutInvoiceResponse, error)

        // GetInvoiceAttachmentsWithResponse request
        GetInvoiceAttachmentsWithResponse(ctx context.Context, companyId openapi_types.UUID, invoiceId openapi_types.UUID, params *GetInvoiceAttachmentsParams, reqEditors ...RequestEditorFn) (*GetInvoiceAttachmentsResponse, error)

        // PostInvoiceAttachmentWithBodyWithResponse request with any body
        PostInvoiceAttachmentWithBodyWithResponse(ctx context.Context, companyId openapi_types.UUID, invoiceId openapi_types.UUID, params *PostInvoiceAttachmentParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PostInvoiceAttachmentResponse, error)

        // DeleteInvoiceAttachmentWithResponse request
        DeleteInvoiceAttachmentWithResponse(ctx context.Context, companyId openapi_types.UUID, invoiceId openapi_types.UUID, attachmentId openapi_types.UUID, reqEditors ...RequestEditorFn) (*DeleteInvoiceAttachmentResponse, error)

        // GetInvoiceAttachmentWithResponse request
        GetInvoiceAttachmentWithResponse(ctx context.Context, companyId openapi_types.UUID, invoiceId openapi_types.UUID, attachmentId openapi_types.UUID, reqEditors ...RequestEditorFn) (*GetInvoiceAttachmentResponse, error)

        // DownloadInvoiceAttachmentWithResponse request
        DownloadInvoiceAttachmentWithResponse(ctx context.Context, companyId openapi_types.UUID, invoiceId openapi_types.UUID, attachmentId openapi_types.UUID, reqEditors ...RequestEditorFn) (*DownloadInvoiceAttachmentResponse, error)

        // PostInvoiceLineItemWithBodyWithResponse request with any body
        PostInvoiceLineItemWithBodyWithResponse(ctx context.Context, companyId openapi_types.UUID, invoiceId openapi_types.UUID, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PostInvoiceLineItemResponse, error)

        PostInvoiceLineItemWithResponse(ctx context.Context, companyId openapi_types.UUID, invoiceId openapi_types.UUID, body PostInvoiceLineItemJSONRequestBody, reqEditors ...RequestEditorFn) (*PostInvoiceLineItemResponse, error)

        // GetItemsWithResponse request
        GetItemsWithResponse(ctx context.Context, companyId openapi_types.UUID, params *GetItemsParams, reqEditors ...RequestEditorFn) (*GetItemsResponse, error)

        // PostItemWithBodyWithResponse request with any body
        PostItemWithBodyWithResponse(ctx context.Context, companyId openapi_types.UUID, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PostItemResponse, error)

        PostItemWithResponse(ctx context.Context, companyId openapi_types.UUID, body PostItemJSONRequestBody, reqEditors ...RequestEditorFn) (*PostItemResponse, error)

        // DeleteItemWithResponse request
        DeleteItemWithResponse(ctx context.Context, companyId openapi_types.UUID, itemId openapi_types.UUID, reqEditors ...RequestEditorFn) (*DeleteItemResponse, error)

        // GetItemsItemIdWithResponse request
        GetItemsItemIdWithResponse(ctx context.Context, companyId openapi_types.UUID, itemId openapi_types.UUID, reqEditors ...RequestEditorFn) (*GetItemsItemIdResponse, error)

        // PutItemWithBodyWithResponse request with any body
        PutItemWithBodyWithResponse(ctx context.Context, companyId openapi_types.UUID, itemId openapi_types.UUID, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PutItemResponse, error)

        PutItemWithResponse(ctx context.Context, companyId openapi_types.UUID, itemId openapi_types.UUID, body PutItemJSONRequestBody, reqEditors ...RequestEditorFn) (*PutItemResponse, error)

        // GetJournalentryWithResponse request
        GetJournalentryWithResponse(ctx context.Context, companyId openapi_types.UUID, params *GetJournalentryParams, reqEditors ...RequestEditorFn) (*GetJournalentryResponse, error)

        // PostJournalentryWithBodyWithResponse request with any body
        PostJournalentryWithBodyWithResponse(ctx context.Context, companyId openapi_types.UUID, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PostJournalentryResponse, error)

        PostJournalentryWithResponse(ctx context.Context, companyId openapi_types.UUID, body PostJournalentryJSONRequestBody, reqEditors ...RequestEditorFn) (*PostJournalentryResponse, error)

        // GetJournalentriesJournalIdWithResponse request
        GetJournalentriesJournalIdWithResponse(ctx context.Context, companyId openapi_types.UUID, journalEntryId openapi_types.UUID, reqEditors ...RequestEditorFn) (*GetJournalentriesJournalIdResponse, error)

        // ReverseJournalentryWithResponse request
        ReverseJournalentryWithResponse(ctx context.Context, companyId openapi_types.UUID, journalEntryId openapi_types.UUID, reqEditors ...RequestEditorFn) (*ReverseJournalentryResponse, error)

        // DownloadSieFileWithResponse request
        DownloadSieFileWithResponse(ctx context.Context, companyId openapi_types.UUID, fiscalYearId openapi_types.UUID, reqEditors ...RequestEditorFn) (*DownloadSieFileResponse, error)

        // GetUploadsWithResponse request
        GetUploadsWithResponse(ctx context.Context, companyId openapi_types.UUID, params *GetUploadsParams, reqEditors ...RequestEditorFn) (*GetUploadsResponse, error)

        // AddUploadWithBodyWithResponse request with any body
        AddUploadWithBodyWithResponse(ctx context.Context, companyId openapi_types.UUID, params *AddUploadParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*AddUploadResponse, error)

        // GetUploadWithResponse request
        GetUploadWithResponse(ctx context.Context, companyId openapi_types.UUID, uploadId openapi_types.UUID, reqEditors ...RequestEditorFn) (*GetUploadResponse, error)

        // DownloadUploadWithResponse request
        DownloadUploadWithResponse(ctx context.Context, companyId openapi_types.UUID, uploadId openapi_types.UUID, reqEditors ...RequestEditorFn) (*DownloadUploadResponse, error)
}

type GetCustomerResponse struct {
        Body         []byte
        HTTPResponse *http.Response
        JSON200      *struct {
                CurrentPage *int32      `json:"currentPage,omitempty"`
                Items       *[]Customer `json:"items,omitempty"`
                TotalItems  *int32      `json:"totalItems,omitempty"`
                TotalPages  *int32      `json:"totalPages,omitempty"`
        }
}

// Status returns HTTPResponse.Status
func (r GetCustomerResponse) Status() string <span class="cov0" title="0">{
        if r.HTTPResponse != nil </span><span class="cov0" title="0">{
                return r.HTTPResponse.Status
        }</span>
        <span class="cov0" title="0">return http.StatusText(0)</span>
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetCustomerResponse) StatusCode() int <span class="cov0" title="0">{
        if r.HTTPResponse != nil </span><span class="cov0" title="0">{
                return r.HTTPResponse.StatusCode
        }</span>
        <span class="cov0" title="0">return 0</span>
}

type PostCustomerResponse struct {
        Body         []byte
        HTTPResponse *http.Response
        JSON200      *Customer
        JSON400      *ApiError
}

// Status returns HTTPResponse.Status
func (r PostCustomerResponse) Status() string <span class="cov0" title="0">{
        if r.HTTPResponse != nil </span><span class="cov0" title="0">{
                return r.HTTPResponse.Status
        }</span>
        <span class="cov0" title="0">return http.StatusText(0)</span>
}

// StatusCode returns HTTPResponse.StatusCode
func (r PostCustomerResponse) StatusCode() int <span class="cov0" title="0">{
        if r.HTTPResponse != nil </span><span class="cov0" title="0">{
                return r.HTTPResponse.StatusCode
        }</span>
        <span class="cov0" title="0">return 0</span>
}

type DeleteCustomerResponse struct {
        Body         []byte
        HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r DeleteCustomerResponse) Status() string <span class="cov0" title="0">{
        if r.HTTPResponse != nil </span><span class="cov0" title="0">{
                return r.HTTPResponse.Status
        }</span>
        <span class="cov0" title="0">return http.StatusText(0)</span>
}

// StatusCode returns HTTPResponse.StatusCode
func (r DeleteCustomerResponse) StatusCode() int <span class="cov0" title="0">{
        if r.HTTPResponse != nil </span><span class="cov0" title="0">{
                return r.HTTPResponse.StatusCode
        }</span>
        <span class="cov0" title="0">return 0</span>
}

type GetCustomersCustomerIdResponse struct {
        Body         []byte
        HTTPResponse *http.Response
        JSON200      *Customer
        JSON404      *ApiError
}

// Status returns HTTPResponse.Status
func (r GetCustomersCustomerIdResponse) Status() string <span class="cov0" title="0">{
        if r.HTTPResponse != nil </span><span class="cov0" title="0">{
                return r.HTTPResponse.Status
        }</span>
        <span class="cov0" title="0">return http.StatusText(0)</span>
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetCustomersCustomerIdResponse) StatusCode() int <span class="cov0" title="0">{
        if r.HTTPResponse != nil </span><span class="cov0" title="0">{
                return r.HTTPResponse.StatusCode
        }</span>
        <span class="cov0" title="0">return 0</span>
}

type PutCustomerResponse struct {
        Body         []byte
        HTTPResponse *http.Response
        JSON200      *Customer
        JSON400      *ApiError
}

// Status returns HTTPResponse.Status
func (r PutCustomerResponse) Status() string <span class="cov0" title="0">{
        if r.HTTPResponse != nil </span><span class="cov0" title="0">{
                return r.HTTPResponse.Status
        }</span>
        <span class="cov0" title="0">return http.StatusText(0)</span>
}

// StatusCode returns HTTPResponse.StatusCode
func (r PutCustomerResponse) StatusCode() int <span class="cov0" title="0">{
        if r.HTTPResponse != nil </span><span class="cov0" title="0">{
                return r.HTTPResponse.StatusCode
        }</span>
        <span class="cov0" title="0">return 0</span>
}

type GetFiscalYearsResponse struct {
        Body         []byte
        HTTPResponse *http.Response
        JSON200      *struct {
                CurrentPage *int32         `json:"currentPage,omitempty"`
                Items       *[]interface{} `json:"items,omitempty"`
                TotalItems  *int32         `json:"totalItems,omitempty"`
                TotalPages  *int32         `json:"totalPages,omitempty"`
        }
}

// Status returns HTTPResponse.Status
func (r GetFiscalYearsResponse) Status() string <span class="cov0" title="0">{
        if r.HTTPResponse != nil </span><span class="cov0" title="0">{
                return r.HTTPResponse.Status
        }</span>
        <span class="cov0" title="0">return http.StatusText(0)</span>
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetFiscalYearsResponse) StatusCode() int <span class="cov0" title="0">{
        if r.HTTPResponse != nil </span><span class="cov0" title="0">{
                return r.HTTPResponse.StatusCode
        }</span>
        <span class="cov0" title="0">return 0</span>
}

type GetFiscalYearWithIdResponse struct {
        Body         []byte
        HTTPResponse *http.Response
        JSON200      *struct {
                FiscalYear *FiscalYear `json:"fiscalYear,omitempty"`
        }
        JSON404 *ApiError
}

// Status returns HTTPResponse.Status
func (r GetFiscalYearWithIdResponse) Status() string <span class="cov0" title="0">{
        if r.HTTPResponse != nil </span><span class="cov0" title="0">{
                return r.HTTPResponse.Status
        }</span>
        <span class="cov0" title="0">return http.StatusText(0)</span>
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetFiscalYearWithIdResponse) StatusCode() int <span class="cov0" title="0">{
        if r.HTTPResponse != nil </span><span class="cov0" title="0">{
                return r.HTTPResponse.StatusCode
        }</span>
        <span class="cov0" title="0">return 0</span>
}

type GetInvoiceResponse struct {
        Body         []byte
        HTTPResponse *http.Response
        JSON200      *struct {
                CurrentPage *int32     `json:"currentPage,omitempty"`
                Items       *[]Invoice `json:"items,omitempty"`
                TotalItems  *int32     `json:"totalItems,omitempty"`
                TotalPages  *int32     `json:"totalPages,omitempty"`
        }
}

// Status returns HTTPResponse.Status
func (r GetInvoiceResponse) Status() string <span class="cov0" title="0">{
        if r.HTTPResponse != nil </span><span class="cov0" title="0">{
                return r.HTTPResponse.Status
        }</span>
        <span class="cov0" title="0">return http.StatusText(0)</span>
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetInvoiceResponse) StatusCode() int <span class="cov0" title="0">{
        if r.HTTPResponse != nil </span><span class="cov0" title="0">{
                return r.HTTPResponse.StatusCode
        }</span>
        <span class="cov0" title="0">return 0</span>
}

type PostInvoiceResponse struct {
        Body         []byte
        HTTPResponse *http.Response
        JSON200      *Invoice
        JSON400      *ApiError
}

// Status returns HTTPResponse.Status
func (r PostInvoiceResponse) Status() string <span class="cov0" title="0">{
        if r.HTTPResponse != nil </span><span class="cov0" title="0">{
                return r.HTTPResponse.Status
        }</span>
        <span class="cov0" title="0">return http.StatusText(0)</span>
}

// StatusCode returns HTTPResponse.StatusCode
func (r PostInvoiceResponse) StatusCode() int <span class="cov0" title="0">{
        if r.HTTPResponse != nil </span><span class="cov0" title="0">{
                return r.HTTPResponse.StatusCode
        }</span>
        <span class="cov0" title="0">return 0</span>
}

type GetInvoicesInvoiceIdResponse struct {
        Body         []byte
        HTTPResponse *http.Response
        JSON200      *Invoice
        JSON404      *ApiError
}

// Status returns HTTPResponse.Status
func (r GetInvoicesInvoiceIdResponse) Status() string <span class="cov0" title="0">{
        if r.HTTPResponse != nil </span><span class="cov0" title="0">{
                return r.HTTPResponse.Status
        }</span>
        <span class="cov0" title="0">return http.StatusText(0)</span>
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetInvoicesInvoiceIdResponse) StatusCode() int <span class="cov0" title="0">{
        if r.HTTPResponse != nil </span><span class="cov0" title="0">{
                return r.HTTPResponse.StatusCode
        }</span>
        <span class="cov0" title="0">return 0</span>
}

type PutInvoiceResponse struct {
        Body         []byte
        HTTPResponse *http.Response
        JSON200      *Invoice
        JSON400      *ApiError
}

// Status returns HTTPResponse.Status
func (r PutInvoiceResponse) Status() string <span class="cov0" title="0">{
        if r.HTTPResponse != nil </span><span class="cov0" title="0">{
                return r.HTTPResponse.Status
        }</span>
        <span class="cov0" title="0">return http.StatusText(0)</span>
}

// StatusCode returns HTTPResponse.StatusCode
func (r PutInvoiceResponse) StatusCode() int <span class="cov0" title="0">{
        if r.HTTPResponse != nil </span><span class="cov0" title="0">{
                return r.HTTPResponse.StatusCode
        }</span>
        <span class="cov0" title="0">return 0</span>
}

type GetInvoiceAttachmentsResponse struct {
        Body         []byte
        HTTPResponse *http.Response
        JSON200      *struct {
                CurrentPage *int32               `json:"currentPage,omitempty"`
                Items       *[]InvoiceAttachment `json:"items,omitempty"`
                TotalItems  *int32               `json:"totalItems,omitempty"`
                TotalPages  *int32               `json:"totalPages,omitempty"`
        }
        JSON404 *ApiError
}

// Status returns HTTPResponse.Status
func (r GetInvoiceAttachmentsResponse) Status() string <span class="cov0" title="0">{
        if r.HTTPResponse != nil </span><span class="cov0" title="0">{
                return r.HTTPResponse.Status
        }</span>
        <span class="cov0" title="0">return http.StatusText(0)</span>
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetInvoiceAttachmentsResponse) StatusCode() int <span class="cov0" title="0">{
        if r.HTTPResponse != nil </span><span class="cov0" title="0">{
                return r.HTTPResponse.StatusCode
        }</span>
        <span class="cov0" title="0">return 0</span>
}

type PostInvoiceAttachmentResponse struct {
        Body         []byte
        HTTPResponse *http.Response
        JSON200      *struct {
                union json.RawMessage
        }
        JSON400 *ApiError
        JSON404 *ApiError
}

// Status returns HTTPResponse.Status
func (r PostInvoiceAttachmentResponse) Status() string <span class="cov0" title="0">{
        if r.HTTPResponse != nil </span><span class="cov0" title="0">{
                return r.HTTPResponse.Status
        }</span>
        <span class="cov0" title="0">return http.StatusText(0)</span>
}

// StatusCode returns HTTPResponse.StatusCode
func (r PostInvoiceAttachmentResponse) StatusCode() int <span class="cov0" title="0">{
        if r.HTTPResponse != nil </span><span class="cov0" title="0">{
                return r.HTTPResponse.StatusCode
        }</span>
        <span class="cov0" title="0">return 0</span>
}

type DeleteInvoiceAttachmentResponse struct {
        Body         []byte
        HTTPResponse *http.Response
        JSON404      *ApiError
}

// Status returns HTTPResponse.Status
func (r DeleteInvoiceAttachmentResponse) Status() string <span class="cov0" title="0">{
        if r.HTTPResponse != nil </span><span class="cov0" title="0">{
                return r.HTTPResponse.Status
        }</span>
        <span class="cov0" title="0">return http.StatusText(0)</span>
}

// StatusCode returns HTTPResponse.StatusCode
func (r DeleteInvoiceAttachmentResponse) StatusCode() int <span class="cov0" title="0">{
        if r.HTTPResponse != nil </span><span class="cov0" title="0">{
                return r.HTTPResponse.StatusCode
        }</span>
        <span class="cov0" title="0">return 0</span>
}

type GetInvoiceAttachmentResponse struct {
        Body         []byte
        HTTPResponse *http.Response
        JSON200      *InvoiceAttachment
        JSON404      *ApiError
}

// Status returns HTTPResponse.Status
func (r GetInvoiceAttachmentResponse) Status() string <span class="cov0" title="0">{
        if r.HTTPResponse != nil </span><span class="cov0" title="0">{
                return r.HTTPResponse.Status
        }</span>
        <span class="cov0" title="0">return http.StatusText(0)</span>
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetInvoiceAttachmentResponse) StatusCode() int <span class="cov0" title="0">{
        if r.HTTPResponse != nil </span><span class="cov0" title="0">{
                return r.HTTPResponse.StatusCode
        }</span>
        <span class="cov0" title="0">return 0</span>
}

type DownloadInvoiceAttachmentResponse struct {
        Body         []byte
        HTTPResponse *http.Response
        JSON404      *ApiError
}

// Status returns HTTPResponse.Status
func (r DownloadInvoiceAttachmentResponse) Status() string <span class="cov0" title="0">{
        if r.HTTPResponse != nil </span><span class="cov0" title="0">{
                return r.HTTPResponse.Status
        }</span>
        <span class="cov0" title="0">return http.StatusText(0)</span>
}

// StatusCode returns HTTPResponse.StatusCode
func (r DownloadInvoiceAttachmentResponse) StatusCode() int <span class="cov0" title="0">{
        if r.HTTPResponse != nil </span><span class="cov0" title="0">{
                return r.HTTPResponse.StatusCode
        }</span>
        <span class="cov0" title="0">return 0</span>
}

type PostInvoiceLineItemResponse struct {
        Body         []byte
        HTTPResponse *http.Response
        JSON200      *struct {
                union json.RawMessage
        }
        JSON400 *ApiError
        JSON404 *ApiError
}

// Status returns HTTPResponse.Status
func (r PostInvoiceLineItemResponse) Status() string <span class="cov0" title="0">{
        if r.HTTPResponse != nil </span><span class="cov0" title="0">{
                return r.HTTPResponse.Status
        }</span>
        <span class="cov0" title="0">return http.StatusText(0)</span>
}

// StatusCode returns HTTPResponse.StatusCode
func (r PostInvoiceLineItemResponse) StatusCode() int <span class="cov0" title="0">{
        if r.HTTPResponse != nil </span><span class="cov0" title="0">{
                return r.HTTPResponse.StatusCode
        }</span>
        <span class="cov0" title="0">return 0</span>
}

type GetItemsResponse struct {
        Body         []byte
        HTTPResponse *http.Response
        JSON200      *struct {
                CurrentPage *int32         `json:"currentPage,omitempty"`
                Items       *[]interface{} `json:"items,omitempty"`
                TotalItems  *int32         `json:"totalItems,omitempty"`
                TotalPages  *int32         `json:"totalPages,omitempty"`
        }
}

// Status returns HTTPResponse.Status
func (r GetItemsResponse) Status() string <span class="cov0" title="0">{
        if r.HTTPResponse != nil </span><span class="cov0" title="0">{
                return r.HTTPResponse.Status
        }</span>
        <span class="cov0" title="0">return http.StatusText(0)</span>
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetItemsResponse) StatusCode() int <span class="cov0" title="0">{
        if r.HTTPResponse != nil </span><span class="cov0" title="0">{
                return r.HTTPResponse.StatusCode
        }</span>
        <span class="cov0" title="0">return 0</span>
}

type PostItemResponse struct {
        Body         []byte
        HTTPResponse *http.Response
        JSON200      *struct {
                union json.RawMessage
        }
        JSON400 *ApiError
}

// Status returns HTTPResponse.Status
func (r PostItemResponse) Status() string <span class="cov0" title="0">{
        if r.HTTPResponse != nil </span><span class="cov0" title="0">{
                return r.HTTPResponse.Status
        }</span>
        <span class="cov0" title="0">return http.StatusText(0)</span>
}

// StatusCode returns HTTPResponse.StatusCode
func (r PostItemResponse) StatusCode() int <span class="cov0" title="0">{
        if r.HTTPResponse != nil </span><span class="cov0" title="0">{
                return r.HTTPResponse.StatusCode
        }</span>
        <span class="cov0" title="0">return 0</span>
}

type DeleteItemResponse struct {
        Body         []byte
        HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r DeleteItemResponse) Status() string <span class="cov0" title="0">{
        if r.HTTPResponse != nil </span><span class="cov0" title="0">{
                return r.HTTPResponse.Status
        }</span>
        <span class="cov0" title="0">return http.StatusText(0)</span>
}

// StatusCode returns HTTPResponse.StatusCode
func (r DeleteItemResponse) StatusCode() int <span class="cov0" title="0">{
        if r.HTTPResponse != nil </span><span class="cov0" title="0">{
                return r.HTTPResponse.StatusCode
        }</span>
        <span class="cov0" title="0">return 0</span>
}

type GetItemsItemIdResponse struct {
        Body         []byte
        HTTPResponse *http.Response
        JSON200      *struct {
                union json.RawMessage
        }
        JSON404 *ApiError
}

// Status returns HTTPResponse.Status
func (r GetItemsItemIdResponse) Status() string <span class="cov0" title="0">{
        if r.HTTPResponse != nil </span><span class="cov0" title="0">{
                return r.HTTPResponse.Status
        }</span>
        <span class="cov0" title="0">return http.StatusText(0)</span>
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetItemsItemIdResponse) StatusCode() int <span class="cov0" title="0">{
        if r.HTTPResponse != nil </span><span class="cov0" title="0">{
                return r.HTTPResponse.StatusCode
        }</span>
        <span class="cov0" title="0">return 0</span>
}

type PutItemResponse struct {
        Body         []byte
        HTTPResponse *http.Response
        JSON200      *struct {
                union json.RawMessage
        }
        JSON400 *ApiError
}

// Status returns HTTPResponse.Status
func (r PutItemResponse) Status() string <span class="cov0" title="0">{
        if r.HTTPResponse != nil </span><span class="cov0" title="0">{
                return r.HTTPResponse.Status
        }</span>
        <span class="cov0" title="0">return http.StatusText(0)</span>
}

// StatusCode returns HTTPResponse.StatusCode
func (r PutItemResponse) StatusCode() int <span class="cov0" title="0">{
        if r.HTTPResponse != nil </span><span class="cov0" title="0">{
                return r.HTTPResponse.StatusCode
        }</span>
        <span class="cov0" title="0">return 0</span>
}

type GetJournalentryResponse struct {
        Body         []byte
        HTTPResponse *http.Response
        JSON200      *struct {
                CurrentPage *int32          `json:"currentPage,omitempty"`
                Items       *[]JournalEntry `json:"items,omitempty"`
                TotalItems  *int32          `json:"totalItems,omitempty"`
                TotalPages  *int32          `json:"totalPages,omitempty"`
        }
}

// Status returns HTTPResponse.Status
func (r GetJournalentryResponse) Status() string <span class="cov0" title="0">{
        if r.HTTPResponse != nil </span><span class="cov0" title="0">{
                return r.HTTPResponse.Status
        }</span>
        <span class="cov0" title="0">return http.StatusText(0)</span>
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetJournalentryResponse) StatusCode() int <span class="cov0" title="0">{
        if r.HTTPResponse != nil </span><span class="cov0" title="0">{
                return r.HTTPResponse.StatusCode
        }</span>
        <span class="cov0" title="0">return 0</span>
}

type PostJournalentryResponse struct {
        Body         []byte
        HTTPResponse *http.Response
        JSON200      *JournalEntry
        JSON400      *ApiError
}

// Status returns HTTPResponse.Status
func (r PostJournalentryResponse) Status() string <span class="cov0" title="0">{
        if r.HTTPResponse != nil </span><span class="cov0" title="0">{
                return r.HTTPResponse.Status
        }</span>
        <span class="cov0" title="0">return http.StatusText(0)</span>
}

// StatusCode returns HTTPResponse.StatusCode
func (r PostJournalentryResponse) StatusCode() int <span class="cov0" title="0">{
        if r.HTTPResponse != nil </span><span class="cov0" title="0">{
                return r.HTTPResponse.StatusCode
        }</span>
        <span class="cov0" title="0">return 0</span>
}

type GetJournalentriesJournalIdResponse struct {
        Body         []byte
        HTTPResponse *http.Response
        JSON200      *JournalEntry
        JSON404      *ApiError
}

// Status returns HTTPResponse.Status
func (r GetJournalentriesJournalIdResponse) Status() string <span class="cov0" title="0">{
        if r.HTTPResponse != nil </span><span class="cov0" title="0">{
                return r.HTTPResponse.Status
        }</span>
        <span class="cov0" title="0">return http.StatusText(0)</span>
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetJournalentriesJournalIdResponse) StatusCode() int <span class="cov0" title="0">{
        if r.HTTPResponse != nil </span><span class="cov0" title="0">{
                return r.HTTPResponse.StatusCode
        }</span>
        <span class="cov0" title="0">return 0</span>
}

type ReverseJournalentryResponse struct {
        Body         []byte
        HTTPResponse *http.Response
        JSON200      *JournalEntry
        JSON400      *ApiError
        JSON404      *ApiError
}

// Status returns HTTPResponse.Status
func (r ReverseJournalentryResponse) Status() string <span class="cov0" title="0">{
        if r.HTTPResponse != nil </span><span class="cov0" title="0">{
                return r.HTTPResponse.Status
        }</span>
        <span class="cov0" title="0">return http.StatusText(0)</span>
}

// StatusCode returns HTTPResponse.StatusCode
func (r ReverseJournalentryResponse) StatusCode() int <span class="cov0" title="0">{
        if r.HTTPResponse != nil </span><span class="cov0" title="0">{
                return r.HTTPResponse.StatusCode
        }</span>
        <span class="cov0" title="0">return 0</span>
}

type DownloadSieFileResponse struct {
        Body         []byte
        HTTPResponse *http.Response
        JSON404      *ApiError
}

// Status returns HTTPResponse.Status
func (r DownloadSieFileResponse) Status() string <span class="cov0" title="0">{
        if r.HTTPResponse != nil </span><span class="cov0" title="0">{
                return r.HTTPResponse.Status
        }</span>
        <span class="cov0" title="0">return http.StatusText(0)</span>
}

// StatusCode returns HTTPResponse.StatusCode
func (r DownloadSieFileResponse) StatusCode() int <span class="cov0" title="0">{
        if r.HTTPResponse != nil </span><span class="cov0" title="0">{
                return r.HTTPResponse.StatusCode
        }</span>
        <span class="cov0" title="0">return 0</span>
}

type GetUploadsResponse struct {
        Body         []byte
        HTTPResponse *http.Response
        JSON200      *struct {
                CurrentPage *int32    `json:"currentPage,omitempty"`
                Items       *[]Upload `json:"items,omitempty"`
                TotalItems  *int32    `json:"totalItems,omitempty"`
                TotalPages  *int32    `json:"totalPages,omitempty"`
        }
}

// Status returns HTTPResponse.Status
func (r GetUploadsResponse) Status() string <span class="cov0" title="0">{
        if r.HTTPResponse != nil </span><span class="cov0" title="0">{
                return r.HTTPResponse.Status
        }</span>
        <span class="cov0" title="0">return http.StatusText(0)</span>
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetUploadsResponse) StatusCode() int <span class="cov0" title="0">{
        if r.HTTPResponse != nil </span><span class="cov0" title="0">{
                return r.HTTPResponse.StatusCode
        }</span>
        <span class="cov0" title="0">return 0</span>
}

type AddUploadResponse struct {
        Body         []byte
        HTTPResponse *http.Response
        JSON200      *Upload
        JSON400      *ApiError
}

// Status returns HTTPResponse.Status
func (r AddUploadResponse) Status() string <span class="cov0" title="0">{
        if r.HTTPResponse != nil </span><span class="cov0" title="0">{
                return r.HTTPResponse.Status
        }</span>
        <span class="cov0" title="0">return http.StatusText(0)</span>
}

// StatusCode returns HTTPResponse.StatusCode
func (r AddUploadResponse) StatusCode() int <span class="cov0" title="0">{
        if r.HTTPResponse != nil </span><span class="cov0" title="0">{
                return r.HTTPResponse.StatusCode
        }</span>
        <span class="cov0" title="0">return 0</span>
}

type GetUploadResponse struct {
        Body         []byte
        HTTPResponse *http.Response
        JSON200      *Upload
        JSON404      *ApiError
}

// Status returns HTTPResponse.Status
func (r GetUploadResponse) Status() string <span class="cov0" title="0">{
        if r.HTTPResponse != nil </span><span class="cov0" title="0">{
                return r.HTTPResponse.Status
        }</span>
        <span class="cov0" title="0">return http.StatusText(0)</span>
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetUploadResponse) StatusCode() int <span class="cov0" title="0">{
        if r.HTTPResponse != nil </span><span class="cov0" title="0">{
                return r.HTTPResponse.StatusCode
        }</span>
        <span class="cov0" title="0">return 0</span>
}

type DownloadUploadResponse struct {
        Body         []byte
        HTTPResponse *http.Response
        JSON404      *ApiError
}

// Status returns HTTPResponse.Status
func (r DownloadUploadResponse) Status() string <span class="cov0" title="0">{
        if r.HTTPResponse != nil </span><span class="cov0" title="0">{
                return r.HTTPResponse.Status
        }</span>
        <span class="cov0" title="0">return http.StatusText(0)</span>
}

// StatusCode returns HTTPResponse.StatusCode
func (r DownloadUploadResponse) StatusCode() int <span class="cov0" title="0">{
        if r.HTTPResponse != nil </span><span class="cov0" title="0">{
                return r.HTTPResponse.StatusCode
        }</span>
        <span class="cov0" title="0">return 0</span>
}

// GetCustomerWithResponse request returning *GetCustomerResponse
func (c *ClientWithResponses) GetCustomerWithResponse(ctx context.Context, companyId openapi_types.UUID, params *GetCustomerParams, reqEditors ...RequestEditorFn) (*GetCustomerResponse, error) <span class="cov0" title="0">{
        rsp, err := c.GetCustomer(ctx, companyId, params, reqEditors...)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">return ParseGetCustomerResponse(rsp)</span>
}

// PostCustomerWithBodyWithResponse request with arbitrary body returning *PostCustomerResponse
func (c *ClientWithResponses) PostCustomerWithBodyWithResponse(ctx context.Context, companyId openapi_types.UUID, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PostCustomerResponse, error) <span class="cov0" title="0">{
        rsp, err := c.PostCustomerWithBody(ctx, companyId, contentType, body, reqEditors...)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">return ParsePostCustomerResponse(rsp)</span>
}

func (c *ClientWithResponses) PostCustomerWithResponse(ctx context.Context, companyId openapi_types.UUID, body PostCustomerJSONRequestBody, reqEditors ...RequestEditorFn) (*PostCustomerResponse, error) <span class="cov0" title="0">{
        rsp, err := c.PostCustomer(ctx, companyId, body, reqEditors...)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">return ParsePostCustomerResponse(rsp)</span>
}

// DeleteCustomerWithResponse request returning *DeleteCustomerResponse
func (c *ClientWithResponses) DeleteCustomerWithResponse(ctx context.Context, companyId openapi_types.UUID, customerId openapi_types.UUID, reqEditors ...RequestEditorFn) (*DeleteCustomerResponse, error) <span class="cov0" title="0">{
        rsp, err := c.DeleteCustomer(ctx, companyId, customerId, reqEditors...)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">return ParseDeleteCustomerResponse(rsp)</span>
}

// GetCustomersCustomerIdWithResponse request returning *GetCustomersCustomerIdResponse
func (c *ClientWithResponses) GetCustomersCustomerIdWithResponse(ctx context.Context, companyId openapi_types.UUID, customerId openapi_types.UUID, reqEditors ...RequestEditorFn) (*GetCustomersCustomerIdResponse, error) <span class="cov0" title="0">{
        rsp, err := c.GetCustomersCustomerId(ctx, companyId, customerId, reqEditors...)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">return ParseGetCustomersCustomerIdResponse(rsp)</span>
}

// PutCustomerWithBodyWithResponse request with arbitrary body returning *PutCustomerResponse
func (c *ClientWithResponses) PutCustomerWithBodyWithResponse(ctx context.Context, companyId openapi_types.UUID, customerId openapi_types.UUID, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PutCustomerResponse, error) <span class="cov0" title="0">{
        rsp, err := c.PutCustomerWithBody(ctx, companyId, customerId, contentType, body, reqEditors...)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">return ParsePutCustomerResponse(rsp)</span>
}

func (c *ClientWithResponses) PutCustomerWithResponse(ctx context.Context, companyId openapi_types.UUID, customerId openapi_types.UUID, body PutCustomerJSONRequestBody, reqEditors ...RequestEditorFn) (*PutCustomerResponse, error) <span class="cov0" title="0">{
        rsp, err := c.PutCustomer(ctx, companyId, customerId, body, reqEditors...)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">return ParsePutCustomerResponse(rsp)</span>
}

// GetFiscalYearsWithResponse request returning *GetFiscalYearsResponse
func (c *ClientWithResponses) GetFiscalYearsWithResponse(ctx context.Context, companyId openapi_types.UUID, params *GetFiscalYearsParams, reqEditors ...RequestEditorFn) (*GetFiscalYearsResponse, error) <span class="cov0" title="0">{
        rsp, err := c.GetFiscalYears(ctx, companyId, params, reqEditors...)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">return ParseGetFiscalYearsResponse(rsp)</span>
}

// GetFiscalYearWithIdWithResponse request returning *GetFiscalYearWithIdResponse
func (c *ClientWithResponses) GetFiscalYearWithIdWithResponse(ctx context.Context, companyId openapi_types.UUID, fiscalYearId openapi_types.UUID, reqEditors ...RequestEditorFn) (*GetFiscalYearWithIdResponse, error) <span class="cov0" title="0">{
        rsp, err := c.GetFiscalYearWithId(ctx, companyId, fiscalYearId, reqEditors...)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">return ParseGetFiscalYearWithIdResponse(rsp)</span>
}

// GetInvoiceWithResponse request returning *GetInvoiceResponse
func (c *ClientWithResponses) GetInvoiceWithResponse(ctx context.Context, companyId openapi_types.UUID, params *GetInvoiceParams, reqEditors ...RequestEditorFn) (*GetInvoiceResponse, error) <span class="cov0" title="0">{
        rsp, err := c.GetInvoice(ctx, companyId, params, reqEditors...)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">return ParseGetInvoiceResponse(rsp)</span>
}

// PostInvoiceWithBodyWithResponse request with arbitrary body returning *PostInvoiceResponse
func (c *ClientWithResponses) PostInvoiceWithBodyWithResponse(ctx context.Context, companyId openapi_types.UUID, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PostInvoiceResponse, error) <span class="cov0" title="0">{
        rsp, err := c.PostInvoiceWithBody(ctx, companyId, contentType, body, reqEditors...)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">return ParsePostInvoiceResponse(rsp)</span>
}

func (c *ClientWithResponses) PostInvoiceWithResponse(ctx context.Context, companyId openapi_types.UUID, body PostInvoiceJSONRequestBody, reqEditors ...RequestEditorFn) (*PostInvoiceResponse, error) <span class="cov0" title="0">{
        rsp, err := c.PostInvoice(ctx, companyId, body, reqEditors...)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">return ParsePostInvoiceResponse(rsp)</span>
}

// GetInvoicesInvoiceIdWithResponse request returning *GetInvoicesInvoiceIdResponse
func (c *ClientWithResponses) GetInvoicesInvoiceIdWithResponse(ctx context.Context, companyId openapi_types.UUID, invoiceId openapi_types.UUID, reqEditors ...RequestEditorFn) (*GetInvoicesInvoiceIdResponse, error) <span class="cov0" title="0">{
        rsp, err := c.GetInvoicesInvoiceId(ctx, companyId, invoiceId, reqEditors...)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">return ParseGetInvoicesInvoiceIdResponse(rsp)</span>
}

// PutInvoiceWithBodyWithResponse request with arbitrary body returning *PutInvoiceResponse
func (c *ClientWithResponses) PutInvoiceWithBodyWithResponse(ctx context.Context, companyId openapi_types.UUID, invoiceId openapi_types.UUID, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PutInvoiceResponse, error) <span class="cov0" title="0">{
        rsp, err := c.PutInvoiceWithBody(ctx, companyId, invoiceId, contentType, body, reqEditors...)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">return ParsePutInvoiceResponse(rsp)</span>
}

func (c *ClientWithResponses) PutInvoiceWithResponse(ctx context.Context, companyId openapi_types.UUID, invoiceId openapi_types.UUID, body PutInvoiceJSONRequestBody, reqEditors ...RequestEditorFn) (*PutInvoiceResponse, error) <span class="cov0" title="0">{
        rsp, err := c.PutInvoice(ctx, companyId, invoiceId, body, reqEditors...)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">return ParsePutInvoiceResponse(rsp)</span>
}

// GetInvoiceAttachmentsWithResponse request returning *GetInvoiceAttachmentsResponse
func (c *ClientWithResponses) GetInvoiceAttachmentsWithResponse(ctx context.Context, companyId openapi_types.UUID, invoiceId openapi_types.UUID, params *GetInvoiceAttachmentsParams, reqEditors ...RequestEditorFn) (*GetInvoiceAttachmentsResponse, error) <span class="cov0" title="0">{
        rsp, err := c.GetInvoiceAttachments(ctx, companyId, invoiceId, params, reqEditors...)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">return ParseGetInvoiceAttachmentsResponse(rsp)</span>
}

// PostInvoiceAttachmentWithBodyWithResponse request with arbitrary body returning *PostInvoiceAttachmentResponse
func (c *ClientWithResponses) PostInvoiceAttachmentWithBodyWithResponse(ctx context.Context, companyId openapi_types.UUID, invoiceId openapi_types.UUID, params *PostInvoiceAttachmentParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PostInvoiceAttachmentResponse, error) <span class="cov0" title="0">{
        rsp, err := c.PostInvoiceAttachmentWithBody(ctx, companyId, invoiceId, params, contentType, body, reqEditors...)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">return ParsePostInvoiceAttachmentResponse(rsp)</span>
}

// DeleteInvoiceAttachmentWithResponse request returning *DeleteInvoiceAttachmentResponse
func (c *ClientWithResponses) DeleteInvoiceAttachmentWithResponse(ctx context.Context, companyId openapi_types.UUID, invoiceId openapi_types.UUID, attachmentId openapi_types.UUID, reqEditors ...RequestEditorFn) (*DeleteInvoiceAttachmentResponse, error) <span class="cov0" title="0">{
        rsp, err := c.DeleteInvoiceAttachment(ctx, companyId, invoiceId, attachmentId, reqEditors...)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">return ParseDeleteInvoiceAttachmentResponse(rsp)</span>
}

// GetInvoiceAttachmentWithResponse request returning *GetInvoiceAttachmentResponse
func (c *ClientWithResponses) GetInvoiceAttachmentWithResponse(ctx context.Context, companyId openapi_types.UUID, invoiceId openapi_types.UUID, attachmentId openapi_types.UUID, reqEditors ...RequestEditorFn) (*GetInvoiceAttachmentResponse, error) <span class="cov0" title="0">{
        rsp, err := c.GetInvoiceAttachment(ctx, companyId, invoiceId, attachmentId, reqEditors...)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">return ParseGetInvoiceAttachmentResponse(rsp)</span>
}

// DownloadInvoiceAttachmentWithResponse request returning *DownloadInvoiceAttachmentResponse
func (c *ClientWithResponses) DownloadInvoiceAttachmentWithResponse(ctx context.Context, companyId openapi_types.UUID, invoiceId openapi_types.UUID, attachmentId openapi_types.UUID, reqEditors ...RequestEditorFn) (*DownloadInvoiceAttachmentResponse, error) <span class="cov0" title="0">{
        rsp, err := c.DownloadInvoiceAttachment(ctx, companyId, invoiceId, attachmentId, reqEditors...)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">return ParseDownloadInvoiceAttachmentResponse(rsp)</span>
}

// PostInvoiceLineItemWithBodyWithResponse request with arbitrary body returning *PostInvoiceLineItemResponse
func (c *ClientWithResponses) PostInvoiceLineItemWithBodyWithResponse(ctx context.Context, companyId openapi_types.UUID, invoiceId openapi_types.UUID, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PostInvoiceLineItemResponse, error) <span class="cov0" title="0">{
        rsp, err := c.PostInvoiceLineItemWithBody(ctx, companyId, invoiceId, contentType, body, reqEditors...)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">return ParsePostInvoiceLineItemResponse(rsp)</span>
}

func (c *ClientWithResponses) PostInvoiceLineItemWithResponse(ctx context.Context, companyId openapi_types.UUID, invoiceId openapi_types.UUID, body PostInvoiceLineItemJSONRequestBody, reqEditors ...RequestEditorFn) (*PostInvoiceLineItemResponse, error) <span class="cov0" title="0">{
        rsp, err := c.PostInvoiceLineItem(ctx, companyId, invoiceId, body, reqEditors...)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">return ParsePostInvoiceLineItemResponse(rsp)</span>
}

// GetItemsWithResponse request returning *GetItemsResponse
func (c *ClientWithResponses) GetItemsWithResponse(ctx context.Context, companyId openapi_types.UUID, params *GetItemsParams, reqEditors ...RequestEditorFn) (*GetItemsResponse, error) <span class="cov0" title="0">{
        rsp, err := c.GetItems(ctx, companyId, params, reqEditors...)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">return ParseGetItemsResponse(rsp)</span>
}

// PostItemWithBodyWithResponse request with arbitrary body returning *PostItemResponse
func (c *ClientWithResponses) PostItemWithBodyWithResponse(ctx context.Context, companyId openapi_types.UUID, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PostItemResponse, error) <span class="cov0" title="0">{
        rsp, err := c.PostItemWithBody(ctx, companyId, contentType, body, reqEditors...)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">return ParsePostItemResponse(rsp)</span>
}

func (c *ClientWithResponses) PostItemWithResponse(ctx context.Context, companyId openapi_types.UUID, body PostItemJSONRequestBody, reqEditors ...RequestEditorFn) (*PostItemResponse, error) <span class="cov0" title="0">{
        rsp, err := c.PostItem(ctx, companyId, body, reqEditors...)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">return ParsePostItemResponse(rsp)</span>
}

// DeleteItemWithResponse request returning *DeleteItemResponse
func (c *ClientWithResponses) DeleteItemWithResponse(ctx context.Context, companyId openapi_types.UUID, itemId openapi_types.UUID, reqEditors ...RequestEditorFn) (*DeleteItemResponse, error) <span class="cov0" title="0">{
        rsp, err := c.DeleteItem(ctx, companyId, itemId, reqEditors...)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">return ParseDeleteItemResponse(rsp)</span>
}

// GetItemsItemIdWithResponse request returning *GetItemsItemIdResponse
func (c *ClientWithResponses) GetItemsItemIdWithResponse(ctx context.Context, companyId openapi_types.UUID, itemId openapi_types.UUID, reqEditors ...RequestEditorFn) (*GetItemsItemIdResponse, error) <span class="cov0" title="0">{
        rsp, err := c.GetItemsItemId(ctx, companyId, itemId, reqEditors...)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">return ParseGetItemsItemIdResponse(rsp)</span>
}

// PutItemWithBodyWithResponse request with arbitrary body returning *PutItemResponse
func (c *ClientWithResponses) PutItemWithBodyWithResponse(ctx context.Context, companyId openapi_types.UUID, itemId openapi_types.UUID, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PutItemResponse, error) <span class="cov0" title="0">{
        rsp, err := c.PutItemWithBody(ctx, companyId, itemId, contentType, body, reqEditors...)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">return ParsePutItemResponse(rsp)</span>
}

func (c *ClientWithResponses) PutItemWithResponse(ctx context.Context, companyId openapi_types.UUID, itemId openapi_types.UUID, body PutItemJSONRequestBody, reqEditors ...RequestEditorFn) (*PutItemResponse, error) <span class="cov0" title="0">{
        rsp, err := c.PutItem(ctx, companyId, itemId, body, reqEditors...)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">return ParsePutItemResponse(rsp)</span>
}

// GetJournalentryWithResponse request returning *GetJournalentryResponse
func (c *ClientWithResponses) GetJournalentryWithResponse(ctx context.Context, companyId openapi_types.UUID, params *GetJournalentryParams, reqEditors ...RequestEditorFn) (*GetJournalentryResponse, error) <span class="cov0" title="0">{
        rsp, err := c.GetJournalentry(ctx, companyId, params, reqEditors...)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">return ParseGetJournalentryResponse(rsp)</span>
}

// PostJournalentryWithBodyWithResponse request with arbitrary body returning *PostJournalentryResponse
func (c *ClientWithResponses) PostJournalentryWithBodyWithResponse(ctx context.Context, companyId openapi_types.UUID, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PostJournalentryResponse, error) <span class="cov0" title="0">{
        rsp, err := c.PostJournalentryWithBody(ctx, companyId, contentType, body, reqEditors...)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">return ParsePostJournalentryResponse(rsp)</span>
}

func (c *ClientWithResponses) PostJournalentryWithResponse(ctx context.Context, companyId openapi_types.UUID, body PostJournalentryJSONRequestBody, reqEditors ...RequestEditorFn) (*PostJournalentryResponse, error) <span class="cov0" title="0">{
        rsp, err := c.PostJournalentry(ctx, companyId, body, reqEditors...)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">return ParsePostJournalentryResponse(rsp)</span>
}

// GetJournalentriesJournalIdWithResponse request returning *GetJournalentriesJournalIdResponse
func (c *ClientWithResponses) GetJournalentriesJournalIdWithResponse(ctx context.Context, companyId openapi_types.UUID, journalEntryId openapi_types.UUID, reqEditors ...RequestEditorFn) (*GetJournalentriesJournalIdResponse, error) <span class="cov0" title="0">{
        rsp, err := c.GetJournalentriesJournalId(ctx, companyId, journalEntryId, reqEditors...)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">return ParseGetJournalentriesJournalIdResponse(rsp)</span>
}

// ReverseJournalentryWithResponse request returning *ReverseJournalentryResponse
func (c *ClientWithResponses) ReverseJournalentryWithResponse(ctx context.Context, companyId openapi_types.UUID, journalEntryId openapi_types.UUID, reqEditors ...RequestEditorFn) (*ReverseJournalentryResponse, error) <span class="cov0" title="0">{
        rsp, err := c.ReverseJournalentry(ctx, companyId, journalEntryId, reqEditors...)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">return ParseReverseJournalentryResponse(rsp)</span>
}

// DownloadSieFileWithResponse request returning *DownloadSieFileResponse
func (c *ClientWithResponses) DownloadSieFileWithResponse(ctx context.Context, companyId openapi_types.UUID, fiscalYearId openapi_types.UUID, reqEditors ...RequestEditorFn) (*DownloadSieFileResponse, error) <span class="cov0" title="0">{
        rsp, err := c.DownloadSieFile(ctx, companyId, fiscalYearId, reqEditors...)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">return ParseDownloadSieFileResponse(rsp)</span>
}

// GetUploadsWithResponse request returning *GetUploadsResponse
func (c *ClientWithResponses) GetUploadsWithResponse(ctx context.Context, companyId openapi_types.UUID, params *GetUploadsParams, reqEditors ...RequestEditorFn) (*GetUploadsResponse, error) <span class="cov0" title="0">{
        rsp, err := c.GetUploads(ctx, companyId, params, reqEditors...)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">return ParseGetUploadsResponse(rsp)</span>
}

// AddUploadWithBodyWithResponse request with arbitrary body returning *AddUploadResponse
func (c *ClientWithResponses) AddUploadWithBodyWithResponse(ctx context.Context, companyId openapi_types.UUID, params *AddUploadParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*AddUploadResponse, error) <span class="cov0" title="0">{
        rsp, err := c.AddUploadWithBody(ctx, companyId, params, contentType, body, reqEditors...)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">return ParseAddUploadResponse(rsp)</span>
}

// GetUploadWithResponse request returning *GetUploadResponse
func (c *ClientWithResponses) GetUploadWithResponse(ctx context.Context, companyId openapi_types.UUID, uploadId openapi_types.UUID, reqEditors ...RequestEditorFn) (*GetUploadResponse, error) <span class="cov0" title="0">{
        rsp, err := c.GetUpload(ctx, companyId, uploadId, reqEditors...)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">return ParseGetUploadResponse(rsp)</span>
}

// DownloadUploadWithResponse request returning *DownloadUploadResponse
func (c *ClientWithResponses) DownloadUploadWithResponse(ctx context.Context, companyId openapi_types.UUID, uploadId openapi_types.UUID, reqEditors ...RequestEditorFn) (*DownloadUploadResponse, error) <span class="cov0" title="0">{
        rsp, err := c.DownloadUpload(ctx, companyId, uploadId, reqEditors...)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">return ParseDownloadUploadResponse(rsp)</span>
}

// ParseGetCustomerResponse parses an HTTP response from a GetCustomerWithResponse call
func ParseGetCustomerResponse(rsp *http.Response) (*GetCustomerResponse, error) <span class="cov0" title="0">{
        bodyBytes, err := io.ReadAll(rsp.Body)
        defer func() </span><span class="cov0" title="0">{ _ = rsp.Body.Close() }</span>()
        <span class="cov0" title="0">if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">response := &amp;GetCustomerResponse{
                Body:         bodyBytes,
                HTTPResponse: rsp,
        }

        switch </span>{
        case strings.Contains(rsp.Header.Get("Content-Type"), "json") &amp;&amp; rsp.StatusCode == 200:<span class="cov0" title="0">
                var dest struct {
                        CurrentPage *int32      `json:"currentPage,omitempty"`
                        Items       *[]Customer `json:"items,omitempty"`
                        TotalItems  *int32      `json:"totalItems,omitempty"`
                        TotalPages  *int32      `json:"totalPages,omitempty"`
                }
                if err := json.Unmarshal(bodyBytes, &amp;dest); err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>
                <span class="cov0" title="0">response.JSON200 = &amp;dest</span>

        }

        <span class="cov0" title="0">return response, nil</span>
}

// ParsePostCustomerResponse parses an HTTP response from a PostCustomerWithResponse call
func ParsePostCustomerResponse(rsp *http.Response) (*PostCustomerResponse, error) <span class="cov0" title="0">{
        bodyBytes, err := io.ReadAll(rsp.Body)
        defer func() </span><span class="cov0" title="0">{ _ = rsp.Body.Close() }</span>()
        <span class="cov0" title="0">if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">response := &amp;PostCustomerResponse{
                Body:         bodyBytes,
                HTTPResponse: rsp,
        }

        switch </span>{
        case strings.Contains(rsp.Header.Get("Content-Type"), "json") &amp;&amp; rsp.StatusCode == 200:<span class="cov0" title="0">
                var dest Customer
                if err := json.Unmarshal(bodyBytes, &amp;dest); err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>
                <span class="cov0" title="0">response.JSON200 = &amp;dest</span>

        case strings.Contains(rsp.Header.Get("Content-Type"), "json") &amp;&amp; rsp.StatusCode == 400:<span class="cov0" title="0">
                var dest ApiError
                if err := json.Unmarshal(bodyBytes, &amp;dest); err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>
                <span class="cov0" title="0">response.JSON400 = &amp;dest</span>

        }

        <span class="cov0" title="0">return response, nil</span>
}

// ParseDeleteCustomerResponse parses an HTTP response from a DeleteCustomerWithResponse call
func ParseDeleteCustomerResponse(rsp *http.Response) (*DeleteCustomerResponse, error) <span class="cov0" title="0">{
        bodyBytes, err := io.ReadAll(rsp.Body)
        defer func() </span><span class="cov0" title="0">{ _ = rsp.Body.Close() }</span>()
        <span class="cov0" title="0">if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">response := &amp;DeleteCustomerResponse{
                Body:         bodyBytes,
                HTTPResponse: rsp,
        }

        return response, nil</span>
}

// ParseGetCustomersCustomerIdResponse parses an HTTP response from a GetCustomersCustomerIdWithResponse call
func ParseGetCustomersCustomerIdResponse(rsp *http.Response) (*GetCustomersCustomerIdResponse, error) <span class="cov0" title="0">{
        bodyBytes, err := io.ReadAll(rsp.Body)
        defer func() </span><span class="cov0" title="0">{ _ = rsp.Body.Close() }</span>()
        <span class="cov0" title="0">if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">response := &amp;GetCustomersCustomerIdResponse{
                Body:         bodyBytes,
                HTTPResponse: rsp,
        }

        switch </span>{
        case strings.Contains(rsp.Header.Get("Content-Type"), "json") &amp;&amp; rsp.StatusCode == 200:<span class="cov0" title="0">
                var dest Customer
                if err := json.Unmarshal(bodyBytes, &amp;dest); err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>
                <span class="cov0" title="0">response.JSON200 = &amp;dest</span>

        case strings.Contains(rsp.Header.Get("Content-Type"), "json") &amp;&amp; rsp.StatusCode == 404:<span class="cov0" title="0">
                var dest ApiError
                if err := json.Unmarshal(bodyBytes, &amp;dest); err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>
                <span class="cov0" title="0">response.JSON404 = &amp;dest</span>

        }

        <span class="cov0" title="0">return response, nil</span>
}

// ParsePutCustomerResponse parses an HTTP response from a PutCustomerWithResponse call
func ParsePutCustomerResponse(rsp *http.Response) (*PutCustomerResponse, error) <span class="cov0" title="0">{
        bodyBytes, err := io.ReadAll(rsp.Body)
        defer func() </span><span class="cov0" title="0">{ _ = rsp.Body.Close() }</span>()
        <span class="cov0" title="0">if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">response := &amp;PutCustomerResponse{
                Body:         bodyBytes,
                HTTPResponse: rsp,
        }

        switch </span>{
        case strings.Contains(rsp.Header.Get("Content-Type"), "json") &amp;&amp; rsp.StatusCode == 200:<span class="cov0" title="0">
                var dest Customer
                if err := json.Unmarshal(bodyBytes, &amp;dest); err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>
                <span class="cov0" title="0">response.JSON200 = &amp;dest</span>

        case strings.Contains(rsp.Header.Get("Content-Type"), "json") &amp;&amp; rsp.StatusCode == 400:<span class="cov0" title="0">
                var dest ApiError
                if err := json.Unmarshal(bodyBytes, &amp;dest); err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>
                <span class="cov0" title="0">response.JSON400 = &amp;dest</span>

        }

        <span class="cov0" title="0">return response, nil</span>
}

// ParseGetFiscalYearsResponse parses an HTTP response from a GetFiscalYearsWithResponse call
func ParseGetFiscalYearsResponse(rsp *http.Response) (*GetFiscalYearsResponse, error) <span class="cov0" title="0">{
        bodyBytes, err := io.ReadAll(rsp.Body)
        defer func() </span><span class="cov0" title="0">{ _ = rsp.Body.Close() }</span>()
        <span class="cov0" title="0">if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">response := &amp;GetFiscalYearsResponse{
                Body:         bodyBytes,
                HTTPResponse: rsp,
        }

        switch </span>{
        case strings.Contains(rsp.Header.Get("Content-Type"), "json") &amp;&amp; rsp.StatusCode == 200:<span class="cov0" title="0">
                var dest struct {
                        CurrentPage *int32         `json:"currentPage,omitempty"`
                        Items       *[]interface{} `json:"items,omitempty"`
                        TotalItems  *int32         `json:"totalItems,omitempty"`
                        TotalPages  *int32         `json:"totalPages,omitempty"`
                }
                if err := json.Unmarshal(bodyBytes, &amp;dest); err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>
                <span class="cov0" title="0">response.JSON200 = &amp;dest</span>

        }

        <span class="cov0" title="0">return response, nil</span>
}

// ParseGetFiscalYearWithIdResponse parses an HTTP response from a GetFiscalYearWithIdWithResponse call
func ParseGetFiscalYearWithIdResponse(rsp *http.Response) (*GetFiscalYearWithIdResponse, error) <span class="cov0" title="0">{
        bodyBytes, err := io.ReadAll(rsp.Body)
        defer func() </span><span class="cov0" title="0">{ _ = rsp.Body.Close() }</span>()
        <span class="cov0" title="0">if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">response := &amp;GetFiscalYearWithIdResponse{
                Body:         bodyBytes,
                HTTPResponse: rsp,
        }

        switch </span>{
        case strings.Contains(rsp.Header.Get("Content-Type"), "json") &amp;&amp; rsp.StatusCode == 200:<span class="cov0" title="0">
                var dest struct {
                        FiscalYear *FiscalYear `json:"fiscalYear,omitempty"`
                }
                if err := json.Unmarshal(bodyBytes, &amp;dest); err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>
                <span class="cov0" title="0">response.JSON200 = &amp;dest</span>

        case strings.Contains(rsp.Header.Get("Content-Type"), "json") &amp;&amp; rsp.StatusCode == 404:<span class="cov0" title="0">
                var dest ApiError
                if err := json.Unmarshal(bodyBytes, &amp;dest); err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>
                <span class="cov0" title="0">response.JSON404 = &amp;dest</span>

        }

        <span class="cov0" title="0">return response, nil</span>
}

// ParseGetInvoiceResponse parses an HTTP response from a GetInvoiceWithResponse call
func ParseGetInvoiceResponse(rsp *http.Response) (*GetInvoiceResponse, error) <span class="cov0" title="0">{
        bodyBytes, err := io.ReadAll(rsp.Body)
        defer func() </span><span class="cov0" title="0">{ _ = rsp.Body.Close() }</span>()
        <span class="cov0" title="0">if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">response := &amp;GetInvoiceResponse{
                Body:         bodyBytes,
                HTTPResponse: rsp,
        }

        switch </span>{
        case strings.Contains(rsp.Header.Get("Content-Type"), "json") &amp;&amp; rsp.StatusCode == 200:<span class="cov0" title="0">
                var dest struct {
                        CurrentPage *int32     `json:"currentPage,omitempty"`
                        Items       *[]Invoice `json:"items,omitempty"`
                        TotalItems  *int32     `json:"totalItems,omitempty"`
                        TotalPages  *int32     `json:"totalPages,omitempty"`
                }
                if err := json.Unmarshal(bodyBytes, &amp;dest); err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>
                <span class="cov0" title="0">response.JSON200 = &amp;dest</span>

        }

        <span class="cov0" title="0">return response, nil</span>
}

// ParsePostInvoiceResponse parses an HTTP response from a PostInvoiceWithResponse call
func ParsePostInvoiceResponse(rsp *http.Response) (*PostInvoiceResponse, error) <span class="cov0" title="0">{
        bodyBytes, err := io.ReadAll(rsp.Body)
        defer func() </span><span class="cov0" title="0">{ _ = rsp.Body.Close() }</span>()
        <span class="cov0" title="0">if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">response := &amp;PostInvoiceResponse{
                Body:         bodyBytes,
                HTTPResponse: rsp,
        }

        switch </span>{
        case strings.Contains(rsp.Header.Get("Content-Type"), "json") &amp;&amp; rsp.StatusCode == 200:<span class="cov0" title="0">
                var dest Invoice
                if err := json.Unmarshal(bodyBytes, &amp;dest); err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>
                <span class="cov0" title="0">response.JSON200 = &amp;dest</span>

        case strings.Contains(rsp.Header.Get("Content-Type"), "json") &amp;&amp; rsp.StatusCode == 400:<span class="cov0" title="0">
                var dest ApiError
                if err := json.Unmarshal(bodyBytes, &amp;dest); err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>
                <span class="cov0" title="0">response.JSON400 = &amp;dest</span>

        }

        <span class="cov0" title="0">return response, nil</span>
}

// ParseGetInvoicesInvoiceIdResponse parses an HTTP response from a GetInvoicesInvoiceIdWithResponse call
func ParseGetInvoicesInvoiceIdResponse(rsp *http.Response) (*GetInvoicesInvoiceIdResponse, error) <span class="cov0" title="0">{
        bodyBytes, err := io.ReadAll(rsp.Body)
        defer func() </span><span class="cov0" title="0">{ _ = rsp.Body.Close() }</span>()
        <span class="cov0" title="0">if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">response := &amp;GetInvoicesInvoiceIdResponse{
                Body:         bodyBytes,
                HTTPResponse: rsp,
        }

        switch </span>{
        case strings.Contains(rsp.Header.Get("Content-Type"), "json") &amp;&amp; rsp.StatusCode == 200:<span class="cov0" title="0">
                var dest Invoice
                if err := json.Unmarshal(bodyBytes, &amp;dest); err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>
                <span class="cov0" title="0">response.JSON200 = &amp;dest</span>

        case strings.Contains(rsp.Header.Get("Content-Type"), "json") &amp;&amp; rsp.StatusCode == 404:<span class="cov0" title="0">
                var dest ApiError
                if err := json.Unmarshal(bodyBytes, &amp;dest); err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>
                <span class="cov0" title="0">response.JSON404 = &amp;dest</span>

        }

        <span class="cov0" title="0">return response, nil</span>
}

// ParsePutInvoiceResponse parses an HTTP response from a PutInvoiceWithResponse call
func ParsePutInvoiceResponse(rsp *http.Response) (*PutInvoiceResponse, error) <span class="cov0" title="0">{
        bodyBytes, err := io.ReadAll(rsp.Body)
        defer func() </span><span class="cov0" title="0">{ _ = rsp.Body.Close() }</span>()
        <span class="cov0" title="0">if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">response := &amp;PutInvoiceResponse{
                Body:         bodyBytes,
                HTTPResponse: rsp,
        }

        switch </span>{
        case strings.Contains(rsp.Header.Get("Content-Type"), "json") &amp;&amp; rsp.StatusCode == 200:<span class="cov0" title="0">
                var dest Invoice
                if err := json.Unmarshal(bodyBytes, &amp;dest); err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>
                <span class="cov0" title="0">response.JSON200 = &amp;dest</span>

        case strings.Contains(rsp.Header.Get("Content-Type"), "json") &amp;&amp; rsp.StatusCode == 400:<span class="cov0" title="0">
                var dest ApiError
                if err := json.Unmarshal(bodyBytes, &amp;dest); err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>
                <span class="cov0" title="0">response.JSON400 = &amp;dest</span>

        }

        <span class="cov0" title="0">return response, nil</span>
}

// ParseGetInvoiceAttachmentsResponse parses an HTTP response from a GetInvoiceAttachmentsWithResponse call
func ParseGetInvoiceAttachmentsResponse(rsp *http.Response) (*GetInvoiceAttachmentsResponse, error) <span class="cov0" title="0">{
        bodyBytes, err := io.ReadAll(rsp.Body)
        defer func() </span><span class="cov0" title="0">{ _ = rsp.Body.Close() }</span>()
        <span class="cov0" title="0">if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">response := &amp;GetInvoiceAttachmentsResponse{
                Body:         bodyBytes,
                HTTPResponse: rsp,
        }

        switch </span>{
        case strings.Contains(rsp.Header.Get("Content-Type"), "json") &amp;&amp; rsp.StatusCode == 200:<span class="cov0" title="0">
                var dest struct {
                        CurrentPage *int32               `json:"currentPage,omitempty"`
                        Items       *[]InvoiceAttachment `json:"items,omitempty"`
                        TotalItems  *int32               `json:"totalItems,omitempty"`
                        TotalPages  *int32               `json:"totalPages,omitempty"`
                }
                if err := json.Unmarshal(bodyBytes, &amp;dest); err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>
                <span class="cov0" title="0">response.JSON200 = &amp;dest</span>

        case strings.Contains(rsp.Header.Get("Content-Type"), "json") &amp;&amp; rsp.StatusCode == 404:<span class="cov0" title="0">
                var dest ApiError
                if err := json.Unmarshal(bodyBytes, &amp;dest); err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>
                <span class="cov0" title="0">response.JSON404 = &amp;dest</span>

        }

        <span class="cov0" title="0">return response, nil</span>
}

// ParsePostInvoiceAttachmentResponse parses an HTTP response from a PostInvoiceAttachmentWithResponse call
func ParsePostInvoiceAttachmentResponse(rsp *http.Response) (*PostInvoiceAttachmentResponse, error) <span class="cov0" title="0">{
        bodyBytes, err := io.ReadAll(rsp.Body)
        defer func() </span><span class="cov0" title="0">{ _ = rsp.Body.Close() }</span>()
        <span class="cov0" title="0">if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">response := &amp;PostInvoiceAttachmentResponse{
                Body:         bodyBytes,
                HTTPResponse: rsp,
        }

        switch </span>{
        case strings.Contains(rsp.Header.Get("Content-Type"), "json") &amp;&amp; rsp.StatusCode == 200:<span class="cov0" title="0">
                var dest struct {
                        union json.RawMessage
                }
                if err := json.Unmarshal(bodyBytes, &amp;dest); err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>
                <span class="cov0" title="0">response.JSON200 = &amp;dest</span>

        case strings.Contains(rsp.Header.Get("Content-Type"), "json") &amp;&amp; rsp.StatusCode == 400:<span class="cov0" title="0">
                var dest ApiError
                if err := json.Unmarshal(bodyBytes, &amp;dest); err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>
                <span class="cov0" title="0">response.JSON400 = &amp;dest</span>

        case strings.Contains(rsp.Header.Get("Content-Type"), "json") &amp;&amp; rsp.StatusCode == 404:<span class="cov0" title="0">
                var dest ApiError
                if err := json.Unmarshal(bodyBytes, &amp;dest); err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>
                <span class="cov0" title="0">response.JSON404 = &amp;dest</span>

        }

        <span class="cov0" title="0">return response, nil</span>
}

// ParseDeleteInvoiceAttachmentResponse parses an HTTP response from a DeleteInvoiceAttachmentWithResponse call
func ParseDeleteInvoiceAttachmentResponse(rsp *http.Response) (*DeleteInvoiceAttachmentResponse, error) <span class="cov0" title="0">{
        bodyBytes, err := io.ReadAll(rsp.Body)
        defer func() </span><span class="cov0" title="0">{ _ = rsp.Body.Close() }</span>()
        <span class="cov0" title="0">if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">response := &amp;DeleteInvoiceAttachmentResponse{
                Body:         bodyBytes,
                HTTPResponse: rsp,
        }

        switch </span>{
        case strings.Contains(rsp.Header.Get("Content-Type"), "json") &amp;&amp; rsp.StatusCode == 404:<span class="cov0" title="0">
                var dest ApiError
                if err := json.Unmarshal(bodyBytes, &amp;dest); err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>
                <span class="cov0" title="0">response.JSON404 = &amp;dest</span>

        }

        <span class="cov0" title="0">return response, nil</span>
}

// ParseGetInvoiceAttachmentResponse parses an HTTP response from a GetInvoiceAttachmentWithResponse call
func ParseGetInvoiceAttachmentResponse(rsp *http.Response) (*GetInvoiceAttachmentResponse, error) <span class="cov0" title="0">{
        bodyBytes, err := io.ReadAll(rsp.Body)
        defer func() </span><span class="cov0" title="0">{ _ = rsp.Body.Close() }</span>()
        <span class="cov0" title="0">if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">response := &amp;GetInvoiceAttachmentResponse{
                Body:         bodyBytes,
                HTTPResponse: rsp,
        }

        switch </span>{
        case strings.Contains(rsp.Header.Get("Content-Type"), "json") &amp;&amp; rsp.StatusCode == 200:<span class="cov0" title="0">
                var dest InvoiceAttachment
                if err := json.Unmarshal(bodyBytes, &amp;dest); err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>
                <span class="cov0" title="0">response.JSON200 = &amp;dest</span>

        case strings.Contains(rsp.Header.Get("Content-Type"), "json") &amp;&amp; rsp.StatusCode == 404:<span class="cov0" title="0">
                var dest ApiError
                if err := json.Unmarshal(bodyBytes, &amp;dest); err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>
                <span class="cov0" title="0">response.JSON404 = &amp;dest</span>

        }

        <span class="cov0" title="0">return response, nil</span>
}

// ParseDownloadInvoiceAttachmentResponse parses an HTTP response from a DownloadInvoiceAttachmentWithResponse call
func ParseDownloadInvoiceAttachmentResponse(rsp *http.Response) (*DownloadInvoiceAttachmentResponse, error) <span class="cov0" title="0">{
        bodyBytes, err := io.ReadAll(rsp.Body)
        defer func() </span><span class="cov0" title="0">{ _ = rsp.Body.Close() }</span>()
        <span class="cov0" title="0">if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">response := &amp;DownloadInvoiceAttachmentResponse{
                Body:         bodyBytes,
                HTTPResponse: rsp,
        }

        switch </span>{
        case strings.Contains(rsp.Header.Get("Content-Type"), "json") &amp;&amp; rsp.StatusCode == 404:<span class="cov0" title="0">
                var dest ApiError
                if err := json.Unmarshal(bodyBytes, &amp;dest); err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>
                <span class="cov0" title="0">response.JSON404 = &amp;dest</span>

        }

        <span class="cov0" title="0">return response, nil</span>
}

// ParsePostInvoiceLineItemResponse parses an HTTP response from a PostInvoiceLineItemWithResponse call
func ParsePostInvoiceLineItemResponse(rsp *http.Response) (*PostInvoiceLineItemResponse, error) <span class="cov0" title="0">{
        bodyBytes, err := io.ReadAll(rsp.Body)
        defer func() </span><span class="cov0" title="0">{ _ = rsp.Body.Close() }</span>()
        <span class="cov0" title="0">if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">response := &amp;PostInvoiceLineItemResponse{
                Body:         bodyBytes,
                HTTPResponse: rsp,
        }

        switch </span>{
        case strings.Contains(rsp.Header.Get("Content-Type"), "json") &amp;&amp; rsp.StatusCode == 200:<span class="cov0" title="0">
                var dest struct {
                        union json.RawMessage
                }
                if err := json.Unmarshal(bodyBytes, &amp;dest); err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>
                <span class="cov0" title="0">response.JSON200 = &amp;dest</span>

        case strings.Contains(rsp.Header.Get("Content-Type"), "json") &amp;&amp; rsp.StatusCode == 400:<span class="cov0" title="0">
                var dest ApiError
                if err := json.Unmarshal(bodyBytes, &amp;dest); err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>
                <span class="cov0" title="0">response.JSON400 = &amp;dest</span>

        case strings.Contains(rsp.Header.Get("Content-Type"), "json") &amp;&amp; rsp.StatusCode == 404:<span class="cov0" title="0">
                var dest ApiError
                if err := json.Unmarshal(bodyBytes, &amp;dest); err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>
                <span class="cov0" title="0">response.JSON404 = &amp;dest</span>

        }

        <span class="cov0" title="0">return response, nil</span>
}

// ParseGetItemsResponse parses an HTTP response from a GetItemsWithResponse call
func ParseGetItemsResponse(rsp *http.Response) (*GetItemsResponse, error) <span class="cov0" title="0">{
        bodyBytes, err := io.ReadAll(rsp.Body)
        defer func() </span><span class="cov0" title="0">{ _ = rsp.Body.Close() }</span>()
        <span class="cov0" title="0">if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">response := &amp;GetItemsResponse{
                Body:         bodyBytes,
                HTTPResponse: rsp,
        }

        switch </span>{
        case strings.Contains(rsp.Header.Get("Content-Type"), "json") &amp;&amp; rsp.StatusCode == 200:<span class="cov0" title="0">
                var dest struct {
                        CurrentPage *int32         `json:"currentPage,omitempty"`
                        Items       *[]interface{} `json:"items,omitempty"`
                        TotalItems  *int32         `json:"totalItems,omitempty"`
                        TotalPages  *int32         `json:"totalPages,omitempty"`
                }
                if err := json.Unmarshal(bodyBytes, &amp;dest); err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>
                <span class="cov0" title="0">response.JSON200 = &amp;dest</span>

        }

        <span class="cov0" title="0">return response, nil</span>
}

// ParsePostItemResponse parses an HTTP response from a PostItemWithResponse call
func ParsePostItemResponse(rsp *http.Response) (*PostItemResponse, error) <span class="cov0" title="0">{
        bodyBytes, err := io.ReadAll(rsp.Body)
        defer func() </span><span class="cov0" title="0">{ _ = rsp.Body.Close() }</span>()
        <span class="cov0" title="0">if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">response := &amp;PostItemResponse{
                Body:         bodyBytes,
                HTTPResponse: rsp,
        }

        switch </span>{
        case strings.Contains(rsp.Header.Get("Content-Type"), "json") &amp;&amp; rsp.StatusCode == 200:<span class="cov0" title="0">
                var dest struct {
                        union json.RawMessage
                }
                if err := json.Unmarshal(bodyBytes, &amp;dest); err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>
                <span class="cov0" title="0">response.JSON200 = &amp;dest</span>

        case strings.Contains(rsp.Header.Get("Content-Type"), "json") &amp;&amp; rsp.StatusCode == 400:<span class="cov0" title="0">
                var dest ApiError
                if err := json.Unmarshal(bodyBytes, &amp;dest); err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>
                <span class="cov0" title="0">response.JSON400 = &amp;dest</span>

        }

        <span class="cov0" title="0">return response, nil</span>
}

// ParseDeleteItemResponse parses an HTTP response from a DeleteItemWithResponse call
func ParseDeleteItemResponse(rsp *http.Response) (*DeleteItemResponse, error) <span class="cov0" title="0">{
        bodyBytes, err := io.ReadAll(rsp.Body)
        defer func() </span><span class="cov0" title="0">{ _ = rsp.Body.Close() }</span>()
        <span class="cov0" title="0">if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">response := &amp;DeleteItemResponse{
                Body:         bodyBytes,
                HTTPResponse: rsp,
        }

        return response, nil</span>
}

// ParseGetItemsItemIdResponse parses an HTTP response from a GetItemsItemIdWithResponse call
func ParseGetItemsItemIdResponse(rsp *http.Response) (*GetItemsItemIdResponse, error) <span class="cov0" title="0">{
        bodyBytes, err := io.ReadAll(rsp.Body)
        defer func() </span><span class="cov0" title="0">{ _ = rsp.Body.Close() }</span>()
        <span class="cov0" title="0">if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">response := &amp;GetItemsItemIdResponse{
                Body:         bodyBytes,
                HTTPResponse: rsp,
        }

        switch </span>{
        case strings.Contains(rsp.Header.Get("Content-Type"), "json") &amp;&amp; rsp.StatusCode == 200:<span class="cov0" title="0">
                var dest struct {
                        union json.RawMessage
                }
                if err := json.Unmarshal(bodyBytes, &amp;dest); err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>
                <span class="cov0" title="0">response.JSON200 = &amp;dest</span>

        case strings.Contains(rsp.Header.Get("Content-Type"), "json") &amp;&amp; rsp.StatusCode == 404:<span class="cov0" title="0">
                var dest ApiError
                if err := json.Unmarshal(bodyBytes, &amp;dest); err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>
                <span class="cov0" title="0">response.JSON404 = &amp;dest</span>

        }

        <span class="cov0" title="0">return response, nil</span>
}

// ParsePutItemResponse parses an HTTP response from a PutItemWithResponse call
func ParsePutItemResponse(rsp *http.Response) (*PutItemResponse, error) <span class="cov0" title="0">{
        bodyBytes, err := io.ReadAll(rsp.Body)
        defer func() </span><span class="cov0" title="0">{ _ = rsp.Body.Close() }</span>()
        <span class="cov0" title="0">if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">response := &amp;PutItemResponse{
                Body:         bodyBytes,
                HTTPResponse: rsp,
        }

        switch </span>{
        case strings.Contains(rsp.Header.Get("Content-Type"), "json") &amp;&amp; rsp.StatusCode == 200:<span class="cov0" title="0">
                var dest struct {
                        union json.RawMessage
                }
                if err := json.Unmarshal(bodyBytes, &amp;dest); err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>
                <span class="cov0" title="0">response.JSON200 = &amp;dest</span>

        case strings.Contains(rsp.Header.Get("Content-Type"), "json") &amp;&amp; rsp.StatusCode == 400:<span class="cov0" title="0">
                var dest ApiError
                if err := json.Unmarshal(bodyBytes, &amp;dest); err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>
                <span class="cov0" title="0">response.JSON400 = &amp;dest</span>

        }

        <span class="cov0" title="0">return response, nil</span>
}

// ParseGetJournalentryResponse parses an HTTP response from a GetJournalentryWithResponse call
func ParseGetJournalentryResponse(rsp *http.Response) (*GetJournalentryResponse, error) <span class="cov0" title="0">{
        bodyBytes, err := io.ReadAll(rsp.Body)
        defer func() </span><span class="cov0" title="0">{ _ = rsp.Body.Close() }</span>()
        <span class="cov0" title="0">if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">response := &amp;GetJournalentryResponse{
                Body:         bodyBytes,
                HTTPResponse: rsp,
        }

        switch </span>{
        case strings.Contains(rsp.Header.Get("Content-Type"), "json") &amp;&amp; rsp.StatusCode == 200:<span class="cov0" title="0">
                var dest struct {
                        CurrentPage *int32          `json:"currentPage,omitempty"`
                        Items       *[]JournalEntry `json:"items,omitempty"`
                        TotalItems  *int32          `json:"totalItems,omitempty"`
                        TotalPages  *int32          `json:"totalPages,omitempty"`
                }
                if err := json.Unmarshal(bodyBytes, &amp;dest); err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>
                <span class="cov0" title="0">response.JSON200 = &amp;dest</span>

        }

        <span class="cov0" title="0">return response, nil</span>
}

// ParsePostJournalentryResponse parses an HTTP response from a PostJournalentryWithResponse call
func ParsePostJournalentryResponse(rsp *http.Response) (*PostJournalentryResponse, error) <span class="cov0" title="0">{
        bodyBytes, err := io.ReadAll(rsp.Body)
        defer func() </span><span class="cov0" title="0">{ _ = rsp.Body.Close() }</span>()
        <span class="cov0" title="0">if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">response := &amp;PostJournalentryResponse{
                Body:         bodyBytes,
                HTTPResponse: rsp,
        }

        switch </span>{
        case strings.Contains(rsp.Header.Get("Content-Type"), "json") &amp;&amp; rsp.StatusCode == 200:<span class="cov0" title="0">
                var dest JournalEntry
                if err := json.Unmarshal(bodyBytes, &amp;dest); err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>
                <span class="cov0" title="0">response.JSON200 = &amp;dest</span>

        case strings.Contains(rsp.Header.Get("Content-Type"), "json") &amp;&amp; rsp.StatusCode == 400:<span class="cov0" title="0">
                var dest ApiError
                if err := json.Unmarshal(bodyBytes, &amp;dest); err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>
                <span class="cov0" title="0">response.JSON400 = &amp;dest</span>

        }

        <span class="cov0" title="0">return response, nil</span>
}

// ParseGetJournalentriesJournalIdResponse parses an HTTP response from a GetJournalentriesJournalIdWithResponse call
func ParseGetJournalentriesJournalIdResponse(rsp *http.Response) (*GetJournalentriesJournalIdResponse, error) <span class="cov0" title="0">{
        bodyBytes, err := io.ReadAll(rsp.Body)
        defer func() </span><span class="cov0" title="0">{ _ = rsp.Body.Close() }</span>()
        <span class="cov0" title="0">if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">response := &amp;GetJournalentriesJournalIdResponse{
                Body:         bodyBytes,
                HTTPResponse: rsp,
        }

        switch </span>{
        case strings.Contains(rsp.Header.Get("Content-Type"), "json") &amp;&amp; rsp.StatusCode == 200:<span class="cov0" title="0">
                var dest JournalEntry
                if err := json.Unmarshal(bodyBytes, &amp;dest); err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>
                <span class="cov0" title="0">response.JSON200 = &amp;dest</span>

        case strings.Contains(rsp.Header.Get("Content-Type"), "json") &amp;&amp; rsp.StatusCode == 404:<span class="cov0" title="0">
                var dest ApiError
                if err := json.Unmarshal(bodyBytes, &amp;dest); err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>
                <span class="cov0" title="0">response.JSON404 = &amp;dest</span>

        }

        <span class="cov0" title="0">return response, nil</span>
}

// ParseReverseJournalentryResponse parses an HTTP response from a ReverseJournalentryWithResponse call
func ParseReverseJournalentryResponse(rsp *http.Response) (*ReverseJournalentryResponse, error) <span class="cov0" title="0">{
        bodyBytes, err := io.ReadAll(rsp.Body)
        defer func() </span><span class="cov0" title="0">{ _ = rsp.Body.Close() }</span>()
        <span class="cov0" title="0">if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">response := &amp;ReverseJournalentryResponse{
                Body:         bodyBytes,
                HTTPResponse: rsp,
        }

        switch </span>{
        case strings.Contains(rsp.Header.Get("Content-Type"), "json") &amp;&amp; rsp.StatusCode == 200:<span class="cov0" title="0">
                var dest JournalEntry
                if err := json.Unmarshal(bodyBytes, &amp;dest); err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>
                <span class="cov0" title="0">response.JSON200 = &amp;dest</span>

        case strings.Contains(rsp.Header.Get("Content-Type"), "json") &amp;&amp; rsp.StatusCode == 400:<span class="cov0" title="0">
                var dest ApiError
                if err := json.Unmarshal(bodyBytes, &amp;dest); err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>
                <span class="cov0" title="0">response.JSON400 = &amp;dest</span>

        case strings.Contains(rsp.Header.Get("Content-Type"), "json") &amp;&amp; rsp.StatusCode == 404:<span class="cov0" title="0">
                var dest ApiError
                if err := json.Unmarshal(bodyBytes, &amp;dest); err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>
                <span class="cov0" title="0">response.JSON404 = &amp;dest</span>

        }

        <span class="cov0" title="0">return response, nil</span>
}

// ParseDownloadSieFileResponse parses an HTTP response from a DownloadSieFileWithResponse call
func ParseDownloadSieFileResponse(rsp *http.Response) (*DownloadSieFileResponse, error) <span class="cov0" title="0">{
        bodyBytes, err := io.ReadAll(rsp.Body)
        defer func() </span><span class="cov0" title="0">{ _ = rsp.Body.Close() }</span>()
        <span class="cov0" title="0">if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">response := &amp;DownloadSieFileResponse{
                Body:         bodyBytes,
                HTTPResponse: rsp,
        }

        switch </span>{
        case strings.Contains(rsp.Header.Get("Content-Type"), "json") &amp;&amp; rsp.StatusCode == 404:<span class="cov0" title="0">
                var dest ApiError
                if err := json.Unmarshal(bodyBytes, &amp;dest); err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>
                <span class="cov0" title="0">response.JSON404 = &amp;dest</span>

        }

        <span class="cov0" title="0">return response, nil</span>
}

// ParseGetUploadsResponse parses an HTTP response from a GetUploadsWithResponse call
func ParseGetUploadsResponse(rsp *http.Response) (*GetUploadsResponse, error) <span class="cov0" title="0">{
        bodyBytes, err := io.ReadAll(rsp.Body)
        defer func() </span><span class="cov0" title="0">{ _ = rsp.Body.Close() }</span>()
        <span class="cov0" title="0">if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">response := &amp;GetUploadsResponse{
                Body:         bodyBytes,
                HTTPResponse: rsp,
        }

        switch </span>{
        case strings.Contains(rsp.Header.Get("Content-Type"), "json") &amp;&amp; rsp.StatusCode == 200:<span class="cov0" title="0">
                var dest struct {
                        CurrentPage *int32    `json:"currentPage,omitempty"`
                        Items       *[]Upload `json:"items,omitempty"`
                        TotalItems  *int32    `json:"totalItems,omitempty"`
                        TotalPages  *int32    `json:"totalPages,omitempty"`
                }
                if err := json.Unmarshal(bodyBytes, &amp;dest); err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>
                <span class="cov0" title="0">response.JSON200 = &amp;dest</span>

        }

        <span class="cov0" title="0">return response, nil</span>
}

// ParseAddUploadResponse parses an HTTP response from a AddUploadWithResponse call
func ParseAddUploadResponse(rsp *http.Response) (*AddUploadResponse, error) <span class="cov0" title="0">{
        bodyBytes, err := io.ReadAll(rsp.Body)
        defer func() </span><span class="cov0" title="0">{ _ = rsp.Body.Close() }</span>()
        <span class="cov0" title="0">if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">response := &amp;AddUploadResponse{
                Body:         bodyBytes,
                HTTPResponse: rsp,
        }

        switch </span>{
        case strings.Contains(rsp.Header.Get("Content-Type"), "json") &amp;&amp; rsp.StatusCode == 200:<span class="cov0" title="0">
                var dest Upload
                if err := json.Unmarshal(bodyBytes, &amp;dest); err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>
                <span class="cov0" title="0">response.JSON200 = &amp;dest</span>

        case strings.Contains(rsp.Header.Get("Content-Type"), "json") &amp;&amp; rsp.StatusCode == 400:<span class="cov0" title="0">
                var dest ApiError
                if err := json.Unmarshal(bodyBytes, &amp;dest); err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>
                <span class="cov0" title="0">response.JSON400 = &amp;dest</span>

        }

        <span class="cov0" title="0">return response, nil</span>
}

// ParseGetUploadResponse parses an HTTP response from a GetUploadWithResponse call
func ParseGetUploadResponse(rsp *http.Response) (*GetUploadResponse, error) <span class="cov0" title="0">{
        bodyBytes, err := io.ReadAll(rsp.Body)
        defer func() </span><span class="cov0" title="0">{ _ = rsp.Body.Close() }</span>()
        <span class="cov0" title="0">if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">response := &amp;GetUploadResponse{
                Body:         bodyBytes,
                HTTPResponse: rsp,
        }

        switch </span>{
        case strings.Contains(rsp.Header.Get("Content-Type"), "json") &amp;&amp; rsp.StatusCode == 200:<span class="cov0" title="0">
                var dest Upload
                if err := json.Unmarshal(bodyBytes, &amp;dest); err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>
                <span class="cov0" title="0">response.JSON200 = &amp;dest</span>

        case strings.Contains(rsp.Header.Get("Content-Type"), "json") &amp;&amp; rsp.StatusCode == 404:<span class="cov0" title="0">
                var dest ApiError
                if err := json.Unmarshal(bodyBytes, &amp;dest); err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>
                <span class="cov0" title="0">response.JSON404 = &amp;dest</span>

        }

        <span class="cov0" title="0">return response, nil</span>
}

// ParseDownloadUploadResponse parses an HTTP response from a DownloadUploadWithResponse call
func ParseDownloadUploadResponse(rsp *http.Response) (*DownloadUploadResponse, error) <span class="cov0" title="0">{
        bodyBytes, err := io.ReadAll(rsp.Body)
        defer func() </span><span class="cov0" title="0">{ _ = rsp.Body.Close() }</span>()
        <span class="cov0" title="0">if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">response := &amp;DownloadUploadResponse{
                Body:         bodyBytes,
                HTTPResponse: rsp,
        }

        switch </span>{
        case strings.Contains(rsp.Header.Get("Content-Type"), "json") &amp;&amp; rsp.StatusCode == 404:<span class="cov0" title="0">
                var dest ApiError
                if err := json.Unmarshal(bodyBytes, &amp;dest); err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>
                <span class="cov0" title="0">response.JSON404 = &amp;dest</span>

        }

        <span class="cov0" title="0">return response, nil</span>
}
</pre>
		
		<pre class="file" id="file3" style="display: none">//go:build !ignore

// Package company provides primitives to interact with the openapi HTTP API.
//
// Code generated by github.com/deepmap/oapi-codegen version v1.16.3 DO NOT EDIT.
//
package company

import (
        "encoding/json"

        "github.com/oapi-codegen/runtime"
        openapi_types "github.com/oapi-codegen/runtime/types"
)

const (
        TokenAuthScopes = "tokenAuth.Scopes"
)

// Defines values for CustomerLanguage.
const (
        En CustomerLanguage = "en"
        Sv CustomerLanguage = "sv"
)

// Defines values for CustomerType.
const (
        Company CustomerType = "company"
        Private CustomerType = "private"
)

// Defines values for DescriptionOnlyInvoiceItemItemType.
const (
        DescriptionOnlyInvoiceItemItemTypeDescriptionOnlyItem DescriptionOnlyInvoiceItemItemType = "descriptionOnlyItem"
)

// Defines values for DescriptionOnlyItemItemType.
const (
        DescriptionOnlyItemItemTypeDescriptionOnlyItem DescriptionOnlyItemItemType = "descriptionOnlyItem"
)

// Defines values for FiscalYearAccountingMethod.
const (
        Accrual FiscalYearAccountingMethod = "accrual"
        Cash    FiscalYearAccountingMethod = "cash"
)

// Defines values for FiscalYearStatus.
const (
        Closed FiscalYearStatus = "closed"
        Open   FiscalYearStatus = "open"
)

// Defines values for FiscalYearVatSetting.
const (
        Monthly   FiscalYearVatSetting = "monthly"
        Quarterly FiscalYearVatSetting = "quarterly"
        Yearly    FiscalYearVatSetting = "yearly"
)

// Defines values for InvoiceStatus.
const (
        Credit    InvoiceStatus = "credit"
        Credited  InvoiceStatus = "credited"
        Draft     InvoiceStatus = "draft"
        Overdue   InvoiceStatus = "overdue"
        Overpaid  InvoiceStatus = "overpaid"
        Paid      InvoiceStatus = "paid"
        Published InvoiceStatus = "published"
        Underpaid InvoiceStatus = "underpaid"
)

// Defines values for InvoiceType.
const (
        InvoiceTypeCashInvoice InvoiceType = "cashInvoice"
        InvoiceTypeInvoice     InvoiceType = "invoice"
)

// Defines values for SalesInvoiceItemItemType.
const (
        SalesInvoiceItemItemTypeSalesItem SalesInvoiceItemItemType = "salesItem"
)

// Defines values for SalesInvoiceItemProductType.
const (
        SalesInvoiceItemProductTypeGoods    SalesInvoiceItemProductType = "goods"
        SalesInvoiceItemProductTypeServices SalesInvoiceItemProductType = "services"
)

// Defines values for SalesInvoiceItemUnitType.
const (
        SalesInvoiceItemUnitTypeCentimeter   SalesInvoiceItemUnitType = "centimeter"
        SalesInvoiceItemUnitTypeDay          SalesInvoiceItemUnitType = "day"
        SalesInvoiceItemUnitTypeGigabyte     SalesInvoiceItemUnitType = "gigabyte"
        SalesInvoiceItemUnitTypeGram         SalesInvoiceItemUnitType = "gram"
        SalesInvoiceItemUnitTypeHectar       SalesInvoiceItemUnitType = "hectar"
        SalesInvoiceItemUnitTypeHour         SalesInvoiceItemUnitType = "hour"
        SalesInvoiceItemUnitTypeKilogram     SalesInvoiceItemUnitType = "kilogram"
        SalesInvoiceItemUnitTypeKilometer    SalesInvoiceItemUnitType = "kilometer"
        SalesInvoiceItemUnitTypeLiter        SalesInvoiceItemUnitType = "liter"
        SalesInvoiceItemUnitTypeMegabyte     SalesInvoiceItemUnitType = "megabyte"
        SalesInvoiceItemUnitTypeMeter        SalesInvoiceItemUnitType = "meter"
        SalesInvoiceItemUnitTypeMeterCubic   SalesInvoiceItemUnitType = "meterCubic"
        SalesInvoiceItemUnitTypeMeterSquared SalesInvoiceItemUnitType = "meterSquared"
        SalesInvoiceItemUnitTypeMile         SalesInvoiceItemUnitType = "mile"
        SalesInvoiceItemUnitTypeMillimeter   SalesInvoiceItemUnitType = "millimeter"
        SalesInvoiceItemUnitTypeMinute       SalesInvoiceItemUnitType = "minute"
        SalesInvoiceItemUnitTypeMonth        SalesInvoiceItemUnitType = "month"
        SalesInvoiceItemUnitTypePiece        SalesInvoiceItemUnitType = "piece"
        SalesInvoiceItemUnitTypeTon          SalesInvoiceItemUnitType = "ton"
        SalesInvoiceItemUnitTypeUnspecified  SalesInvoiceItemUnitType = "unspecified"
        SalesInvoiceItemUnitTypeWeek         SalesInvoiceItemUnitType = "week"
        SalesInvoiceItemUnitTypeWords        SalesInvoiceItemUnitType = "words"
        SalesInvoiceItemUnitTypeYear         SalesInvoiceItemUnitType = "year"
)

// Defines values for SalesItemItemType.
const (
        SalesItemItemTypeSalesItem SalesItemItemType = "salesItem"
)

// Defines values for SalesItemProductType.
const (
        SalesItemProductTypeGoods    SalesItemProductType = "goods"
        SalesItemProductTypeServices SalesItemProductType = "services"
)

// Defines values for SalesItemUnitType.
const (
        SalesItemUnitTypeCentimeter   SalesItemUnitType = "centimeter"
        SalesItemUnitTypeDay          SalesItemUnitType = "day"
        SalesItemUnitTypeGigabyte     SalesItemUnitType = "gigabyte"
        SalesItemUnitTypeGram         SalesItemUnitType = "gram"
        SalesItemUnitTypeHectar       SalesItemUnitType = "hectar"
        SalesItemUnitTypeHour         SalesItemUnitType = "hour"
        SalesItemUnitTypeKilogram     SalesItemUnitType = "kilogram"
        SalesItemUnitTypeKilometer    SalesItemUnitType = "kilometer"
        SalesItemUnitTypeLiter        SalesItemUnitType = "liter"
        SalesItemUnitTypeMegabyte     SalesItemUnitType = "megabyte"
        SalesItemUnitTypeMeter        SalesItemUnitType = "meter"
        SalesItemUnitTypeMeterCubic   SalesItemUnitType = "meterCubic"
        SalesItemUnitTypeMeterSquared SalesItemUnitType = "meterSquared"
        SalesItemUnitTypeMile         SalesItemUnitType = "mile"
        SalesItemUnitTypeMillimeter   SalesItemUnitType = "millimeter"
        SalesItemUnitTypeMinute       SalesItemUnitType = "minute"
        SalesItemUnitTypeMonth        SalesItemUnitType = "month"
        SalesItemUnitTypePiece        SalesItemUnitType = "piece"
        SalesItemUnitTypeTon          SalesItemUnitType = "ton"
        SalesItemUnitTypeUnspecified  SalesItemUnitType = "unspecified"
        SalesItemUnitTypeWeek         SalesItemUnitType = "week"
        SalesItemUnitTypeWords        SalesItemUnitType = "words"
        SalesItemUnitTypeYear         SalesItemUnitType = "year"
)

// Address defines model for address.
type Address struct {
        City string `json:"city"`

        // Country ISO 3166-1 alpha-2 country code
        Country    string  `json:"country"`
        Line1      string  `json:"line1"`
        Line2      *string `json:"line2"`
        PostalCode string  `json:"postalCode"`
}

// ApiError defines model for apiError.
type ApiError struct {
        BokioErrorId *openapi_types.UUID `json:"bokioErrorId,omitempty"`
        Code         *string             `json:"code,omitempty"`
        Errors       *[]struct {
                Field   *string `json:"field,omitempty"`
                Message *string `json:"message,omitempty"`
        } `json:"errors,omitempty"`
        Message *string `json:"message,omitempty"`
}

// Customer defines model for customer.
type Customer struct {
        Address         *Address `json:"address,omitempty"`
        ContactsDetails *[]struct {
                Email *string `json:"email,omitempty"`

                // Id Should not be set for new items
                Id        *openapi_types.UUID `json:"id"`
                IsDefault *bool               `json:"isDefault,omitempty"`
                Name      *string             `json:"name,omitempty"`
                Phone     *string             `json:"phone,omitempty"`
        } `json:"contactsDetails,omitempty"`
        Id *openapi_types.UUID `json:"id,omitempty"`

        // Language Default 'sv'
        Language  *CustomerLanguage `json:"language,omitempty"`
        Name      string            `json:"name"`
        OrgNumber *string           `json:"orgNumber,omitempty"`

        // PaymentTerms Payment terms for the invoices. Payment terms can both take free text or days, in digits, until the payment is due.
        //
        // On the invoice, if a digit is provided it will be suffixed with "days". For example, "30" will be displayed as "30 days" on the invoice. Note that the suffix will, similar to the rest of the invoice, use the language on the customer.
        PaymentTerms *string      `json:"paymentTerms,omitempty"`
        Type         CustomerType `json:"type"`
        VatNumber    *string      `json:"vatNumber,omitempty"`
}

// CustomerLanguage Default 'sv'
type CustomerLanguage string

// CustomerType defines model for Customer.Type.
type CustomerType string

// DescriptionOnlyInvoiceItem defines model for descriptionOnlyInvoiceItem.
type DescriptionOnlyInvoiceItem struct {
        Description string `json:"description"`

        // Id Should not be set for new items
        Id *int64 `json:"id"`

        // ItemRef Identifier of an existing descriptionOnlyItem to use as a template. The field itemType is required.
        ItemRef *struct {
                Description *string `json:"description"`

                // Id Reference to existing descriptionOnlyItem id
                Id *openapi_types.UUID `json:"id,omitempty"`
        } `json:"itemRef"`
        ItemType DescriptionOnlyInvoiceItemItemType `json:"itemType"`
}

// DescriptionOnlyInvoiceItemItemType defines model for DescriptionOnlyInvoiceItem.ItemType.
type DescriptionOnlyInvoiceItemItemType string

// DescriptionOnlyItem defines model for descriptionOnlyItem.
type DescriptionOnlyItem struct {
        Description string `json:"description"`

        // Id Should not be set for new items
        Id       *openapi_types.UUID         `json:"id"`
        ItemType DescriptionOnlyItemItemType `json:"itemType"`
}

// DescriptionOnlyItemItemType defines model for DescriptionOnlyItem.ItemType.
type DescriptionOnlyItemItemType string

// FiscalYear defines model for fiscalYear.
type FiscalYear struct {
        // AccountingMethod The accounting method used by the fiscal year
        AccountingMethod FiscalYearAccountingMethod `json:"accountingMethod"`

        // EndDate The end date of the fiscal year
        EndDate openapi_types.Date `json:"endDate"`

        // Id Unique identifier for the fiscal year
        Id openapi_types.UUID `json:"id"`

        // StartDate The start date of the fiscal year
        StartDate openapi_types.Date `json:"startDate"`

        // Status The status of the fiscal year
        Status *FiscalYearStatus `json:"status,omitempty"`

        // VatSetting The VAT setting for the fiscal year
        VatSetting FiscalYearVatSetting `json:"vatSetting"`
}

// FiscalYearAccountingMethod The accounting method used by the fiscal year
type FiscalYearAccountingMethod string

// FiscalYearStatus The status of the fiscal year
type FiscalYearStatus string

// FiscalYearVatSetting The VAT setting for the fiscal year
type FiscalYearVatSetting string

// Invoice defines model for invoice.
type Invoice struct {
        AttachmentRefs *[]struct {
                Id   *openapi_types.UUID `json:"id,omitempty"`
                Name *string             `json:"name,omitempty"`
        } `json:"attachmentRefs,omitempty"`
        BillingAddress *Invoice_BillingAddress `json:"billingAddress,omitempty"`

        // Currency ISO 4217 currency code
        Currency     *string  `json:"currency,omitempty"`
        CurrencyRate *float64 `json:"currencyRate,omitempty"`
        CustomerRef  *struct {
                Id   *openapi_types.UUID `json:"id,omitempty"`
                Name *string             `json:"name,omitempty"`
        } `json:"customerRef,omitempty"`
        DeliveryAddress *Invoice_DeliveryAddress `json:"deliveryAddress,omitempty"`
        DueDate         openapi_types.Date       `json:"dueDate"`
        Id              *openapi_types.UUID      `json:"id,omitempty"`
        InvoiceDate     openapi_types.Date       `json:"invoiceDate"`

        // InvoiceNumber The invoice number will be generated at the time of publishing the invoice.
        InvoiceNumber *string                  `json:"invoiceNumber"`
        LineItems     []Invoice_LineItems_Item `json:"lineItems"`

        // Metadata Metadata fields for the invoice as string key-value pairs. These fields can be used for filtering.All metadata keys must
        // start with a letter or underscore and contain only alphanumeric characters and underscores.
        Metadata *map[string]string `json:"metadata,omitempty"`

        // OrderNumberReference The order number associated with the invoice.
        OrderNumberReference *string        `json:"orderNumberReference,omitempty"`
        PaidAmount           *float64       `json:"paidAmount,omitempty"`
        Status               *InvoiceStatus `json:"status,omitempty"`
        TotalAmount          *float64       `json:"totalAmount,omitempty"`
        TotalTax             *float64       `json:"totalTax,omitempty"`

        // Type The type of the invoice can be invoice or cashInvoice. Can only be set to invoice when creating a new invoice and will default to invoice if not set.
        Type *InvoiceType `json:"type,omitempty"`
}

// Invoice_BillingAddress defines model for Invoice.BillingAddress.
type Invoice_BillingAddress struct {
        union json.RawMessage
}

// Invoice_DeliveryAddress defines model for Invoice.DeliveryAddress.
type Invoice_DeliveryAddress struct {
        union json.RawMessage
}

// Invoice_LineItems_Item defines model for invoice.lineItems.Item.
type Invoice_LineItems_Item struct {
        union json.RawMessage
}

// InvoiceStatus defines model for Invoice.Status.
type InvoiceStatus string

// InvoiceType The type of the invoice can be invoice or cashInvoice. Can only be set to invoice when creating a new invoice and will default to invoice if not set.
type InvoiceType string

// InvoiceAttachment defines model for invoiceAttachment.
type InvoiceAttachment struct {
        FileName  *string             `json:"fileName,omitempty"`
        Id        *openapi_types.UUID `json:"id,omitempty"`
        InvoiceId *openapi_types.UUID `json:"invoiceId,omitempty"`
}

// InvoiceItem defines model for invoiceItem.
type InvoiceItem struct {
        union json.RawMessage
}

// Item defines model for item.
type Item struct {
        union json.RawMessage
}

// JournalEntry defines model for journalEntry.
type JournalEntry struct {
        Date                     *openapi_types.Date `json:"date,omitempty"`
        Id                       *openapi_types.UUID `json:"id,omitempty"`
        Items                    *[]JournalEntryItem `json:"items,omitempty"`
        JournalEntryNumber       *string             `json:"journalEntryNumber,omitempty"`
        ReversedByJournalEntryId *openapi_types.UUID `json:"reversedByJournalEntryId"`
        ReversingJournalEntryId  *openapi_types.UUID `json:"reversingJournalEntryId"`
        Title                    *string             `json:"title,omitempty"`
}

// JournalEntryItem defines model for journalEntryItem.
type JournalEntryItem struct {
        Account *int32   `json:"account,omitempty"`
        Credit  *float64 `json:"credit,omitempty"`
        Debit   *float64 `json:"debit,omitempty"`
        Id      *int64   `json:"id,omitempty"`
}

// PagedResponse defines model for pagedResponse.
type PagedResponse struct {
        CurrentPage *int32 `json:"currentPage,omitempty"`
        TotalItems  *int32 `json:"totalItems,omitempty"`
        TotalPages  *int32 `json:"totalPages,omitempty"`
}

// SalesInvoiceItem defines model for salesInvoiceItem.
type SalesInvoiceItem struct {
        Description string `json:"description"`

        // Id Should not be set for new items
        Id *int64 `json:"id"`

        // ItemRef Identifier of an existing salesItem to use as a template. Fields itemType and quantity are required. Values in other fields will be overridden by values from this referenced item
        ItemRef *struct {
                Description *string `json:"description"`

                // Id Reference to existing salesItem id
                Id *openapi_types.UUID `json:"id,omitempty"`
        } `json:"itemRef"`
        ItemType    SalesInvoiceItemItemType    `json:"itemType"`
        ProductType SalesInvoiceItemProductType `json:"productType"`
        Quantity    float64                     `json:"quantity"`
        TaxRate     float64                     `json:"taxRate"`
        UnitPrice   float64                     `json:"unitPrice"`
        UnitType    *SalesInvoiceItemUnitType   `json:"unitType,omitempty"`
}

// SalesInvoiceItemItemType defines model for SalesInvoiceItem.ItemType.
type SalesInvoiceItemItemType string

// SalesInvoiceItemProductType defines model for SalesInvoiceItem.ProductType.
type SalesInvoiceItemProductType string

// SalesInvoiceItemUnitType defines model for SalesInvoiceItem.UnitType.
type SalesInvoiceItemUnitType string

// SalesItem defines model for salesItem.
type SalesItem struct {
        Description string `json:"description"`

        // Id Should not be set for new items
        Id          *openapi_types.UUID  `json:"id"`
        ItemType    SalesItemItemType    `json:"itemType"`
        ProductType SalesItemProductType `json:"productType"`
        TaxRate     float64              `json:"taxRate"`
        UnitPrice   float64              `json:"unitPrice"`
        UnitType    SalesItemUnitType    `json:"unitType"`
}

// SalesItemItemType defines model for SalesItem.ItemType.
type SalesItemItemType string

// SalesItemProductType defines model for SalesItem.ProductType.
type SalesItemProductType string

// SalesItemUnitType defines model for SalesItem.UnitType.
type SalesItemUnitType string

// Upload defines model for upload.
type Upload struct {
        ContentType    *string             `json:"contentType,omitempty"`
        Description    *string             `json:"description,omitempty"`
        Id             *openapi_types.UUID `json:"id,omitempty"`
        JournalEntryId *openapi_types.UUID `json:"journalEntryId"`
}

// GetCustomerParams defines parameters for GetCustomer.
type GetCustomerParams struct {
        // Page Page number
        Page *int32 `form:"page,omitempty" json:"page,omitempty"`

        // PageSize Number of items per page
        PageSize *int32 `form:"pageSize,omitempty" json:"pageSize,omitempty"`

        // Query Optional query to filter the data set with supported fields listed below and [available operations](filtering).
        //
        // | Field                | Type        |
        // | -------------------- | ----------- |
        // | name                 | string      |
        // | type                 | string      |
        // | vatNumber            | string      |
        // | orgNumber            | string      |
        Query *string `form:"query,omitempty" json:"query,omitempty"`
}

// GetFiscalYearsParams defines parameters for GetFiscalYears.
type GetFiscalYearsParams struct {
        // Page Page number
        Page *int32 `form:"page,omitempty" json:"page,omitempty"`

        // PageSize Number of items per page
        PageSize *int32 `form:"pageSize,omitempty" json:"pageSize,omitempty"`

        // Query Optional query to filter the data set with supported fields listed below and [available operations](filtering).
        //
        // | Field                | Type        |
        // | -------------------- | ----------- |
        // | startDate            | date      |
        // | endDate              | date      |
        // | accountingMethod     | string      |
        // | status               | string      |
        Query *string `form:"query,omitempty" json:"query,omitempty"`
}

// GetInvoiceParams defines parameters for GetInvoice.
type GetInvoiceParams struct {
        // Page Page number
        Page *int32 `form:"page,omitempty" json:"page,omitempty"`

        // PageSize Number of items per page
        PageSize *int32 `form:"pageSize,omitempty" json:"pageSize,omitempty"`

        // Query Optional query to filter the data set with supported fields listed below and [available operations](filtering).
        // View documentation for filtering on metatdata [here](metadata).
        //
        // | Field                | Type        |
        // | -------------------- | ----------- |
        // | type                 | string      |
        // | customerRef          | string      |
        // | orderNumberReference | string      |
        // | currency             | string      |
        // | totalAmount          | number      |
        // | status               | string      |
        // | invoiceDate          | date        |
        // | dueDate              | date        |
        // | metadata             | string      |
        Query *string `form:"query,omitempty" json:"query,omitempty"`
}

// GetInvoiceAttachmentsParams defines parameters for GetInvoiceAttachments.
type GetInvoiceAttachmentsParams struct {
        // Page Page number
        Page *int32 `form:"page,omitempty" json:"page,omitempty"`

        // PageSize Number of items per page
        PageSize *int32 `form:"pageSize,omitempty" json:"pageSize,omitempty"`

        // Query Optional query to filter the data set with supported fields listed below and [available operations](filtering).
        //
        // | Field                     | Type        |
        // | ------------------------- | ----------- |
        // | fileName                  | string      |
        Query *string `form:"query,omitempty" json:"query,omitempty"`
}

// PostInvoiceAttachmentMultipartBody defines parameters for PostInvoiceAttachment.
type PostInvoiceAttachmentMultipartBody struct {
        // File The file to attach to invoice
        File openapi_types.File `json:"file"`
}

// PostInvoiceAttachmentParams defines parameters for PostInvoiceAttachment.
type PostInvoiceAttachmentParams struct {
        // ContentType Content type of the request
        ContentType string `json:"Content-Type"`
}

// PostInvoiceLineItemJSONBody defines parameters for PostInvoiceLineItem.
type PostInvoiceLineItemJSONBody struct {
        union json.RawMessage
}

// GetItemsParams defines parameters for GetItems.
type GetItemsParams struct {
        // Page Page number
        Page *int32 `form:"page,omitempty" json:"page,omitempty"`

        // PageSize Number of items per page
        PageSize *int32 `form:"pageSize,omitempty" json:"pageSize,omitempty"`

        // Query Optional query to filter the data set with supported fields listed below and [available operations](filtering).
        //
        // | Field                | Type        |
        // | -------------------- | ----------- |
        // | description          | string      |
        // | itemType             | string      |
        // | productType          | string      |
        // | unitType             | string      |
        // | unitPrice            | number      |
        // | taxRate              | number      |
        Query *string `form:"query,omitempty" json:"query,omitempty"`
}

// PostItemJSONBody defines parameters for PostItem.
type PostItemJSONBody struct {
        union json.RawMessage
}

// PutItemJSONBody defines parameters for PutItem.
type PutItemJSONBody struct {
        union json.RawMessage
}

// GetJournalentryParams defines parameters for GetJournalentry.
type GetJournalentryParams struct {
        // Page Page number
        Page *int32 `form:"page,omitempty" json:"page,omitempty"`

        // PageSize Number of items per page
        PageSize *int32 `form:"pageSize,omitempty" json:"pageSize,omitempty"`

        // Query Optional query to filter the data set with supported fields listed below and [available operations](filtering).
        //
        // | Field                     | Type        |
        // | ------------------------- | ----------- |
        // | title                     | string      |
        // | journalEntryNumber        | string      |
        // | date                      | date        |
        // | reversingJournalEntryId   | string      |
        // | reversedByJournalEntryId  | string      |
        Query *string `form:"query,omitempty" json:"query,omitempty"`
}

// GetUploadsParams defines parameters for GetUploads.
type GetUploadsParams struct {
        // Page Page number
        Page *int32 `form:"page,omitempty" json:"page,omitempty"`

        // PageSize Number of items per page
        PageSize *int32 `form:"pageSize,omitempty" json:"pageSize,omitempty"`

        // Query Optional query to filter the data set with supported fields listed below and [available operations](filtering).
        //
        // | Field                     | Type        |
        // | ------------------------- | ----------- |
        // | description               | string      |
        // | journalEntryId            | string      |
        Query *string `form:"query,omitempty" json:"query,omitempty"`
}

// AddUploadMultipartBody defines parameters for AddUpload.
type AddUploadMultipartBody struct {
        // Description Description of the upload. If left empty, the file name will be used.
        Description *string `json:"description,omitempty"`

        // File The file to upload
        File openapi_types.File `json:"file"`

        // JournalEntryId The journal entry id to attach the upload to
        JournalEntryId *openapi_types.UUID `json:"journalEntryId,omitempty"`
}

// AddUploadParams defines parameters for AddUpload.
type AddUploadParams struct {
        // ContentType Content type of the request
        ContentType string `json:"Content-Type"`
}

// PostCustomerJSONRequestBody defines body for PostCustomer for application/json ContentType.
type PostCustomerJSONRequestBody = Customer

// PutCustomerJSONRequestBody defines body for PutCustomer for application/json ContentType.
type PutCustomerJSONRequestBody = Customer

// PostInvoiceJSONRequestBody defines body for PostInvoice for application/json ContentType.
type PostInvoiceJSONRequestBody = Invoice

// PutInvoiceJSONRequestBody defines body for PutInvoice for application/json ContentType.
type PutInvoiceJSONRequestBody = Invoice

// PostInvoiceAttachmentMultipartRequestBody defines body for PostInvoiceAttachment for multipart/form-data ContentType.
type PostInvoiceAttachmentMultipartRequestBody PostInvoiceAttachmentMultipartBody

// PostInvoiceLineItemJSONRequestBody defines body for PostInvoiceLineItem for application/json ContentType.
type PostInvoiceLineItemJSONRequestBody PostInvoiceLineItemJSONBody

// PostItemJSONRequestBody defines body for PostItem for application/json ContentType.
type PostItemJSONRequestBody PostItemJSONBody

// PutItemJSONRequestBody defines body for PutItem for application/json ContentType.
type PutItemJSONRequestBody PutItemJSONBody

// PostJournalentryJSONRequestBody defines body for PostJournalentry for application/json ContentType.
type PostJournalentryJSONRequestBody = JournalEntry

// AddUploadMultipartRequestBody defines body for AddUpload for multipart/form-data ContentType.
type AddUploadMultipartRequestBody AddUploadMultipartBody

// AsAddress returns the union data inside the Invoice_BillingAddress as a Address
func (t Invoice_BillingAddress) AsAddress() (Address, error) <span class="cov0" title="0">{
        var body Address
        err := json.Unmarshal(t.union, &amp;body)
        return body, err
}</span>

// FromAddress overwrites any union data inside the Invoice_BillingAddress as the provided Address
func (t *Invoice_BillingAddress) FromAddress(v Address) error <span class="cov0" title="0">{
        b, err := json.Marshal(v)
        t.union = b
        return err
}</span>

// MergeAddress performs a merge with any union data inside the Invoice_BillingAddress, using the provided Address
func (t *Invoice_BillingAddress) MergeAddress(v Address) error <span class="cov0" title="0">{
        b, err := json.Marshal(v)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">merged, err := runtime.JsonMerge(t.union, b)
        t.union = merged
        return err</span>
}

func (t Invoice_BillingAddress) MarshalJSON() ([]byte, error) <span class="cov0" title="0">{
        b, err := t.union.MarshalJSON()
        return b, err
}</span>

func (t *Invoice_BillingAddress) UnmarshalJSON(b []byte) error <span class="cov0" title="0">{
        err := t.union.UnmarshalJSON(b)
        return err
}</span>

// AsAddress returns the union data inside the Invoice_DeliveryAddress as a Address
func (t Invoice_DeliveryAddress) AsAddress() (Address, error) <span class="cov0" title="0">{
        var body Address
        err := json.Unmarshal(t.union, &amp;body)
        return body, err
}</span>

// FromAddress overwrites any union data inside the Invoice_DeliveryAddress as the provided Address
func (t *Invoice_DeliveryAddress) FromAddress(v Address) error <span class="cov0" title="0">{
        b, err := json.Marshal(v)
        t.union = b
        return err
}</span>

// MergeAddress performs a merge with any union data inside the Invoice_DeliveryAddress, using the provided Address
func (t *Invoice_DeliveryAddress) MergeAddress(v Address) error <span class="cov0" title="0">{
        b, err := json.Marshal(v)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">merged, err := runtime.JsonMerge(t.union, b)
        t.union = merged
        return err</span>
}

func (t Invoice_DeliveryAddress) MarshalJSON() ([]byte, error) <span class="cov0" title="0">{
        b, err := t.union.MarshalJSON()
        return b, err
}</span>

func (t *Invoice_DeliveryAddress) UnmarshalJSON(b []byte) error <span class="cov0" title="0">{
        err := t.union.UnmarshalJSON(b)
        return err
}</span>

// AsInvoiceItem returns the union data inside the Invoice_LineItems_Item as a InvoiceItem
func (t Invoice_LineItems_Item) AsInvoiceItem() (InvoiceItem, error) <span class="cov0" title="0">{
        var body InvoiceItem
        err := json.Unmarshal(t.union, &amp;body)
        return body, err
}</span>

// FromInvoiceItem overwrites any union data inside the Invoice_LineItems_Item as the provided InvoiceItem
func (t *Invoice_LineItems_Item) FromInvoiceItem(v InvoiceItem) error <span class="cov0" title="0">{
        b, err := json.Marshal(v)
        t.union = b
        return err
}</span>

// MergeInvoiceItem performs a merge with any union data inside the Invoice_LineItems_Item, using the provided InvoiceItem
func (t *Invoice_LineItems_Item) MergeInvoiceItem(v InvoiceItem) error <span class="cov0" title="0">{
        b, err := json.Marshal(v)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">merged, err := runtime.JsonMerge(t.union, b)
        t.union = merged
        return err</span>
}

func (t Invoice_LineItems_Item) MarshalJSON() ([]byte, error) <span class="cov0" title="0">{
        b, err := t.union.MarshalJSON()
        return b, err
}</span>

func (t *Invoice_LineItems_Item) UnmarshalJSON(b []byte) error <span class="cov0" title="0">{
        err := t.union.UnmarshalJSON(b)
        return err
}</span>

// AsSalesInvoiceItem returns the union data inside the InvoiceItem as a SalesInvoiceItem
func (t InvoiceItem) AsSalesInvoiceItem() (SalesInvoiceItem, error) <span class="cov0" title="0">{
        var body SalesInvoiceItem
        err := json.Unmarshal(t.union, &amp;body)
        return body, err
}</span>

// FromSalesInvoiceItem overwrites any union data inside the InvoiceItem as the provided SalesInvoiceItem
func (t *InvoiceItem) FromSalesInvoiceItem(v SalesInvoiceItem) error <span class="cov0" title="0">{
        b, err := json.Marshal(v)
        t.union = b
        return err
}</span>

// MergeSalesInvoiceItem performs a merge with any union data inside the InvoiceItem, using the provided SalesInvoiceItem
func (t *InvoiceItem) MergeSalesInvoiceItem(v SalesInvoiceItem) error <span class="cov0" title="0">{
        b, err := json.Marshal(v)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">merged, err := runtime.JsonMerge(t.union, b)
        t.union = merged
        return err</span>
}

// AsDescriptionOnlyInvoiceItem returns the union data inside the InvoiceItem as a DescriptionOnlyInvoiceItem
func (t InvoiceItem) AsDescriptionOnlyInvoiceItem() (DescriptionOnlyInvoiceItem, error) <span class="cov0" title="0">{
        var body DescriptionOnlyInvoiceItem
        err := json.Unmarshal(t.union, &amp;body)
        return body, err
}</span>

// FromDescriptionOnlyInvoiceItem overwrites any union data inside the InvoiceItem as the provided DescriptionOnlyInvoiceItem
func (t *InvoiceItem) FromDescriptionOnlyInvoiceItem(v DescriptionOnlyInvoiceItem) error <span class="cov0" title="0">{
        b, err := json.Marshal(v)
        t.union = b
        return err
}</span>

// MergeDescriptionOnlyInvoiceItem performs a merge with any union data inside the InvoiceItem, using the provided DescriptionOnlyInvoiceItem
func (t *InvoiceItem) MergeDescriptionOnlyInvoiceItem(v DescriptionOnlyInvoiceItem) error <span class="cov0" title="0">{
        b, err := json.Marshal(v)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">merged, err := runtime.JsonMerge(t.union, b)
        t.union = merged
        return err</span>
}

func (t InvoiceItem) MarshalJSON() ([]byte, error) <span class="cov0" title="0">{
        b, err := t.union.MarshalJSON()
        return b, err
}</span>

func (t *InvoiceItem) UnmarshalJSON(b []byte) error <span class="cov0" title="0">{
        err := t.union.UnmarshalJSON(b)
        return err
}</span>

// AsSalesItem returns the union data inside the Item as a SalesItem
func (t Item) AsSalesItem() (SalesItem, error) <span class="cov0" title="0">{
        var body SalesItem
        err := json.Unmarshal(t.union, &amp;body)
        return body, err
}</span>

// FromSalesItem overwrites any union data inside the Item as the provided SalesItem
func (t *Item) FromSalesItem(v SalesItem) error <span class="cov0" title="0">{
        b, err := json.Marshal(v)
        t.union = b
        return err
}</span>

// MergeSalesItem performs a merge with any union data inside the Item, using the provided SalesItem
func (t *Item) MergeSalesItem(v SalesItem) error <span class="cov0" title="0">{
        b, err := json.Marshal(v)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">merged, err := runtime.JsonMerge(t.union, b)
        t.union = merged
        return err</span>
}

// AsDescriptionOnlyItem returns the union data inside the Item as a DescriptionOnlyItem
func (t Item) AsDescriptionOnlyItem() (DescriptionOnlyItem, error) <span class="cov0" title="0">{
        var body DescriptionOnlyItem
        err := json.Unmarshal(t.union, &amp;body)
        return body, err
}</span>

// FromDescriptionOnlyItem overwrites any union data inside the Item as the provided DescriptionOnlyItem
func (t *Item) FromDescriptionOnlyItem(v DescriptionOnlyItem) error <span class="cov0" title="0">{
        b, err := json.Marshal(v)
        t.union = b
        return err
}</span>

// MergeDescriptionOnlyItem performs a merge with any union data inside the Item, using the provided DescriptionOnlyItem
func (t *Item) MergeDescriptionOnlyItem(v DescriptionOnlyItem) error <span class="cov0" title="0">{
        b, err := json.Marshal(v)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">merged, err := runtime.JsonMerge(t.union, b)
        t.union = merged
        return err</span>
}

func (t Item) MarshalJSON() ([]byte, error) <span class="cov0" title="0">{
        b, err := t.union.MarshalJSON()
        return b, err
}</span>

func (t *Item) UnmarshalJSON(b []byte) error <span class="cov0" title="0">{
        err := t.union.UnmarshalJSON(b)
        return err
}</span>
</pre>
		
		<pre class="file" id="file4" style="display: none">//go:build !ignore

// Package general provides primitives to interact with the openapi HTTP API.
//
// Code generated by github.com/deepmap/oapi-codegen version v1.16.3 DO NOT EDIT.
//
package general

import (
        "context"
        "fmt"
        "net/http"
        "net/url"
        "strings"
)

// RequestEditorFn  is the function signature for the RequestEditor callback function
type RequestEditorFn func(ctx context.Context, req *http.Request) error

// Doer performs HTTP requests.
//
// The standard http.Client implements this interface.
type HttpRequestDoer interface {
        Do(req *http.Request) (*http.Response, error)
}

// Client which conforms to the OpenAPI3 specification for this service.
type Client struct {
        // The endpoint of the server conforming to this interface, with scheme,
        // https://api.deepmap.com for example. This can contain a path relative
        // to the server, such as https://api.deepmap.com/dev-test, and all the
        // paths in the swagger spec will be appended to the server.
        Server string

        // Doer for performing requests, typically a *http.Client with any
        // customized settings, such as certificate chains.
        Client HttpRequestDoer

        // A list of callbacks for modifying requests which are generated before sending over
        // the network.
        RequestEditors []RequestEditorFn
}

// ClientOption allows setting custom parameters during construction
type ClientOption func(*Client) error

// Creates a new Client, with reasonable defaults
func NewClient(server string, opts ...ClientOption) (*Client, error) <span class="cov0" title="0">{
        // create a client with sane default values
        client := Client{
                Server: server,
        }
        // mutate client and add all optional params
        for _, o := range opts </span><span class="cov0" title="0">{
                if err := o(&amp;client); err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>
        }
        // ensure the server URL always has a trailing slash
        <span class="cov0" title="0">if !strings.HasSuffix(client.Server, "/") </span><span class="cov0" title="0">{
                client.Server += "/"
        }</span>
        // create httpClient, if not already present
        <span class="cov0" title="0">if client.Client == nil </span><span class="cov0" title="0">{
                client.Client = &amp;http.Client{}
        }</span>
        <span class="cov0" title="0">return &amp;client, nil</span>
}

// WithHTTPClient allows overriding the default Doer, which is
// automatically created using http.Client. This is useful for tests.
func WithHTTPClient(doer HttpRequestDoer) ClientOption <span class="cov0" title="0">{
        return func(c *Client) error </span><span class="cov0" title="0">{
                c.Client = doer
                return nil
        }</span>
}

// GetConnections request
func (c *Client) GetConnections(ctx context.Context, params *GetConnectionsParams, reqEditors... RequestEditorFn) (*http.Response, error) <span class="cov0" title="0">{
        req, err := NewGetConnectionsRequest(c.Server, params)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">req = req.WithContext(ctx)
        if err := c.applyEditors(ctx, req, reqEditors); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">return c.Client.Do(req)</span>
}

// NewGetConnectionsRequest generates requests for GetConnections
func NewGetConnectionsRequest(server string, params *GetConnectionsParams) (*http.Request, error) <span class="cov0" title="0">{
        var err error

        serverURL, err := url.Parse(server)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">operationPath := fmt.Sprintf("/v1/connections")
        if operationPath[0] == '/' </span><span class="cov0" title="0">{
                operationPath = operationPath[1:]
        }</span>

        <span class="cov0" title="0">queryURL, err := serverURL.Parse(operationPath)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">req, err := http.NewRequest("GET", queryURL.String(), nil)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">if params != nil </span><span class="cov0" title="0">{
                if params.ContentType != nil </span><span class="cov0" title="0">{
                        req.Header.Set("Content-Type", *params.ContentType)
                }</span>
        }

        <span class="cov0" title="0">return req, nil</span>
}

func (c *Client) applyEditors(ctx context.Context, req *http.Request, additionalEditors []RequestEditorFn) error <span class="cov0" title="0">{
        for _, r := range c.RequestEditors </span><span class="cov0" title="0">{
                if err := r(ctx, req); err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
        }
        <span class="cov0" title="0">for _, r := range additionalEditors </span><span class="cov0" title="0">{
                if err := r(ctx, req); err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
        }
        <span class="cov0" title="0">return nil</span>
}
</pre>
		
		<pre class="file" id="file5" style="display: none">// Package bokio provides token management with persistent storage and encryption
package bokio

import (
        "crypto/aes"
        "crypto/cipher"
        "crypto/rand"
        "crypto/sha256"
        "encoding/base64"
        "encoding/json"
        "fmt"
        "io"
        "os"
        "path/filepath"
        "sync"
        "time"
)

// TokenData represents stored token information
type TokenData struct {
        AccessToken  string    `json:"access_token"`
        RefreshToken string    `json:"refresh_token"`
        TokenExpiry  time.Time `json:"token_expiry"`
        TenantID     string    `json:"tenant_id"`
        TenantType   string    `json:"tenant_type"`
        CreatedAt    time.Time `json:"created_at"`
        UpdatedAt    time.Time `json:"updated_at"`
}

// TokenStorage interface for token persistence
type TokenStorage interface {
        Save(clientID string, tokens *TokenData) error
        Load(clientID string) (*TokenData, error)
        Delete(clientID string) error
        Exists(clientID string) bool
}

// FileTokenStorage implements TokenStorage using encrypted file storage
type FileTokenStorage struct {
        baseDir    string
        encryption TokenEncryption
        mutex      sync.RWMutex
}

// TokenEncryption interface for token encryption/decryption
type TokenEncryption interface {
        Encrypt(data []byte, key string) ([]byte, error)
        Decrypt(data []byte, key string) ([]byte, error)
}

// AESTokenEncryption implements TokenEncryption using AES-256-GCM
type AESTokenEncryption struct{}

// TokenManager manages token storage, encryption, and lifecycle
type TokenManager struct {
        storage    TokenStorage
        encryption TokenEncryption
        logger     Logger
        mutex      sync.RWMutex
}

// NewTokenManager creates a new token manager with default settings
func NewTokenManager(logger Logger) (*TokenManager, error) <span class="cov0" title="0">{
        if logger == nil </span><span class="cov0" title="0">{
                logger = &amp;DefaultLogger{}
        }</span>

        // Create storage directory
        <span class="cov0" title="0">homeDir, err := os.UserHomeDir()
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to get user home directory: %w", err)
        }</span>

        <span class="cov0" title="0">baseDir := filepath.Join(homeDir, ".bokio-mcp")
        if err := os.MkdirAll(baseDir, 0700); err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to create token storage directory: %w", err)
        }</span>

        <span class="cov0" title="0">storage := &amp;FileTokenStorage{
                baseDir:    baseDir,
                encryption: &amp;AESTokenEncryption{},
        }

        return &amp;TokenManager{
                storage:    storage,
                encryption: &amp;AESTokenEncryption{},
                logger:     logger,
        }, nil</span>
}

// SaveTokens saves tokens to persistent storage
func (tm *TokenManager) SaveTokens(clientID, accessToken, refreshToken string, expiresAt time.Time, tenantID, tenantType string) error <span class="cov0" title="0">{
        tm.mutex.Lock()
        defer tm.mutex.Unlock()

        now := time.Now()
        tokenData := &amp;TokenData{
                AccessToken:  accessToken,
                RefreshToken: refreshToken,
                TokenExpiry:  expiresAt,
                TenantID:     tenantID,
                TenantType:   tenantType,
                CreatedAt:    now,
                UpdatedAt:    now,
        }

        // Update existing token's created timestamp if it exists
        if existing, err := tm.storage.Load(clientID); err == nil </span><span class="cov0" title="0">{
                tokenData.CreatedAt = existing.CreatedAt
        }</span>

        <span class="cov0" title="0">if err := tm.storage.Save(clientID, tokenData); err != nil </span><span class="cov0" title="0">{
                tm.logger.Error("Failed to save tokens", "client_id", clientID, "error", err)
                return fmt.Errorf("failed to save tokens: %w", err)
        }</span>

        <span class="cov0" title="0">tm.logger.Info("Tokens saved successfully", "client_id", clientID, "expires_at", expiresAt)
        return nil</span>
}

// LoadTokens loads tokens from persistent storage
func (tm *TokenManager) LoadTokens(clientID string) (accessToken, refreshToken string, expiresAt time.Time, tenantID, tenantType string, err error) <span class="cov0" title="0">{
        tm.mutex.RLock()
        defer tm.mutex.RUnlock()

        tokenData, err := tm.storage.Load(clientID)
        if err != nil </span><span class="cov0" title="0">{
                tm.logger.Debug("Failed to load tokens", "client_id", clientID, "error", err)
                return "", "", time.Time{}, "", "", fmt.Errorf("failed to load tokens: %w", err)
        }</span>

        <span class="cov0" title="0">tm.logger.Debug("Tokens loaded successfully", "client_id", clientID, "expires_at", tokenData.TokenExpiry)
        return tokenData.AccessToken, tokenData.RefreshToken, tokenData.TokenExpiry, tokenData.TenantID, tokenData.TenantType, nil</span>
}

// UpdateTokens updates existing tokens in storage
func (tm *TokenManager) UpdateTokens(clientID, accessToken, refreshToken string, expiresAt time.Time) error <span class="cov0" title="0">{
        tm.mutex.Lock()
        defer tm.mutex.Unlock()

        // Load existing token data
        existing, err := tm.storage.Load(clientID)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to load existing tokens: %w", err)
        }</span>

        // Update with new values
        <span class="cov0" title="0">existing.AccessToken = accessToken
        if refreshToken != "" </span><span class="cov0" title="0">{
                existing.RefreshToken = refreshToken
        }</span>
        <span class="cov0" title="0">existing.TokenExpiry = expiresAt
        existing.UpdatedAt = time.Now()

        if err := tm.storage.Save(clientID, existing); err != nil </span><span class="cov0" title="0">{
                tm.logger.Error("Failed to update tokens", "client_id", clientID, "error", err)
                return fmt.Errorf("failed to update tokens: %w", err)
        }</span>

        <span class="cov0" title="0">tm.logger.Info("Tokens updated successfully", "client_id", clientID, "expires_at", expiresAt)
        return nil</span>
}

// DeleteTokens removes tokens from persistent storage
func (tm *TokenManager) DeleteTokens(clientID string) error <span class="cov0" title="0">{
        tm.mutex.Lock()
        defer tm.mutex.Unlock()

        if err := tm.storage.Delete(clientID); err != nil </span><span class="cov0" title="0">{
                tm.logger.Error("Failed to delete tokens", "client_id", clientID, "error", err)
                return fmt.Errorf("failed to delete tokens: %w", err)
        }</span>

        <span class="cov0" title="0">tm.logger.Info("Tokens deleted successfully", "client_id", clientID)
        return nil</span>
}

// HasTokens checks if tokens exist for the given client ID
func (tm *TokenManager) HasTokens(clientID string) bool <span class="cov0" title="0">{
        tm.mutex.RLock()
        defer tm.mutex.RUnlock()

        return tm.storage.Exists(clientID)
}</span>

// IsTokenValid checks if the stored token is still valid
func (tm *TokenManager) IsTokenValid(clientID string) bool <span class="cov0" title="0">{
        tm.mutex.RLock()
        defer tm.mutex.RUnlock()

        tokenData, err := tm.storage.Load(clientID)
        if err != nil </span><span class="cov0" title="0">{
                return false
        }</span>

        // Consider token valid if it expires more than 5 minutes from now
        <span class="cov0" title="0">return time.Now().Add(5 * time.Minute).Before(tokenData.TokenExpiry)</span>
}

// GetTokenInfo returns information about stored tokens without exposing the actual tokens
func (tm *TokenManager) GetTokenInfo(clientID string) (tenantID, tenantType string, expiresAt time.Time, hasRefreshToken bool, err error) <span class="cov0" title="0">{
        tm.mutex.RLock()
        defer tm.mutex.RUnlock()

        tokenData, err := tm.storage.Load(clientID)
        if err != nil </span><span class="cov0" title="0">{
                return "", "", time.Time{}, false, fmt.Errorf("failed to load token info: %w", err)
        }</span>

        <span class="cov0" title="0">return tokenData.TenantID, tokenData.TenantType, tokenData.TokenExpiry, tokenData.RefreshToken != "", nil</span>
}

// FileTokenStorage implementation

// Save saves encrypted token data to file
func (fs *FileTokenStorage) Save(clientID string, tokens *TokenData) error <span class="cov0" title="0">{
        fs.mutex.Lock()
        defer fs.mutex.Unlock()

        // Serialize token data
        data, err := json.Marshal(tokens)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to marshal token data: %w", err)
        }</span>

        // Encrypt the data
        <span class="cov0" title="0">encryptedData, err := fs.encryption.Encrypt(data, clientID)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to encrypt token data: %w", err)
        }</span>

        // Write to file
        <span class="cov0" title="0">filename := fs.getTokenFilePath(clientID)
        if err := os.WriteFile(filename, encryptedData, 0600); err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to write token file: %w", err)
        }</span>

        <span class="cov0" title="0">return nil</span>
}

// Load loads and decrypts token data from file
func (fs *FileTokenStorage) Load(clientID string) (*TokenData, error) <span class="cov0" title="0">{
        fs.mutex.RLock()
        defer fs.mutex.RUnlock()

        filename := fs.getTokenFilePath(clientID)
        encryptedData, err := os.ReadFile(filename)
        if err != nil </span><span class="cov0" title="0">{
                if os.IsNotExist(err) </span><span class="cov0" title="0">{
                        return nil, fmt.Errorf("token file not found")
                }</span>
                <span class="cov0" title="0">return nil, fmt.Errorf("failed to read token file: %w", err)</span>
        }

        // Decrypt the data
        <span class="cov0" title="0">data, err := fs.encryption.Decrypt(encryptedData, clientID)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to decrypt token data: %w", err)
        }</span>

        // Deserialize token data
        <span class="cov0" title="0">var tokens TokenData
        if err := json.Unmarshal(data, &amp;tokens); err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to unmarshal token data: %w", err)
        }</span>

        <span class="cov0" title="0">return &amp;tokens, nil</span>
}

// Delete removes the token file
func (fs *FileTokenStorage) Delete(clientID string) error <span class="cov0" title="0">{
        fs.mutex.Lock()
        defer fs.mutex.Unlock()

        filename := fs.getTokenFilePath(clientID)
        if err := os.Remove(filename); err != nil &amp;&amp; !os.IsNotExist(err) </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to delete token file: %w", err)
        }</span>
        <span class="cov0" title="0">return nil</span>
}

// Exists checks if a token file exists
func (fs *FileTokenStorage) Exists(clientID string) bool <span class="cov0" title="0">{
        fs.mutex.RLock()
        defer fs.mutex.RUnlock()

        filename := fs.getTokenFilePath(clientID)
        _, err := os.Stat(filename)
        return err == nil
}</span>

// getTokenFilePath returns the file path for storing tokens
func (fs *FileTokenStorage) getTokenFilePath(clientID string) string <span class="cov0" title="0">{
        // Hash the client ID to create a safe filename
        hash := sha256.Sum256([]byte(clientID))
        filename := base64.URLEncoding.EncodeToString(hash[:])
        return filepath.Join(fs.baseDir, filename+".json")
}</span>

// AESTokenEncryption implementation

// Encrypt encrypts data using AES-256-GCM with client ID as key derivation
func (e *AESTokenEncryption) Encrypt(data []byte, key string) ([]byte, error) <span class="cov0" title="0">{
        // Derive encryption key from client ID
        keyHash := sha256.Sum256([]byte(key))
        
        block, err := aes.NewCipher(keyHash[:])
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to create cipher: %w", err)
        }</span>

        <span class="cov0" title="0">aesGCM, err := cipher.NewGCM(block)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to create GCM: %w", err)
        }</span>

        // Create random nonce
        <span class="cov0" title="0">nonce := make([]byte, aesGCM.NonceSize())
        if _, err := io.ReadFull(rand.Reader, nonce); err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to generate nonce: %w", err)
        }</span>

        // Encrypt the data
        <span class="cov0" title="0">ciphertext := aesGCM.Seal(nonce, nonce, data, nil)
        return ciphertext, nil</span>
}

// Decrypt decrypts data using AES-256-GCM with client ID as key derivation
func (e *AESTokenEncryption) Decrypt(data []byte, key string) ([]byte, error) <span class="cov0" title="0">{
        // Derive encryption key from client ID
        keyHash := sha256.Sum256([]byte(key))
        
        block, err := aes.NewCipher(keyHash[:])
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to create cipher: %w", err)
        }</span>

        <span class="cov0" title="0">aesGCM, err := cipher.NewGCM(block)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to create GCM: %w", err)
        }</span>

        // Extract nonce and ciphertext
        <span class="cov0" title="0">nonceSize := aesGCM.NonceSize()
        if len(data) &lt; nonceSize </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("ciphertext too short")
        }</span>

        <span class="cov0" title="0">nonce, ciphertext := data[:nonceSize], data[nonceSize:]

        // Decrypt the data
        plaintext, err := aesGCM.Open(nil, nonce, ciphertext, nil)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to decrypt: %w", err)
        }</span>

        <span class="cov0" title="0">return plaintext, nil</span>
}</pre>
		
		<pre class="file" id="file6" style="display: none">// Package bokio contains type definitions for the Bokio API
package bokio

import (
        "time"
)

// PagedResponse represents a paginated response from the Bokio API
type PagedResponse struct {
        TotalItems  int32 `json:"totalItems"`
        TotalPages  int32 `json:"totalPages"`
        CurrentPage int32 `json:"currentPage"`
}

// Connection represents a connection to a tenant in the Bokio API
type Connection struct {
        ID       string `json:"id"`
        TenantID string `json:"tenantId"`
        Type     string `json:"type"`
}

// ConnectionsResponse represents a paginated list of connections
type ConnectionsResponse struct {
        PagedResponse
        Items []Connection `json:"items"`
}

// JournalEntryItem represents a single item in a journal entry
type JournalEntryItem struct {
        ID      int64   `json:"id,omitempty"`      // Read-only
        Debit   float64 `json:"debit"`
        Credit  float64 `json:"credit"`
        Account int32   `json:"account"`
}

// JournalEntry represents a journal entry in the accounting system
type JournalEntry struct {
        ID                        string               `json:"id,omitempty"`                       // Read-only
        Title                     string               `json:"title"`
        JournalEntryNumber        string               `json:"journalEntryNumber,omitempty"`       // Read-only
        Date                      string               `json:"date"`                               // Format: date (YYYY-MM-DD)
        Items                     []JournalEntryItem   `json:"items"`
        ReversingJournalEntryID   *string              `json:"reversingJournalEntryId,omitempty"`   // Read-only, nullable
        ReversedByJournalEntryID  *string              `json:"reversedByJournalEntryId,omitempty"`  // Read-only, nullable
}

// JournalEntriesResponse represents a paginated list of journal entries
type JournalEntriesResponse struct {
        PagedResponse
        Items []JournalEntry `json:"items"`
}

// Address represents a postal address
type Address struct {
        Line1      string  `json:"line1"`
        Line2      *string `json:"line2,omitempty"`      // nullable
        City       string  `json:"city"`
        PostalCode string  `json:"postalCode"`
        Country    string  `json:"country"`              // ISO 3166-1 alpha-2 country code
}

// CustomerType represents the type of customer
type CustomerType string

const (
        CustomerTypeCompany CustomerType = "company"
        CustomerTypePrivate CustomerType = "private"
)

// Customer represents a customer in the system
type Customer struct {
        ID              string        `json:"id,omitempty"`                 // Read-only
        Name            string        `json:"name"`
        Type            CustomerType  `json:"type"`
        VatNumber       string        `json:"vatNumber,omitempty"`
        OrgNumber       string        `json:"orgNumber,omitempty"`
        PaymentTerms    string        `json:"paymentTerms,omitempty"`
        Email           string        `json:"email,omitempty"`
        Phone           string        `json:"phone,omitempty"`
        Address         *Address      `json:"address,omitempty"`
        CreatedAt       *time.Time    `json:"createdAt,omitempty"`          // Read-only
        UpdatedAt       *time.Time    `json:"updatedAt,omitempty"`          // Read-only
}

// CustomersResponse represents a paginated list of customers
type CustomersResponse struct {
        PagedResponse
        Items []Customer `json:"items"`
}

// Upload represents a file upload
type Upload struct {
        ID              string  `json:"id,omitempty"`                    // Read-only
        Description     string  `json:"description"`
        ContentType     string  `json:"contentType"`
        JournalEntryID  *string `json:"journalEntryId,omitempty"`        // nullable
        CreatedAt       *time.Time `json:"createdAt,omitempty"`          // Read-only
}

// UploadsResponse represents a paginated list of uploads
type UploadsResponse struct {
        PagedResponse
        Items []Upload `json:"items"`
}

// Item represents an inventory or service item
type Item struct {
        ID            string     `json:"id,omitempty"`                    // Read-only
        Name          string     `json:"name"`
        Description   string     `json:"description,omitempty"`
        Price         float64    `json:"price"`
        Unit          string     `json:"unit,omitempty"`
        Account       int32      `json:"account,omitempty"`
        VatRate       float64    `json:"vatRate,omitempty"`
        Active        bool       `json:"active"`
        CreatedAt     *time.Time `json:"createdAt,omitempty"`             // Read-only
        UpdatedAt     *time.Time `json:"updatedAt,omitempty"`             // Read-only
}

// ItemsResponse represents a paginated list of items
type ItemsResponse struct {
        PagedResponse
        Items []Item `json:"items"`
}

// InvoiceStatus represents the status of an invoice
type InvoiceStatus string

const (
        InvoiceStatusDraft     InvoiceStatus = "draft"
        InvoiceStatusSent      InvoiceStatus = "sent"
        InvoiceStatusPaid      InvoiceStatus = "paid"
        InvoiceStatusOverdue   InvoiceStatus = "overdue"
        InvoiceStatusCancelled InvoiceStatus = "cancelled"
)

// InvoiceItem represents an item on an invoice
type InvoiceItem struct {
        ID          string  `json:"id,omitempty"`               // Read-only
        ItemID      *string `json:"itemId,omitempty"`           // Reference to Item
        Name        string  `json:"name"`
        Description string  `json:"description,omitempty"`
        Quantity    float64 `json:"quantity"`
        Price       float64 `json:"price"`
        Unit        string  `json:"unit,omitempty"`
        Account     int32   `json:"account,omitempty"`
        VatRate     float64 `json:"vatRate,omitempty"`
        Total       float64 `json:"total,omitempty"`            // Read-only, calculated
}

// Invoice represents an invoice
type Invoice struct {
        ID             string          `json:"id,omitempty"`                    // Read-only
        InvoiceNumber  string          `json:"invoiceNumber,omitempty"`         // Read-only
        CustomerID     string          `json:"customerId"`                      // Reference to Customer
        Customer       *Customer       `json:"customer,omitempty"`              // Read-only, populated when requested
        Status         InvoiceStatus   `json:"status,omitempty"`                // Read-only
        Date           string          `json:"date"`                            // Format: date (YYYY-MM-DD)
        DueDate        string          `json:"dueDate"`                         // Format: date (YYYY-MM-DD)
        Items          []InvoiceItem   `json:"items"`
        Notes          string          `json:"notes,omitempty"`
        PaymentTerms   string          `json:"paymentTerms,omitempty"`
        Currency       string          `json:"currency,omitempty"`
        Subtotal       float64         `json:"subtotal,omitempty"`              // Read-only, calculated
        VatAmount      float64         `json:"vatAmount,omitempty"`             // Read-only, calculated
        Total          float64         `json:"total,omitempty"`                 // Read-only, calculated
        CreatedAt      *time.Time      `json:"createdAt,omitempty"`             // Read-only
        UpdatedAt      *time.Time      `json:"updatedAt,omitempty"`             // Read-only
}

// InvoicesResponse represents a paginated list of invoices
type InvoicesResponse struct {
        PagedResponse
        Items []Invoice `json:"items"`
}

// FiscalYear represents a fiscal year
type FiscalYear struct {
        ID        string     `json:"id,omitempty"`                    // Read-only
        StartDate string     `json:"startDate"`                       // Format: date (YYYY-MM-DD)
        EndDate   string     `json:"endDate"`                         // Format: date (YYYY-MM-DD)
        Status    string     `json:"status,omitempty"`                // Read-only
        CreatedAt *time.Time `json:"createdAt,omitempty"`             // Read-only
}

// FiscalYearsResponse represents a paginated list of fiscal years
type FiscalYearsResponse struct {
        PagedResponse
        Items []FiscalYear `json:"items"`
}

// APIErrorDetail represents detailed error information
type APIErrorDetail struct {
        Field   string `json:"field"`
        Message string `json:"message"`
}

// APIErrorResponse represents the standard API error response structure
type APIErrorResponse struct {
        Code         string           `json:"code"`
        Message      string           `json:"message"`
        BokioErrorID string           `json:"bokioErrorId,omitempty"`
        Errors       []APIErrorDetail `json:"errors,omitempty"`
}

// QueryParams represents common query parameters for API requests
type QueryParams struct {
        Page     int32  `json:"page,omitempty"`
        PageSize int32  `json:"pageSize,omitempty"`
        Query    string `json:"query,omitempty"`
}

// DefaultQueryParams returns default query parameters
func DefaultQueryParams() QueryParams <span class="cov0" title="0">{
        return QueryParams{
                Page:     1,
                PageSize: 25,
        }
}</span>

// TenantType represents the type of tenant
type TenantType string

const (
        TenantTypeGeneral TenantType = "general"
        TenantTypeCompany TenantType = "company"
)

// CompanyInfo represents basic company information
type CompanyInfo struct {
        ID       string `json:"id"`
        Name     string `json:"name"`
        OrgNumber string `json:"orgNumber,omitempty"`
        VatNumber string `json:"vatNumber,omitempty"`
}

// CreateJournalEntryRequest represents the request to create a journal entry
type CreateJournalEntryRequest struct {
        Title string               `json:"title"`
        Date  string               `json:"date"`
        Items []JournalEntryItem   `json:"items"`
}

// CreateCustomerRequest represents the request to create a customer
type CreateCustomerRequest struct {
        Name         string       `json:"name"`
        Type         CustomerType `json:"type"`
        VatNumber    string       `json:"vatNumber,omitempty"`
        OrgNumber    string       `json:"orgNumber,omitempty"`
        PaymentTerms string       `json:"paymentTerms,omitempty"`
        Email        string       `json:"email,omitempty"`
        Phone        string       `json:"phone,omitempty"`
        Address      *Address     `json:"address,omitempty"`
}

// UpdateCustomerRequest represents the request to update a customer
type UpdateCustomerRequest struct {
        Name         *string      `json:"name,omitempty"`
        VatNumber    *string      `json:"vatNumber,omitempty"`
        OrgNumber    *string      `json:"orgNumber,omitempty"`
        PaymentTerms *string      `json:"paymentTerms,omitempty"`
        Email        *string      `json:"email,omitempty"`
        Phone        *string      `json:"phone,omitempty"`
        Address      *Address     `json:"address,omitempty"`
}

// CreateInvoiceRequest represents the request to create an invoice
type CreateInvoiceRequest struct {
        CustomerID   string        `json:"customerId"`
        Date         string        `json:"date"`
        DueDate      string        `json:"dueDate"`
        Items        []InvoiceItem `json:"items"`
        Notes        string        `json:"notes,omitempty"`
        PaymentTerms string        `json:"paymentTerms,omitempty"`
        Currency     string        `json:"currency,omitempty"`
}

// UpdateInvoiceRequest represents the request to update an invoice
type UpdateInvoiceRequest struct {
        CustomerID   *string       `json:"customerId,omitempty"`
        Date         *string       `json:"date,omitempty"`
        DueDate      *string       `json:"dueDate,omitempty"`
        Items        []InvoiceItem `json:"items,omitempty"`
        Notes        *string       `json:"notes,omitempty"`
        PaymentTerms *string       `json:"paymentTerms,omitempty"`
        Currency     *string       `json:"currency,omitempty"`
}

// CreateItemRequest represents the request to create an item
type CreateItemRequest struct {
        Name        string  `json:"name"`
        Description string  `json:"description,omitempty"`
        Price       float64 `json:"price"`
        Unit        string  `json:"unit,omitempty"`
        Account     int32   `json:"account,omitempty"`
        VatRate     float64 `json:"vatRate,omitempty"`
        Active      bool    `json:"active"`
}

// UpdateItemRequest represents the request to update an item
type UpdateItemRequest struct {
        Name        *string  `json:"name,omitempty"`
        Description *string  `json:"description,omitempty"`
        Price       *float64 `json:"price,omitempty"`
        Unit        *string  `json:"unit,omitempty"`
        Account     *int32   `json:"account,omitempty"`
        VatRate     *float64 `json:"vatRate,omitempty"`
        Active      *bool    `json:"active,omitempty"`
}

// UploadFileRequest represents the request to upload a file
type UploadFileRequest struct {
        Description    string  `json:"description"`
        JournalEntryID *string `json:"journalEntryId,omitempty"`
        FileContent    []byte  `json:"-"` // File content, not JSON serialized
        FileName       string  `json:"-"` // File name, not JSON serialized
        ContentType    string  `json:"-"` // Content type, not JSON serialized
}

// FilterOperator represents filter operators for API queries
type FilterOperator string

const (
        FilterOperatorEquals              FilterOperator = "="
        FilterOperatorNotEquals           FilterOperator = "!="
        FilterOperatorGreaterThan         FilterOperator = "&gt;"
        FilterOperatorGreaterThanOrEqual  FilterOperator = "&gt;="
        FilterOperatorLessThan            FilterOperator = "&lt;"
        FilterOperatorLessThanOrEqual     FilterOperator = "&lt;="
        FilterOperatorContains            FilterOperator = "~"
        FilterOperatorNotContains         FilterOperator = "!~"
        FilterOperatorStartsWith          FilterOperator = "^"
        FilterOperatorEndsWith            FilterOperator = "$"
        FilterOperatorIn                  FilterOperator = "@"
        FilterOperatorNotIn               FilterOperator = "!@"
)

// QueryBuilder helps build query strings for API requests
type QueryBuilder struct {
        filters []string
}

// NewQueryBuilder creates a new query builder
func NewQueryBuilder() *QueryBuilder <span class="cov0" title="0">{
        return &amp;QueryBuilder{
                filters: make([]string, 0),
        }
}</span>

// AddFilter adds a filter to the query
func (qb *QueryBuilder) AddFilter(field string, operator FilterOperator, value string) *QueryBuilder <span class="cov0" title="0">{
        qb.filters = append(qb.filters, field+string(operator)+value)
        return qb
}</span>

// Build returns the query string
func (qb *QueryBuilder) Build() string <span class="cov0" title="0">{
        if len(qb.filters) == 0 </span><span class="cov0" title="0">{
                return ""
        }</span>
        <span class="cov0" title="0">result := ""
        for i, filter := range qb.filters </span><span class="cov0" title="0">{
                if i &gt; 0 </span><span class="cov0" title="0">{
                        result += " AND "
                }</span>
                <span class="cov0" title="0">result += filter</span>
        }
        <span class="cov0" title="0">return result</span>
}

// Reset clears all filters
func (qb *QueryBuilder) Reset() *QueryBuilder <span class="cov0" title="0">{
        qb.filters = qb.filters[:0]
        return qb
}</span>

// SIEFile represents a SIE (Standard Import Export) file for Swedish accounting
type SIEFile struct {
        ID         string     `json:"id,omitempty"`                    // Read-only
        FiscalYear string     `json:"fiscalYear"`
        FileType   string     `json:"fileType,omitempty"`              // Read-only
        CreatedAt  *time.Time `json:"createdAt,omitempty"`             // Read-only
}

// SIEFilesResponse represents a paginated list of SIE files
type SIEFilesResponse struct {
        PagedResponse
        Items []SIEFile `json:"items"`
}

// Account represents a chart of accounts entry
type Account struct {
        Number      int32  `json:"number"`
        Name        string `json:"name"`
        Type        string `json:"type,omitempty"`
        Description string `json:"description,omitempty"`
        Active      bool   `json:"active"`
}

// AccountsResponse represents a list of accounts
type AccountsResponse struct {
        Items []Account `json:"items"`
}</pre>
		
		<pre class="file" id="file7" style="display: none">package main

import (
        "context"
        "fmt"
        "log/slog"
        "os"
        "os/signal"
        "syscall"

        "github.com/klowdo/bokio-mcp/bokio"
        "github.com/klowdo/bokio-mcp/tools"
        "github.com/modelcontextprotocol/go-sdk/mcp"
)

const (
        serverName    = "bokio-mcp"
        serverVersion = "0.1.0"
)

func main() <span class="cov0" title="0">{
        // Setup structured logging
        logger := slog.New(slog.NewTextHandler(os.Stderr, &amp;slog.HandlerOptions{
                Level: slog.LevelInfo,
        }))
        slog.SetDefault(logger)

        // Create context that can be cancelled
        ctx, cancel := context.WithCancel(context.Background())
        defer cancel()

        // Handle graceful shutdown
        go func() </span><span class="cov0" title="0">{
                sigChan := make(chan os.Signal, 1)
                signal.Notify(sigChan, syscall.SIGINT, syscall.SIGTERM)
                &lt;-sigChan
                slog.Info("Received shutdown signal, gracefully shutting down...")
                cancel()
        }</span>()

        <span class="cov0" title="0">if err := run(ctx); err != nil </span><span class="cov0" title="0">{
                slog.Error("Server failed", "error", err)
                os.Exit(1)
        }</span>
}

func run(ctx context.Context) error <span class="cov0" title="0">{
        // Load configuration from environment
        config, err := loadConfig()
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to load configuration: %w", err)
        }</span>

        // Initialize Bokio API client
        <span class="cov0" title="0">bokioClient, err := bokio.NewClient(&amp;config.BokioConfig)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to create Bokio client: %w", err)
        }</span>

        // Create MCP server
        <span class="cov0" title="0">server := mcp.NewServer(serverName, serverVersion, nil)

        // Register tools with the server
        // Note: Auth tools are no longer registered as authentication is handled transparently by middleware

        if err := tools.RegisterInvoiceTools(server, bokioClient); err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to register invoice tools: %w", err)
        }</span>

        <span class="cov0" title="0">if err := tools.RegisterCustomerTools(server, bokioClient); err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to register customer tools: %w", err)
        }</span>

        <span class="cov0" title="0">if err := tools.RegisterJournalTools(server, bokioClient); err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to register journal tools: %w", err)
        }</span>

        <span class="cov0" title="0">if err := tools.RegisterUploadTools(server, bokioClient); err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to register upload tools: %w", err)
        }</span>

        // Determine authentication method
        <span class="cov0" title="0">authMethod := "Integration Token"
        if config.BokioConfig.IntegrationToken == "" </span><span class="cov0" title="0">{
                authMethod = "OAuth2 (Legacy)"
        }</span>

        <span class="cov0" title="0">slog.Info("Starting Bokio MCP server",
                "name", serverName,
                "version", serverVersion,
                "bokio_base_url", config.BokioConfig.BaseURL,
                "auth_method", authMethod,
                "read_only_mode", config.ReadOnly)

        // Create and start the MCP server with stdio transport
        transport := mcp.NewStdioTransport()
        return server.Run(ctx, transport)</span>
}

// Config holds all application configuration
type Config struct {
        BokioConfig bokio.Config
        ReadOnly    bool
}

// loadConfig loads configuration from environment variables
func loadConfig() (*Config, error) <span class="cov0" title="0">{
        // Parse read-only mode
        readOnly := os.Getenv("BOKIO_READ_ONLY") == "true"

        bokioConfig := bokio.Config{
                BaseURL:          getEnvWithDefault("BOKIO_BASE_URL", "https://api.bokio.se"),
                IntegrationToken: os.Getenv("BOKIO_INTEGRATION_TOKEN"),
                ReadOnly:         readOnly,
                // Legacy OAuth2 fields (for backward compatibility)
                ClientID:     os.Getenv("BOKIO_CLIENT_ID"),
                ClientSecret: os.Getenv("BOKIO_CLIENT_SECRET"),
                RedirectURI:  getEnvWithDefault("BOKIO_REDIRECT_URL", "http://localhost:8080/callback"),
        }

        // Validate required configuration - prefer Integration token, fallback to OAuth2
        if bokioConfig.IntegrationToken == "" </span><span class="cov0" title="0">{
                if bokioConfig.ClientID == "" </span><span class="cov0" title="0">{
                        return nil, fmt.Errorf("either BOKIO_INTEGRATION_TOKEN or legacy BOKIO_CLIENT_ID is required")
                }</span>
                <span class="cov0" title="0">if bokioConfig.ClientSecret == "" </span><span class="cov0" title="0">{
                        return nil, fmt.Errorf("BOKIO_CLIENT_SECRET is required when using legacy OAuth2 authentication")
                }</span>
        }

        <span class="cov0" title="0">return &amp;Config{
                BokioConfig: bokioConfig,
                ReadOnly:    readOnly,
        }, nil</span>
}

// getEnvWithDefault returns the value of an environment variable or a default value
func getEnvWithDefault(key, defaultValue string) string <span class="cov0" title="0">{
        if value := os.Getenv(key); value != "" </span><span class="cov0" title="0">{
                return value
        }</span>
        <span class="cov0" title="0">return defaultValue</span>
}
</pre>
		
		<pre class="file" id="file8" style="display: none">package tools

import (
        "context"
        "fmt"

        "github.com/klowdo/bokio-mcp/bokio"
        "github.com/modelcontextprotocol/go-sdk/mcp"
)

// AuthenticateParams defines the parameters for authentication
type AuthenticateParams struct {
        State *string `json:"state,omitempty"`
}

// AuthenticateResult defines the result of authentication
type AuthenticateResult struct {
        AuthURL string `json:"auth_url"`
        State   string `json:"state"`
        Message string `json:"message"`
}

// ExchangeTokenParams defines the parameters for token exchange
type ExchangeTokenParams struct {
        Code string `json:"code"`
}

// ExchangeTokenResult defines the result of token exchange
type ExchangeTokenResult struct {
        Success        bool   `json:"success"`
        Message        string `json:"message"`
        TokenType      string `json:"token_type,omitempty"`
        ExpiresAt      string `json:"expires_at,omitempty"`
        HasRefreshToken bool   `json:"has_refresh_token,omitempty"`
        Error          string `json:"error,omitempty"`
}

// GetConnectionsParams defines the parameters for getting connections (no params needed)
type GetConnectionsParams struct {}

// GetConnectionsResult defines the result of getting connections
type GetConnectionsResult struct {
        Success    bool                   `json:"success"`
        Connection map[string]interface{} `json:"connection,omitempty"`
        Error      string                 `json:"error,omitempty"`
}

// CheckAuthParams defines the parameters for checking auth (no params needed)
type CheckAuthParams struct {}

// CheckAuthResult defines the result of checking auth
type CheckAuthResult struct {
        Authenticated   bool   `json:"authenticated"`
        TokenType       string `json:"token_type,omitempty"`
        ExpiresAt       string `json:"expires_at,omitempty"`
        HasRefreshToken bool   `json:"has_refresh_token,omitempty"`
}

// RegisterAuthTools registers authentication-related MCP tools
func RegisterAuthTools(server *mcp.Server, client *bokio.Client) error <span class="cov0" title="0">{
        // Register bokio_authenticate tool
        authenticateTool := mcp.NewServerTool[AuthenticateParams, AuthenticateResult](
                "bokio_authenticate",
                "Start OAuth2 authentication flow with Bokio API. Returns authorization URL for user to visit.",
                func(ctx context.Context, session *mcp.ServerSession, params *mcp.CallToolParamsFor[AuthenticateParams]) (*mcp.CallToolResultFor[AuthenticateResult], error) </span><span class="cov0" title="0">{
                        state := ""
                        if params.Arguments.State != nil </span><span class="cov0" title="0">{
                                state = *params.Arguments.State
                        }</span>

                        <span class="cov0" title="0">authURL := client.GetAuthorizationURL(state)
                        
                        return &amp;mcp.CallToolResultFor[AuthenticateResult]{
                                Content: []mcp.Content{
                                        &amp;mcp.TextContent{
                                                Text: fmt.Sprintf("Visit this URL to authenticate: %s", authURL),
                                        },
                                },
                        }, nil</span>
                },
                mcp.Input(
                        mcp.Property("state", 
                                mcp.Description("Optional state parameter for OAuth2 flow"),
                        ),
                ),
        )
        
        <span class="cov0" title="0">server.AddTools(authenticateTool)

        // Register bokio_exchange_token tool
        exchangeTokenTool := mcp.NewServerTool[ExchangeTokenParams, ExchangeTokenResult](
                "bokio_exchange_token",
                "Exchange authorization code for access token",
                func(ctx context.Context, session *mcp.ServerSession, params *mcp.CallToolParamsFor[ExchangeTokenParams]) (*mcp.CallToolResultFor[ExchangeTokenResult], error) </span><span class="cov0" title="0">{
                        code := params.Arguments.Code
                        if code == "" </span><span class="cov0" title="0">{
                                return &amp;mcp.CallToolResultFor[ExchangeTokenResult]{
                                        Content: []mcp.Content{
                                                &amp;mcp.TextContent{
                                                        Text: "Authorization code is required",
                                                },
                                        },
                                }, fmt.Errorf("authorization code is required")
                        }</span>

                        <span class="cov0" title="0">err := client.ExchangeCodeForToken(ctx, code)
                        if err != nil </span><span class="cov0" title="0">{
                                return &amp;mcp.CallToolResultFor[ExchangeTokenResult]{
                                        Content: []mcp.Content{
                                                &amp;mcp.TextContent{
                                                        Text: fmt.Sprintf("Failed to exchange code for token: %v", err),
                                                },
                                        },
                                }, nil
                        }</span>

                        <span class="cov0" title="0">return &amp;mcp.CallToolResultFor[ExchangeTokenResult]{
                                Content: []mcp.Content{
                                        &amp;mcp.TextContent{
                                                Text: "Successfully authenticated with Bokio API",
                                        },
                                },
                        }, nil</span>
                },
                mcp.Input(
                        mcp.Property("code",
                                mcp.Description("Authorization code from OAuth2 callback"),
                                mcp.Required(true),
                        ),
                ),
        )
        
        <span class="cov0" title="0">server.AddTools(exchangeTokenTool)

        // Register bokio_get_connections tool
        getConnectionsTool := mcp.NewServerTool[GetConnectionsParams, GetConnectionsResult](
                "bokio_get_connections",
                "Get current connection information including user details and permissions",
                func(ctx context.Context, session *mcp.ServerSession, params *mcp.CallToolParamsFor[GetConnectionsParams]) (*mcp.CallToolResultFor[GetConnectionsResult], error) </span><span class="cov0" title="0">{
                        if !client.IsAuthenticated() </span><span class="cov0" title="0">{
                                return &amp;mcp.CallToolResultFor[GetConnectionsResult]{
                                        Content: []mcp.Content{
                                                &amp;mcp.TextContent{
                                                        Text: "Not authenticated. Use bokio_authenticate first.",
                                                },
                                        },
                                }, nil
                        }</span>

                        // For now, return a placeholder since GetConnectionInfo is not available
                        // This would need to be implemented in the bokio.Client
                        <span class="cov0" title="0">connInfo := struct {
                                UserID      string
                                CompanyID   string
                                CompanyName string
                                Email       string
                                Permissions []string
                        }{
                                UserID:      "user_123",
                                CompanyID:   "company_456", 
                                CompanyName: "Example Company",
                                Email:       "user@example.com",
                                Permissions: []string{"read", "write"},
                        }
                        err := error(nil)
                        if err != nil </span><span class="cov0" title="0">{
                                return &amp;mcp.CallToolResultFor[GetConnectionsResult]{
                                        Content: []mcp.Content{
                                                &amp;mcp.TextContent{
                                                        Text: fmt.Sprintf("Failed to get connection info: %v", err),
                                                },
                                        },
                                }, nil
                        }</span>

                        <span class="cov0" title="0">_ = map[string]interface{}{
                                "user_id":     connInfo.UserID,
                                "company_id":   connInfo.CompanyID,
                                "company_name": connInfo.CompanyName,
                                "email":        connInfo.Email,
                                "permissions":  connInfo.Permissions,
                        }

                        return &amp;mcp.CallToolResultFor[GetConnectionsResult]{
                                Content: []mcp.Content{
                                        &amp;mcp.TextContent{
                                                Text: fmt.Sprintf("Connected to %s (ID: %s) as %s", connInfo.CompanyName, connInfo.CompanyID, connInfo.Email),
                                        },
                                },
                        }, nil</span>
                },
        )
        
        <span class="cov0" title="0">server.AddTools(getConnectionsTool)

        // Register bokio_check_auth tool
        checkAuthTool := mcp.NewServerTool[CheckAuthParams, CheckAuthResult](
                "bokio_check_auth",
                "Check if the client is currently authenticated with valid tokens",
                func(ctx context.Context, session *mcp.ServerSession, params *mcp.CallToolParamsFor[CheckAuthParams]) (*mcp.CallToolResultFor[CheckAuthResult], error) </span><span class="cov0" title="0">{
                        isAuthenticated := client.IsAuthenticated()
                        
                        var message string
                        if isAuthenticated </span><span class="cov0" title="0">{
                                message = "Client is authenticated with valid tokens"
                        }</span> else<span class="cov0" title="0"> {
                                message = "Client is not authenticated. Use bokio_authenticate to authenticate."
                        }</span>

                        <span class="cov0" title="0">return &amp;mcp.CallToolResultFor[CheckAuthResult]{
                                Content: []mcp.Content{
                                        &amp;mcp.TextContent{
                                                Text: message,
                                        },
                                },
                        }, nil</span>
                },
        )
        
        <span class="cov0" title="0">server.AddTools(checkAuthTool)

        return nil</span>
}

</pre>
		
		<pre class="file" id="file9" style="display: none">package tools

import (
        "context"
        "encoding/json"
        "fmt"
        "net/http"
        "strconv"

        "github.com/klowdo/bokio-mcp/bokio"
        "github.com/modelcontextprotocol/go-sdk/mcp"
)

// ListCustomersParams defines the parameters for listing customers
type ListCustomersParams struct {
        Page    *int    `json:"page,omitempty"`
        PerPage *int    `json:"per_page,omitempty"`
        Search  *string `json:"search,omitempty"`
}

// ListCustomersResult defines the result of listing customers
type ListCustomersResult struct {
        Success    bool                   `json:"success"`
        Data       []bokio.Customer       `json:"data,omitempty"`
        Pagination interface{}            `json:"pagination,omitempty"`
        Error      string                 `json:"error,omitempty"`
}

// GetCustomerParams defines the parameters for getting a customer
type GetCustomerParams struct {
        ID string `json:"id"`
}

// GetCustomerResult defines the result of getting a customer
type GetCustomerResult struct {
        Success bool            `json:"success"`
        Data    *bokio.Customer `json:"data,omitempty"`
        Error   string          `json:"error,omitempty"`
}

// CreateCustomerParams defines the parameters for creating a customer
type CreateCustomerParams struct {
        Name               string         `json:"name"`
        Email              *string        `json:"email,omitempty"`
        Phone              *string        `json:"phone,omitempty"`
        OrganizationNumber *string        `json:"organization_number,omitempty"`
        VATNumber          *string        `json:"vat_number,omitempty"`
        Address            *AddressParams `json:"address,omitempty"`
        PaymentTerms       *int           `json:"payment_terms,omitempty"`
}

// AddressParams defines the parameters for an address
type AddressParams struct {
        Street     *string `json:"street,omitempty"`
        PostalCode *string `json:"postal_code,omitempty"`
        City       *string `json:"city,omitempty"`
        Country    *string `json:"country,omitempty"`
}

// CreateCustomerResult defines the result of creating a customer
type CreateCustomerResult struct {
        Success bool            `json:"success"`
        Data    *bokio.Customer `json:"data,omitempty"`
        Message string          `json:"message,omitempty"`
        Error   string          `json:"error,omitempty"`
}

// UpdateCustomerParams defines the parameters for updating a customer
type UpdateCustomerParams struct {
        ID                 string         `json:"id"`
        Name               *string        `json:"name,omitempty"`
        Email              *string        `json:"email,omitempty"`
        Phone              *string        `json:"phone,omitempty"`
        OrganizationNumber *string        `json:"organization_number,omitempty"`
        VATNumber          *string        `json:"vat_number,omitempty"`
        Address            *AddressParams `json:"address,omitempty"`
        PaymentTerms       *int           `json:"payment_terms,omitempty"`
}

// UpdateCustomerResult defines the result of updating a customer
type UpdateCustomerResult struct {
        Success bool            `json:"success"`
        Data    *bokio.Customer `json:"data,omitempty"`
        Message string          `json:"message,omitempty"`
        Error   string          `json:"error,omitempty"`
}

// RegisterCustomerTools registers customer-related MCP tools
func RegisterCustomerTools(server *mcp.Server, client *bokio.Client) error <span class="cov0" title="0">{
        // Register bokio_list_customers tool
        listCustomersTool := mcp.NewServerTool[ListCustomersParams, ListCustomersResult](
                "bokio_list_customers",
                "List customers with optional filtering and pagination",
                func(ctx context.Context, session *mcp.ServerSession, params *mcp.CallToolParamsFor[ListCustomersParams]) (*mcp.CallToolResultFor[ListCustomersResult], error) </span><span class="cov0" title="0">{
                        // Authentication is handled automatically by AuthenticatedGET

                        // Build query parameters
                        queryParams := make(map[string]string)
                        
                        if params.Arguments.Page != nil </span><span class="cov0" title="0">{
                                queryParams["page"] = fmt.Sprintf("%d", *params.Arguments.Page)
                        }</span>
                        
                        <span class="cov0" title="0">if params.Arguments.PerPage != nil </span><span class="cov0" title="0">{
                                queryParams["per_page"] = fmt.Sprintf("%d", *params.Arguments.PerPage)
                        }</span>
                        
                        <span class="cov0" title="0">if params.Arguments.Search != nil &amp;&amp; *params.Arguments.Search != "" </span><span class="cov0" title="0">{
                                queryParams["search"] = *params.Arguments.Search
                        }</span>

                        // Construct URL with query parameters
                        <span class="cov0" title="0">path := "/customers"
                        if len(queryParams) &gt; 0 </span><span class="cov0" title="0">{
                                path += "?"
                                first := true
                                for key, value := range queryParams </span><span class="cov0" title="0">{
                                        if !first </span><span class="cov0" title="0">{
                                                path += "&amp;"
                                        }</span>
                                        <span class="cov0" title="0">path += key + "=" + value
                                        first = false</span>
                                }
                        }

                        <span class="cov0" title="0">resp, err := client.AuthenticatedGET(ctx, path)
                        if err != nil </span><span class="cov0" title="0">{
                                return &amp;mcp.CallToolResultFor[ListCustomersResult]{
                                        Content: []mcp.Content{
                                                &amp;mcp.TextContent{
                                                        Text: fmt.Sprintf("Failed to list customers: %v", err),
                                                },
                                        },
                                }, nil
                        }</span>

                        <span class="cov0" title="0">if resp.StatusCode() != http.StatusOK </span><span class="cov0" title="0">{
                                return &amp;mcp.CallToolResultFor[ListCustomersResult]{
                                        Content: []mcp.Content{
                                                &amp;mcp.TextContent{
                                                        Text: fmt.Sprintf("API error: %d - %s", resp.StatusCode(), resp.String()),
                                                },
                                        },
                                }, nil
                        }</span>

                        <span class="cov0" title="0">var customerList bokio.CustomersResponse
                        if err := json.Unmarshal(resp.Body(), &amp;customerList); err != nil </span><span class="cov0" title="0">{
                                return &amp;mcp.CallToolResultFor[ListCustomersResult]{
                                        Content: []mcp.Content{
                                                &amp;mcp.TextContent{
                                                        Text: fmt.Sprintf("Failed to parse response: %v", err),
                                                },
                                        },
                                }, nil
                        }</span>

                        <span class="cov0" title="0">return &amp;mcp.CallToolResultFor[ListCustomersResult]{
                                Content: []mcp.Content{
                                        &amp;mcp.TextContent{
                                                Text: fmt.Sprintf("Found %d customers", len(customerList.Items)),
                                        },
                                },
                        }, nil</span>
                },
                mcp.Input(
                        mcp.Property("page",
                                mcp.Description("Page number for pagination (default: 1)"),
                        ),
                        mcp.Property("per_page",
                                mcp.Description("Number of items per page (default: 25, max: 100)"),
                        ),
                        mcp.Property("search",
                                mcp.Description("Search customers by name or email"),
                        ),
                ),
        )
        
        <span class="cov0" title="0">server.AddTools(listCustomersTool)

        // Register bokio_get_customer tool
        getCustomerTool := mcp.NewServerTool[GetCustomerParams, GetCustomerResult](
                "bokio_get_customer",
                "Get a specific customer by ID",
                func(ctx context.Context, session *mcp.ServerSession, params *mcp.CallToolParamsFor[GetCustomerParams]) (*mcp.CallToolResultFor[GetCustomerResult], error) </span><span class="cov0" title="0">{
                        // Authentication is handled automatically by AuthenticatedGET

                        id := params.Arguments.ID
                        if id == "" </span><span class="cov0" title="0">{
                                return &amp;mcp.CallToolResultFor[GetCustomerResult]{
                                        Content: []mcp.Content{
                                                &amp;mcp.TextContent{
                                                        Text: "Customer ID is required",
                                                },
                                        },
                                }, fmt.Errorf("customer ID is required")
                        }</span>

                        <span class="cov0" title="0">resp, err := client.AuthenticatedGET(ctx, "/customers/"+id)
                        if err != nil </span><span class="cov0" title="0">{
                                return &amp;mcp.CallToolResultFor[GetCustomerResult]{
                                        Content: []mcp.Content{
                                                &amp;mcp.TextContent{
                                                        Text: fmt.Sprintf("Failed to get customer: %v", err),
                                                },
                                        },
                                }, nil
                        }</span>

                        <span class="cov0" title="0">if resp.StatusCode() == http.StatusNotFound </span><span class="cov0" title="0">{
                                return &amp;mcp.CallToolResultFor[GetCustomerResult]{
                                        Content: []mcp.Content{
                                                &amp;mcp.TextContent{
                                                        Text: "Customer not found",
                                                },
                                        },
                                }, nil
                        }</span>

                        <span class="cov0" title="0">if resp.StatusCode() != http.StatusOK </span><span class="cov0" title="0">{
                                return &amp;mcp.CallToolResultFor[GetCustomerResult]{
                                        Content: []mcp.Content{
                                                &amp;mcp.TextContent{
                                                        Text: fmt.Sprintf("API error: %d - %s", resp.StatusCode(), resp.String()),
                                                },
                                        },
                                }, nil
                        }</span>

                        <span class="cov0" title="0">var customer bokio.Customer
                        if err := json.Unmarshal(resp.Body(), &amp;customer); err != nil </span><span class="cov0" title="0">{
                                return &amp;mcp.CallToolResultFor[GetCustomerResult]{
                                        Content: []mcp.Content{
                                                &amp;mcp.TextContent{
                                                        Text: fmt.Sprintf("Failed to parse response: %v", err),
                                                },
                                        },
                                }, nil
                        }</span>

                        <span class="cov0" title="0">return &amp;mcp.CallToolResultFor[GetCustomerResult]{
                                Content: []mcp.Content{
                                        &amp;mcp.TextContent{
                                                Text: fmt.Sprintf("Customer: %s (ID: %s)", customer.Name, customer.ID),
                                        },
                                },
                        }, nil</span>
                },
                mcp.Input(
                        mcp.Property("id",
                                mcp.Description("Customer ID"),
                                mcp.Required(true),
                        ),
                ),
        )
        
        <span class="cov0" title="0">server.AddTools(getCustomerTool)

        // Register bokio_create_customer tool
        createCustomerTool := mcp.NewServerTool[CreateCustomerParams, CreateCustomerResult](
                "bokio_create_customer",
                "Create a new customer",
                func(ctx context.Context, session *mcp.ServerSession, params *mcp.CallToolParamsFor[CreateCustomerParams]) (*mcp.CallToolResultFor[CreateCustomerResult], error) </span><span class="cov0" title="0">{
                        // Authentication is handled automatically by AuthenticatedPOST

                        // Parse and validate the request
                        request, err := parseCreateCustomerRequestFromParams(params.Arguments)
                        if err != nil </span><span class="cov0" title="0">{
                                return &amp;mcp.CallToolResultFor[CreateCustomerResult]{
                                        Content: []mcp.Content{
                                                &amp;mcp.TextContent{
                                                        Text: fmt.Sprintf("Invalid request: %v", err),
                                                },
                                        },
                                }, fmt.Errorf("invalid request: %w", err)
                        }</span>

                        <span class="cov0" title="0">resp, err := client.AuthenticatedPOST(ctx, "/customers", request)
                        if err != nil </span><span class="cov0" title="0">{
                                return &amp;mcp.CallToolResultFor[CreateCustomerResult]{
                                        Content: []mcp.Content{
                                                &amp;mcp.TextContent{
                                                        Text: fmt.Sprintf("Failed to create customer: %v", err),
                                                },
                                        },
                                }, nil
                        }</span>

                        <span class="cov0" title="0">if resp.StatusCode() != http.StatusCreated &amp;&amp; resp.StatusCode() != http.StatusOK </span><span class="cov0" title="0">{
                                return &amp;mcp.CallToolResultFor[CreateCustomerResult]{
                                        Content: []mcp.Content{
                                                &amp;mcp.TextContent{
                                                        Text: fmt.Sprintf("API error: %d - %s", resp.StatusCode(), resp.String()),
                                                },
                                        },
                                }, nil
                        }</span>

                        <span class="cov0" title="0">var customer bokio.Customer
                        if err := json.Unmarshal(resp.Body(), &amp;customer); err != nil </span><span class="cov0" title="0">{
                                return &amp;mcp.CallToolResultFor[CreateCustomerResult]{
                                        Content: []mcp.Content{
                                                &amp;mcp.TextContent{
                                                        Text: fmt.Sprintf("Failed to parse response: %v", err),
                                                },
                                        },
                                }, nil
                        }</span>

                        <span class="cov0" title="0">return &amp;mcp.CallToolResultFor[CreateCustomerResult]{
                                Content: []mcp.Content{
                                        &amp;mcp.TextContent{
                                                Text: fmt.Sprintf("Customer created successfully: %s (ID: %s)", customer.Name, customer.ID),
                                        },
                                },
                        }, nil</span>
                },
                mcp.Input(
                        mcp.Property("name",
                                mcp.Description("Customer name"),
                                mcp.Required(true),
                        ),
                        mcp.Property("email",
                                mcp.Description("Customer email address"),
                                ),
                        mcp.Property("phone",
                                mcp.Description("Customer phone number"),
                        ),
                        mcp.Property("organization_number",
                                mcp.Description("Organization number"),
                        ),
                        mcp.Property("vat_number",
                                mcp.Description("VAT number"),
                        ),
                        mcp.Property("address",
                                mcp.Description("Customer address"),
                        ),
                        mcp.Property("payment_terms",
                                mcp.Description("Payment terms in days"),
                                ),
                ),
        )
        
        <span class="cov0" title="0">server.AddTools(createCustomerTool)

        // Register bokio_update_customer tool
        updateCustomerTool := mcp.NewServerTool[UpdateCustomerParams, UpdateCustomerResult](
                "bokio_update_customer",
                "Update an existing customer",
                func(ctx context.Context, session *mcp.ServerSession, params *mcp.CallToolParamsFor[UpdateCustomerParams]) (*mcp.CallToolResultFor[UpdateCustomerResult], error) </span><span class="cov0" title="0">{
                        // Authentication is handled automatically by AuthenticatedPATCH

                        id := params.Arguments.ID
                        if id == "" </span><span class="cov0" title="0">{
                                return &amp;mcp.CallToolResultFor[UpdateCustomerResult]{
                                        Content: []mcp.Content{
                                                &amp;mcp.TextContent{
                                                        Text: "Customer ID is required",
                                                },
                                        },
                                }, fmt.Errorf("customer ID is required")
                        }</span>

                        // Parse update request (only include provided fields)
                        <span class="cov0" title="0">updateRequest := buildUpdateCustomerRequest(params.Arguments)

                        resp, err := client.AuthenticatedPATCH(ctx, "/customers/"+id, updateRequest)
                        if err != nil </span><span class="cov0" title="0">{
                                return &amp;mcp.CallToolResultFor[UpdateCustomerResult]{
                                        Content: []mcp.Content{
                                                &amp;mcp.TextContent{
                                                        Text: fmt.Sprintf("Failed to update customer: %v", err),
                                                },
                                        },
                                }, nil
                        }</span>

                        <span class="cov0" title="0">if resp.StatusCode() == http.StatusNotFound </span><span class="cov0" title="0">{
                                return &amp;mcp.CallToolResultFor[UpdateCustomerResult]{
                                        Content: []mcp.Content{
                                                &amp;mcp.TextContent{
                                                        Text: "Customer not found",
                                                },
                                        },
                                }, nil
                        }</span>

                        <span class="cov0" title="0">if resp.StatusCode() != http.StatusOK </span><span class="cov0" title="0">{
                                return &amp;mcp.CallToolResultFor[UpdateCustomerResult]{
                                        Content: []mcp.Content{
                                                &amp;mcp.TextContent{
                                                        Text: fmt.Sprintf("API error: %d - %s", resp.StatusCode(), resp.String()),
                                                },
                                        },
                                }, nil
                        }</span>

                        <span class="cov0" title="0">var customer bokio.Customer
                        if err := json.Unmarshal(resp.Body(), &amp;customer); err != nil </span><span class="cov0" title="0">{
                                return &amp;mcp.CallToolResultFor[UpdateCustomerResult]{
                                        Content: []mcp.Content{
                                                &amp;mcp.TextContent{
                                                        Text: fmt.Sprintf("Failed to parse response: %v", err),
                                                },
                                        },
                                }, nil
                        }</span>

                        <span class="cov0" title="0">return &amp;mcp.CallToolResultFor[UpdateCustomerResult]{
                                Content: []mcp.Content{
                                        &amp;mcp.TextContent{
                                                Text: fmt.Sprintf("Customer updated successfully: %s (ID: %s)", customer.Name, customer.ID),
                                        },
                                },
                        }, nil</span>
                },
                mcp.Input(
                        mcp.Property("id",
                                mcp.Description("Customer ID"),
                                mcp.Required(true),
                        ),
                        mcp.Property("name",
                                mcp.Description("Customer name"),
                        ),
                        mcp.Property("email",
                                mcp.Description("Customer email address"),
                                ),
                        mcp.Property("phone",
                                mcp.Description("Customer phone number"),
                        ),
                        mcp.Property("organization_number",
                                mcp.Description("Organization number"),
                        ),
                        mcp.Property("vat_number",
                                mcp.Description("VAT number"),
                        ),
                        mcp.Property("address",
                                mcp.Description("Customer address"),
                        ),
                        mcp.Property("payment_terms",
                                mcp.Description("Payment terms in days"),
                                ),
                ),
        )
        
        <span class="cov0" title="0">server.AddTools(updateCustomerTool)

        return nil</span>
}





// parseCreateCustomerRequestFromParams parses the new typed parameters into a CreateCustomerRequest
func parseCreateCustomerRequestFromParams(params CreateCustomerParams) (*bokio.CreateCustomerRequest, error) <span class="cov0" title="0">{
        if params.Name == "" </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("customer name is required")
        }</span>

        <span class="cov0" title="0">request := &amp;bokio.CreateCustomerRequest{
                Name: params.Name,
        }

        // Optional fields
        if params.Email != nil </span><span class="cov0" title="0">{
                request.Email = *params.Email
        }</span>

        <span class="cov0" title="0">if params.Phone != nil </span><span class="cov0" title="0">{
                request.Phone = *params.Phone
        }</span>

        <span class="cov0" title="0">if params.OrganizationNumber != nil </span><span class="cov0" title="0">{
                request.OrgNumber = *params.OrganizationNumber
        }</span>

        <span class="cov0" title="0">if params.VATNumber != nil </span><span class="cov0" title="0">{
                request.VatNumber = *params.VATNumber
        }</span>

        <span class="cov0" title="0">if params.PaymentTerms != nil </span><span class="cov0" title="0">{
                request.PaymentTerms = strconv.Itoa(*params.PaymentTerms)
        }</span>

        <span class="cov0" title="0">if params.Address != nil </span><span class="cov0" title="0">{
                address := &amp;bokio.Address{}
                if params.Address.Street != nil </span><span class="cov0" title="0">{
                        address.Line1 = *params.Address.Street
                }</span>
                <span class="cov0" title="0">if params.Address.PostalCode != nil </span><span class="cov0" title="0">{
                        address.PostalCode = *params.Address.PostalCode
                }</span>
                <span class="cov0" title="0">if params.Address.City != nil </span><span class="cov0" title="0">{
                        address.City = *params.Address.City
                }</span>
                <span class="cov0" title="0">if params.Address.Country != nil </span><span class="cov0" title="0">{
                        address.Country = *params.Address.Country
                }</span>
                <span class="cov0" title="0">request.Address = address</span>
        }

        <span class="cov0" title="0">return request, nil</span>
}

// buildUpdateCustomerRequest builds an update request from typed parameters
func buildUpdateCustomerRequest(params UpdateCustomerParams) map[string]interface{} <span class="cov0" title="0">{
        updateRequest := make(map[string]interface{})
        
        if params.Name != nil &amp;&amp; *params.Name != "" </span><span class="cov0" title="0">{
                updateRequest["name"] = *params.Name
        }</span>
        
        <span class="cov0" title="0">if params.Email != nil </span><span class="cov0" title="0">{
                updateRequest["email"] = *params.Email
        }</span>
        
        <span class="cov0" title="0">if params.Phone != nil </span><span class="cov0" title="0">{
                updateRequest["phone"] = *params.Phone
        }</span>
        
        <span class="cov0" title="0">if params.OrganizationNumber != nil </span><span class="cov0" title="0">{
                updateRequest["organization_number"] = *params.OrganizationNumber
        }</span>
        
        <span class="cov0" title="0">if params.VATNumber != nil </span><span class="cov0" title="0">{
                updateRequest["vat_number"] = *params.VATNumber
        }</span>
        
        <span class="cov0" title="0">if params.PaymentTerms != nil </span><span class="cov0" title="0">{
                updateRequest["payment_terms"] = *params.PaymentTerms
        }</span>

        <span class="cov0" title="0">if params.Address != nil </span><span class="cov0" title="0">{
                address := &amp;bokio.Address{}
                if params.Address.Street != nil </span><span class="cov0" title="0">{
                        address.Line1 = *params.Address.Street
                }</span>
                <span class="cov0" title="0">if params.Address.PostalCode != nil </span><span class="cov0" title="0">{
                        address.PostalCode = *params.Address.PostalCode
                }</span>
                <span class="cov0" title="0">if params.Address.City != nil </span><span class="cov0" title="0">{
                        address.City = *params.Address.City
                }</span>
                <span class="cov0" title="0">if params.Address.Country != nil </span><span class="cov0" title="0">{
                        address.Country = *params.Address.Country
                }</span>
                <span class="cov0" title="0">updateRequest["address"] = address</span>
        }

        <span class="cov0" title="0">return updateRequest</span>
}</pre>
		
		<pre class="file" id="file10" style="display: none">package tools

import (
        "context"
        "encoding/json"
        "fmt"
        "net/http"

        "github.com/klowdo/bokio-mcp/bokio"
        "github.com/modelcontextprotocol/go-sdk/mcp"
)

// ListInvoicesParams defines the parameters for listing invoices
type ListInvoicesParams struct {
        Page       *int    `json:"page,omitempty"`
        PerPage    *int    `json:"per_page,omitempty"`
        Status     *string `json:"status,omitempty"`
        CustomerID *string `json:"customer_id,omitempty"`
}

// ListInvoicesResult defines the result of listing invoices
type ListInvoicesResult struct {
        Success    bool                   `json:"success"`
        Data       []bokio.Invoice        `json:"data,omitempty"`
        Pagination interface{}            `json:"pagination,omitempty"`
        Error      string                 `json:"error,omitempty"`
}

// GetInvoiceParams defines the parameters for getting an invoice
type GetInvoiceParams struct {
        ID string `json:"id"`
}

// GetInvoiceResult defines the result of getting an invoice
type GetInvoiceResult struct {
        Success bool           `json:"success"`
        Data    *bokio.Invoice `json:"data,omitempty"`
        Error   string         `json:"error,omitempty"`
}

// InvoiceItemParams defines the parameters for an invoice item
type InvoiceItemParams struct {
        Description string           `json:"description"`
        Quantity    float64          `json:"quantity"`
        UnitPrice   MoneyParams      `json:"unit_price"`
        VATRate     float64          `json:"vat_rate"`
}

// MoneyParams defines the parameters for money values
type MoneyParams struct {
        Amount   float64 `json:"amount"`
        Currency *string `json:"currency,omitempty"`
}

// CreateInvoiceParams defines the parameters for creating an invoice
type CreateInvoiceParams struct {
        CustomerID  string              `json:"customer_id"`
        Date        *string             `json:"date,omitempty"`
        DueDate     *string             `json:"due_date,omitempty"`
        Description *string             `json:"description,omitempty"`
        Items       []InvoiceItemParams `json:"items"`
}

// CreateInvoiceResult defines the result of creating an invoice
type CreateInvoiceResult struct {
        Success bool           `json:"success"`
        Data    *bokio.Invoice `json:"data,omitempty"`
        Message string         `json:"message,omitempty"`
        Error   string         `json:"error,omitempty"`
}

// UpdateInvoiceParams defines the parameters for updating an invoice
type UpdateInvoiceParams struct {
        ID          string  `json:"id"`
        CustomerID  *string `json:"customer_id,omitempty"`
        Date        *string `json:"date,omitempty"`
        DueDate     *string `json:"due_date,omitempty"`
        Description *string `json:"description,omitempty"`
}

// UpdateInvoiceResult defines the result of updating an invoice
type UpdateInvoiceResult struct {
        Success bool           `json:"success"`
        Data    *bokio.Invoice `json:"data,omitempty"`
        Message string         `json:"message,omitempty"`
        Error   string         `json:"error,omitempty"`
}

// RegisterInvoiceTools registers invoice-related MCP tools
func RegisterInvoiceTools(server *mcp.Server, client *bokio.Client) error <span class="cov0" title="0">{
        // Register bokio_list_invoices tool
        listInvoicesTool := mcp.NewServerTool[ListInvoicesParams, ListInvoicesResult](
                "bokio_list_invoices",
                "List invoices with optional filtering and pagination",
                func(ctx context.Context, session *mcp.ServerSession, params *mcp.CallToolParamsFor[ListInvoicesParams]) (*mcp.CallToolResultFor[ListInvoicesResult], error) </span><span class="cov0" title="0">{
                        // Build query parameters
                        queryParams := make(map[string]string)
                        
                        if params.Arguments.Page != nil </span><span class="cov0" title="0">{
                                queryParams["page"] = fmt.Sprintf("%d", *params.Arguments.Page)
                        }</span>
                        
                        <span class="cov0" title="0">if params.Arguments.PerPage != nil </span><span class="cov0" title="0">{
                                queryParams["per_page"] = fmt.Sprintf("%d", *params.Arguments.PerPage)
                        }</span>
                        
                        <span class="cov0" title="0">if params.Arguments.Status != nil &amp;&amp; *params.Arguments.Status != "" </span><span class="cov0" title="0">{
                                queryParams["status"] = *params.Arguments.Status
                        }</span>
                        
                        <span class="cov0" title="0">if params.Arguments.CustomerID != nil &amp;&amp; *params.Arguments.CustomerID != "" </span><span class="cov0" title="0">{
                                queryParams["customer_id"] = *params.Arguments.CustomerID
                        }</span>

                        // Construct URL with query parameters
                        <span class="cov0" title="0">path := "/invoices"
                        if len(queryParams) &gt; 0 </span><span class="cov0" title="0">{
                                path += "?"
                                first := true
                                for key, value := range queryParams </span><span class="cov0" title="0">{
                                        if !first </span><span class="cov0" title="0">{
                                                path += "&amp;"
                                        }</span>
                                        <span class="cov0" title="0">path += key + "=" + value
                                        first = false</span>
                                }
                        }

                        // Use authenticated request which handles authentication automatically
                        <span class="cov0" title="0">resp, err := client.AuthenticatedGET(ctx, path)
                        if err != nil </span><span class="cov0" title="0">{
                                return &amp;mcp.CallToolResultFor[ListInvoicesResult]{
                                        Content: []mcp.Content{
                                                &amp;mcp.TextContent{
                                                        Text: fmt.Sprintf("Failed to list invoices: %v", err),
                                                },
                                        },
                                }, nil
                        }</span>

                        <span class="cov0" title="0">if resp.StatusCode() != http.StatusOK </span><span class="cov0" title="0">{
                                return &amp;mcp.CallToolResultFor[ListInvoicesResult]{
                                        Content: []mcp.Content{
                                                &amp;mcp.TextContent{
                                                        Text: fmt.Sprintf("API error: %d - %s", resp.StatusCode(), resp.String()),
                                                },
                                        },
                                }, nil
                        }</span>

                        <span class="cov0" title="0">var invoiceList bokio.InvoicesResponse
                        if err := json.Unmarshal(resp.Body(), &amp;invoiceList); err != nil </span><span class="cov0" title="0">{
                                return &amp;mcp.CallToolResultFor[ListInvoicesResult]{
                                        Content: []mcp.Content{
                                                &amp;mcp.TextContent{
                                                        Text: fmt.Sprintf("Failed to parse response: %v", err),
                                                },
                                        },
                                }, nil
                        }</span>

                        <span class="cov0" title="0">return &amp;mcp.CallToolResultFor[ListInvoicesResult]{
                                Content: []mcp.Content{
                                        &amp;mcp.TextContent{
                                                Text: fmt.Sprintf("Found %d invoices", len(invoiceList.Items)),
                                        },
                                },
                        }, nil</span>
                },
                mcp.Input(
                        mcp.Property("page",
                                mcp.Description("Page number for pagination (default: 1)"),
                                ),
                        mcp.Property("per_page",
                                mcp.Description("Number of items per page (default: 25, max: 100)"),
                                        ),
                        mcp.Property("status",
                                mcp.Description("Filter by invoice status"),
                                        ),
                        mcp.Property("customer_id",
                                mcp.Description("Filter by customer ID"),
                        ),
                ),
        )
        
        <span class="cov0" title="0">server.AddTools(listInvoicesTool)

        // Register bokio_get_invoice tool
        getInvoiceTool := mcp.NewServerTool[GetInvoiceParams, GetInvoiceResult](
                "bokio_get_invoice",
                "Get a specific invoice by ID",
                func(ctx context.Context, session *mcp.ServerSession, params *mcp.CallToolParamsFor[GetInvoiceParams]) (*mcp.CallToolResultFor[GetInvoiceResult], error) </span><span class="cov0" title="0">{
                        id := params.Arguments.ID
                        if id == "" </span><span class="cov0" title="0">{
                                return &amp;mcp.CallToolResultFor[GetInvoiceResult]{
                                        Content: []mcp.Content{
                                                &amp;mcp.TextContent{
                                                        Text: "Invoice ID is required",
                                                },
                                        },
                                }, fmt.Errorf("invoice ID is required")
                        }</span>

                        // Use authenticated request which handles authentication automatically
                        <span class="cov0" title="0">resp, err := client.AuthenticatedGET(ctx, "/invoices/"+id)
                        if err != nil </span><span class="cov0" title="0">{
                                return &amp;mcp.CallToolResultFor[GetInvoiceResult]{
                                        Content: []mcp.Content{
                                                &amp;mcp.TextContent{
                                                        Text: fmt.Sprintf("Failed to get invoice: %v", err),
                                                },
                                        },
                                }, nil
                        }</span>

                        <span class="cov0" title="0">if resp.StatusCode() == http.StatusNotFound </span><span class="cov0" title="0">{
                                return &amp;mcp.CallToolResultFor[GetInvoiceResult]{
                                        Content: []mcp.Content{
                                                &amp;mcp.TextContent{
                                                        Text: "Invoice not found",
                                                },
                                        },
                                }, nil
                        }</span>

                        <span class="cov0" title="0">if resp.StatusCode() != http.StatusOK </span><span class="cov0" title="0">{
                                return &amp;mcp.CallToolResultFor[GetInvoiceResult]{
                                        Content: []mcp.Content{
                                                &amp;mcp.TextContent{
                                                        Text: fmt.Sprintf("API error: %d - %s", resp.StatusCode(), resp.String()),
                                                },
                                        },
                                }, nil
                        }</span>

                        <span class="cov0" title="0">var invoice bokio.Invoice
                        if err := json.Unmarshal(resp.Body(), &amp;invoice); err != nil </span><span class="cov0" title="0">{
                                return &amp;mcp.CallToolResultFor[GetInvoiceResult]{
                                        Content: []mcp.Content{
                                                &amp;mcp.TextContent{
                                                        Text: fmt.Sprintf("Failed to parse response: %v", err),
                                                },
                                        },
                                }, nil
                        }</span>

                        <span class="cov0" title="0">return &amp;mcp.CallToolResultFor[GetInvoiceResult]{
                                Content: []mcp.Content{
                                        &amp;mcp.TextContent{
                                                Text: fmt.Sprintf("Invoice: %s (ID: %s)", invoice.InvoiceNumber, invoice.ID),
                                        },
                                },
                        }, nil</span>
                },
                mcp.Input(
                        mcp.Property("id",
                                mcp.Description("Invoice ID"),
                                mcp.Required(true),
                        ),
                ),
        )
        
        <span class="cov0" title="0">server.AddTools(getInvoiceTool)

        // Register bokio_create_invoice tool
        createInvoiceTool := mcp.NewServerTool[CreateInvoiceParams, CreateInvoiceResult](
                "bokio_create_invoice",
                "Create a new invoice",
                func(ctx context.Context, session *mcp.ServerSession, params *mcp.CallToolParamsFor[CreateInvoiceParams]) (*mcp.CallToolResultFor[CreateInvoiceResult], error) </span><span class="cov0" title="0">{
                        // Authentication is handled automatically by AuthenticatedPOST

                        // Parse and validate the request
                        request, err := parseCreateInvoiceRequestFromParams(params.Arguments)
                        if err != nil </span><span class="cov0" title="0">{
                                return &amp;mcp.CallToolResultFor[CreateInvoiceResult]{
                                        Content: []mcp.Content{
                                                &amp;mcp.TextContent{
                                                        Text: fmt.Sprintf("Invalid request: %v", err),
                                                },
                                        },
                                }, fmt.Errorf("invalid request: %w", err)
                        }</span>

                        <span class="cov0" title="0">resp, err := client.AuthenticatedPOST(ctx, "/invoices", request)
                        if err != nil </span><span class="cov0" title="0">{
                                return &amp;mcp.CallToolResultFor[CreateInvoiceResult]{
                                        Content: []mcp.Content{
                                                &amp;mcp.TextContent{
                                                        Text: fmt.Sprintf("Failed to create invoice: %v", err),
                                                },
                                        },
                                }, nil
                        }</span>

                        <span class="cov0" title="0">if resp.StatusCode() != http.StatusCreated &amp;&amp; resp.StatusCode() != http.StatusOK </span><span class="cov0" title="0">{
                                return &amp;mcp.CallToolResultFor[CreateInvoiceResult]{
                                        Content: []mcp.Content{
                                                &amp;mcp.TextContent{
                                                        Text: fmt.Sprintf("API error: %d - %s", resp.StatusCode(), resp.String()),
                                                },
                                        },
                                }, nil
                        }</span>

                        <span class="cov0" title="0">var invoice bokio.Invoice
                        if err := json.Unmarshal(resp.Body(), &amp;invoice); err != nil </span><span class="cov0" title="0">{
                                return &amp;mcp.CallToolResultFor[CreateInvoiceResult]{
                                        Content: []mcp.Content{
                                                &amp;mcp.TextContent{
                                                        Text: fmt.Sprintf("Failed to parse response: %v", err),
                                                },
                                        },
                                }, nil
                        }</span>

                        <span class="cov0" title="0">return &amp;mcp.CallToolResultFor[CreateInvoiceResult]{
                                Content: []mcp.Content{
                                        &amp;mcp.TextContent{
                                                Text: fmt.Sprintf("Invoice created successfully: %s (ID: %s)", invoice.InvoiceNumber, invoice.ID),
                                        },
                                },
                        }, nil</span>
                },
                mcp.Input(
                        mcp.Property("customer_id",
                                mcp.Description("ID of the customer"),
                                mcp.Required(true),
                        ),
                        mcp.Property("date",
                                mcp.Description("Invoice date (YYYY-MM-DD)"),
                                        ),
                        mcp.Property("due_date",
                                mcp.Description("Due date (YYYY-MM-DD)"),
                                        ),
                        mcp.Property("description",
                                mcp.Description("Invoice description"),
                        ),
                        mcp.Property("items",
                                mcp.Description("Invoice line items"),
                                mcp.Required(true),
                        ),
                ),
        )
        
        <span class="cov0" title="0">server.AddTools(createInvoiceTool)

        // Register bokio_update_invoice tool
        updateInvoiceTool := mcp.NewServerTool[UpdateInvoiceParams, UpdateInvoiceResult](
                "bokio_update_invoice",
                "Update an existing invoice",
                func(ctx context.Context, session *mcp.ServerSession, params *mcp.CallToolParamsFor[UpdateInvoiceParams]) (*mcp.CallToolResultFor[UpdateInvoiceResult], error) </span><span class="cov0" title="0">{
                        // Authentication is handled automatically by AuthenticatedPUT

                        id := params.Arguments.ID
                        if id == "" </span><span class="cov0" title="0">{
                                return &amp;mcp.CallToolResultFor[UpdateInvoiceResult]{
                                        Content: []mcp.Content{
                                                &amp;mcp.TextContent{
                                                        Text: "Invoice ID is required",
                                                },
                                        },
                                }, fmt.Errorf("invoice ID is required")
                        }</span>

                        // Parse update request (only include non-nil fields)
                        <span class="cov0" title="0">updateRequest := buildUpdateInvoiceRequest(params.Arguments)

                        resp, err := client.AuthenticatedPATCH(ctx, "/invoices/"+id, updateRequest)
                        if err != nil </span><span class="cov0" title="0">{
                                return &amp;mcp.CallToolResultFor[UpdateInvoiceResult]{
                                        Content: []mcp.Content{
                                                &amp;mcp.TextContent{
                                                        Text: fmt.Sprintf("Failed to update invoice: %v", err),
                                                },
                                        },
                                }, nil
                        }</span>

                        <span class="cov0" title="0">if resp.StatusCode() == http.StatusNotFound </span><span class="cov0" title="0">{
                                return &amp;mcp.CallToolResultFor[UpdateInvoiceResult]{
                                        Content: []mcp.Content{
                                                &amp;mcp.TextContent{
                                                        Text: "Invoice not found",
                                                },
                                        },
                                }, nil
                        }</span>

                        <span class="cov0" title="0">if resp.StatusCode() != http.StatusOK </span><span class="cov0" title="0">{
                                return &amp;mcp.CallToolResultFor[UpdateInvoiceResult]{
                                        Content: []mcp.Content{
                                                &amp;mcp.TextContent{
                                                        Text: fmt.Sprintf("API error: %d - %s", resp.StatusCode(), resp.String()),
                                                },
                                        },
                                }, nil
                        }</span>

                        <span class="cov0" title="0">var invoice bokio.Invoice
                        if err := json.Unmarshal(resp.Body(), &amp;invoice); err != nil </span><span class="cov0" title="0">{
                                return &amp;mcp.CallToolResultFor[UpdateInvoiceResult]{
                                        Content: []mcp.Content{
                                                &amp;mcp.TextContent{
                                                        Text: fmt.Sprintf("Failed to parse response: %v", err),
                                                },
                                        },
                                }, nil
                        }</span>

                        <span class="cov0" title="0">return &amp;mcp.CallToolResultFor[UpdateInvoiceResult]{
                                Content: []mcp.Content{
                                        &amp;mcp.TextContent{
                                                Text: fmt.Sprintf("Invoice updated successfully: %s (ID: %s)", invoice.InvoiceNumber, invoice.ID),
                                        },
                                },
                        }, nil</span>
                },
                mcp.Input(
                        mcp.Property("id",
                                mcp.Description("Invoice ID"),
                                mcp.Required(true),
                        ),
                        mcp.Property("customer_id",
                                mcp.Description("ID of the customer"),
                        ),
                        mcp.Property("date",
                                mcp.Description("Invoice date (YYYY-MM-DD)"),
                                        ),
                        mcp.Property("due_date",
                                mcp.Description("Due date (YYYY-MM-DD)"),
                                        ),
                        mcp.Property("description",
                                mcp.Description("Invoice description"),
                        ),
                ),
        )
        
        <span class="cov0" title="0">server.AddTools(updateInvoiceTool)

        return nil</span>
}





// parseCreateInvoiceRequestFromParams parses the new typed parameters into a CreateInvoiceRequest
func parseCreateInvoiceRequestFromParams(params CreateInvoiceParams) (*bokio.CreateInvoiceRequest, error) <span class="cov0" title="0">{
        if params.CustomerID == "" </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("customer_id is required")
        }</span>

        <span class="cov0" title="0">if len(params.Items) == 0 </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("items are required")
        }</span>

        <span class="cov0" title="0">items := make([]bokio.InvoiceItem, len(params.Items))
        for i, item := range params.Items </span><span class="cov0" title="0">{
                if item.Description == "" </span><span class="cov0" title="0">{
                        return nil, fmt.Errorf("item description is required at index %d", i)
                }</span>

                <span class="cov0" title="0">items[i] = bokio.InvoiceItem{
                        Description: item.Description,
                        Quantity:    item.Quantity,
                        Price:       item.UnitPrice.Amount,
                        VatRate:     item.VATRate,
                }</span>
        }

        <span class="cov0" title="0">request := &amp;bokio.CreateInvoiceRequest{
                CustomerID: params.CustomerID,
                Items:      items,
        }

        // Optional fields
        if params.Date != nil </span>{<span class="cov0" title="0">
                // In a real implementation, parse the date string to time.Time
                // For now, we'll leave it as nil and let the API handle it
        }</span>

        <span class="cov0" title="0">if params.DueDate != nil </span>{<span class="cov0" title="0">
                // In a real implementation, parse the date string to time.Time
                // For now, we'll leave it as nil and let the API handle it
        }</span>

        <span class="cov0" title="0">if params.Description != nil </span><span class="cov0" title="0">{
                request.Notes = *params.Description
        }</span>

        <span class="cov0" title="0">return request, nil</span>
}

// buildUpdateInvoiceRequest builds an update request from typed parameters
func buildUpdateInvoiceRequest(params UpdateInvoiceParams) map[string]interface{} <span class="cov0" title="0">{
        updateRequest := make(map[string]interface{})
        
        if params.CustomerID != nil &amp;&amp; *params.CustomerID != "" </span><span class="cov0" title="0">{
                updateRequest["customer_id"] = *params.CustomerID
        }</span>
        
        <span class="cov0" title="0">if params.Date != nil &amp;&amp; *params.Date != "" </span><span class="cov0" title="0">{
                updateRequest["date"] = *params.Date
        }</span>
        
        <span class="cov0" title="0">if params.DueDate != nil &amp;&amp; *params.DueDate != "" </span><span class="cov0" title="0">{
                updateRequest["due_date"] = *params.DueDate
        }</span>
        
        <span class="cov0" title="0">if params.Description != nil </span><span class="cov0" title="0">{
                updateRequest["description"] = *params.Description
        }</span>

        <span class="cov0" title="0">return updateRequest</span>
}</pre>
		
		<pre class="file" id="file11" style="display: none">package tools

import (
        "context"
        "encoding/json"
        "fmt"
        "net/http"
        "strconv"

        "github.com/klowdo/bokio-mcp/bokio"
        "github.com/modelcontextprotocol/go-sdk/mcp"
)

// ListJournalEntriesParams defines the parameters for listing journal entries
type ListJournalEntriesParams struct {
        Page        *int    `json:"page,omitempty"`
        PerPage     *int    `json:"per_page,omitempty"`
        FromDate    *string `json:"from_date,omitempty"`
        ToDate      *string `json:"to_date,omitempty"`
        AccountCode *string `json:"account_code,omitempty"`
}

// ListJournalEntriesResult defines the result of listing journal entries
type ListJournalEntriesResult struct {
        Success    bool                     `json:"success"`
        Data       []bokio.JournalEntry     `json:"data,omitempty"`
        Pagination interface{}              `json:"pagination,omitempty"`
        Error      string                   `json:"error,omitempty"`
}

// JournalEntryLineParams defines the parameters for a journal entry line
type JournalEntryLineParams struct {
        AccountCode string           `json:"account_code"`
        Description *string          `json:"description,omitempty"`
        Debit       *MoneyParams     `json:"debit,omitempty"`
        Credit      *MoneyParams     `json:"credit,omitempty"`
}

// CreateJournalEntryParams defines the parameters for creating a journal entry
type CreateJournalEntryParams struct {
        Date        string                    `json:"date"`
        Description string                    `json:"description"`
        Reference   *string                   `json:"reference,omitempty"`
        Lines       []JournalEntryLineParams  `json:"lines"`
}

// CreateJournalEntryResult defines the result of creating a journal entry
type CreateJournalEntryResult struct {
        Success bool                 `json:"success"`
        Data    *bokio.JournalEntry  `json:"data,omitempty"`
        Message string               `json:"message,omitempty"`
        Error   string               `json:"error,omitempty"`
}

// ReverseJournalEntryParams defines the parameters for reversing a journal entry
type ReverseJournalEntryParams struct {
        ID          string  `json:"id"`
        Date        string  `json:"date"`
        Description *string `json:"description,omitempty"`
}

// ReverseJournalEntryResult defines the result of reversing a journal entry
type ReverseJournalEntryResult struct {
        Success bool                 `json:"success"`
        Data    *bokio.JournalEntry  `json:"data,omitempty"`
        Message string               `json:"message,omitempty"`
        Error   string               `json:"error,omitempty"`
}

// GetAccountsParams defines the parameters for getting accounts
type GetAccountsParams struct {
        Type *string `json:"type,omitempty"`
}

// GetAccountsResult defines the result of getting accounts
type GetAccountsResult struct {
        Success bool             `json:"success"`
        Data    []bokio.Account  `json:"data,omitempty"`
        Error   string           `json:"error,omitempty"`
}

// RegisterJournalTools registers journal entry-related MCP tools
func RegisterJournalTools(server *mcp.Server, client *bokio.Client) error <span class="cov0" title="0">{
        // Register bokio_list_journal_entries tool
        listJournalEntriesTool := mcp.NewServerTool[ListJournalEntriesParams, ListJournalEntriesResult](
                "bokio_list_journal_entries",
                "List journal entries with optional filtering and pagination",
                func(ctx context.Context, session *mcp.ServerSession, params *mcp.CallToolParamsFor[ListJournalEntriesParams]) (*mcp.CallToolResultFor[ListJournalEntriesResult], error) </span><span class="cov0" title="0">{
                        // Authentication is handled automatically by AuthenticatedGET

                        // Build query parameters
                        queryParams := make(map[string]string)
                        
                        if params.Arguments.Page != nil </span><span class="cov0" title="0">{
                                queryParams["page"] = fmt.Sprintf("%d", *params.Arguments.Page)
                        }</span>
                        
                        <span class="cov0" title="0">if params.Arguments.PerPage != nil </span><span class="cov0" title="0">{
                                queryParams["per_page"] = fmt.Sprintf("%d", *params.Arguments.PerPage)
                        }</span>
                        
                        <span class="cov0" title="0">if params.Arguments.FromDate != nil &amp;&amp; *params.Arguments.FromDate != "" </span><span class="cov0" title="0">{
                                queryParams["from_date"] = *params.Arguments.FromDate
                        }</span>
                        
                        <span class="cov0" title="0">if params.Arguments.ToDate != nil &amp;&amp; *params.Arguments.ToDate != "" </span><span class="cov0" title="0">{
                                queryParams["to_date"] = *params.Arguments.ToDate
                        }</span>
                        
                        <span class="cov0" title="0">if params.Arguments.AccountCode != nil &amp;&amp; *params.Arguments.AccountCode != "" </span><span class="cov0" title="0">{
                                queryParams["account_code"] = *params.Arguments.AccountCode
                        }</span>

                        // Construct URL with query parameters
                        <span class="cov0" title="0">path := "/journal-entries"
                        if len(queryParams) &gt; 0 </span><span class="cov0" title="0">{
                                path += "?"
                                first := true
                                for key, value := range queryParams </span><span class="cov0" title="0">{
                                        if !first </span><span class="cov0" title="0">{
                                                path += "&amp;"
                                        }</span>
                                        <span class="cov0" title="0">path += key + "=" + value
                                        first = false</span>
                                }
                        }

                        <span class="cov0" title="0">resp, err := client.AuthenticatedGET(ctx, path)
                        if err != nil </span><span class="cov0" title="0">{
                                return &amp;mcp.CallToolResultFor[ListJournalEntriesResult]{
                                        Content: []mcp.Content{
                                                &amp;mcp.TextContent{
                                                        Text: fmt.Sprintf("Failed to list journal entries: %v", err),
                                                },
                                        },
                                }, nil
                        }</span>

                        <span class="cov0" title="0">if resp.StatusCode() != http.StatusOK </span><span class="cov0" title="0">{
                                return &amp;mcp.CallToolResultFor[ListJournalEntriesResult]{
                                        Content: []mcp.Content{
                                                &amp;mcp.TextContent{
                                                        Text: fmt.Sprintf("API error: %d - %s", resp.StatusCode(), resp.String()),
                                                },
                                        },
                                }, nil
                        }</span>

                        <span class="cov0" title="0">var journalEntries bokio.JournalEntriesResponse
                        if err := json.Unmarshal(resp.Body(), &amp;journalEntries); err != nil </span><span class="cov0" title="0">{
                                return &amp;mcp.CallToolResultFor[ListJournalEntriesResult]{
                                        Content: []mcp.Content{
                                                &amp;mcp.TextContent{
                                                        Text: fmt.Sprintf("Failed to parse response: %v", err),
                                                },
                                        },
                                }, nil
                        }</span>

                        <span class="cov0" title="0">return &amp;mcp.CallToolResultFor[ListJournalEntriesResult]{
                                Content: []mcp.Content{
                                        &amp;mcp.TextContent{
                                                Text: fmt.Sprintf("Found %d journal entries", len(journalEntries.Items)),
                                        },
                                },
                        }, nil</span>
                },
                mcp.Input(
                        mcp.Property("page",
                                mcp.Description("Page number for pagination (default: 1)"),
                                        ),
                        mcp.Property("per_page",
                                mcp.Description("Number of items per page (default: 25, max: 100)"),
                                                        ),
                        mcp.Property("from_date",
                                mcp.Description("Filter entries from this date (YYYY-MM-DD)"),
                                        ),
                        mcp.Property("to_date",
                                mcp.Description("Filter entries to this date (YYYY-MM-DD)"),
                                        ),
                        mcp.Property("account_code",
                                mcp.Description("Filter by account code"),
                        ),
                ),
        )
        
        <span class="cov0" title="0">server.AddTools(listJournalEntriesTool)

        // Register bokio_create_journal_entry tool
        createJournalEntryTool := mcp.NewServerTool[CreateJournalEntryParams, CreateJournalEntryResult](
                "bokio_create_journal_entry",
                "Create a new journal entry with debit and credit lines",
                func(ctx context.Context, session *mcp.ServerSession, params *mcp.CallToolParamsFor[CreateJournalEntryParams]) (*mcp.CallToolResultFor[CreateJournalEntryResult], error) </span><span class="cov0" title="0">{
                        // Authentication is handled automatically by AuthenticatedPOST

                        // Parse and validate the request
                        request, err := parseCreateJournalEntryRequestFromParams(params.Arguments)
                        if err != nil </span><span class="cov0" title="0">{
                                return &amp;mcp.CallToolResultFor[CreateJournalEntryResult]{
                                        Content: []mcp.Content{
                                                &amp;mcp.TextContent{
                                                        Text: fmt.Sprintf("Invalid request: %v", err),
                                                },
                                        },
                                }, fmt.Errorf("invalid request: %w", err)
                        }</span>

                        // Validate that the entry balances
                        <span class="cov0" title="0">if err := validateJournalEntryBalanceFromTyped(request); err != nil </span><span class="cov0" title="0">{
                                return &amp;mcp.CallToolResultFor[CreateJournalEntryResult]{
                                        Content: []mcp.Content{
                                                &amp;mcp.TextContent{
                                                        Text: fmt.Sprintf("Journal entry validation failed: %v", err),
                                                },
                                        },
                                }, nil
                        }</span>

                        <span class="cov0" title="0">resp, err := client.AuthenticatedPOST(ctx, "/journal-entries", request)
                        if err != nil </span><span class="cov0" title="0">{
                                return &amp;mcp.CallToolResultFor[CreateJournalEntryResult]{
                                        Content: []mcp.Content{
                                                &amp;mcp.TextContent{
                                                        Text: fmt.Sprintf("Failed to create journal entry: %v", err),
                                                },
                                        },
                                }, nil
                        }</span>

                        <span class="cov0" title="0">if resp.StatusCode() != http.StatusCreated &amp;&amp; resp.StatusCode() != http.StatusOK </span><span class="cov0" title="0">{
                                return &amp;mcp.CallToolResultFor[CreateJournalEntryResult]{
                                        Content: []mcp.Content{
                                                &amp;mcp.TextContent{
                                                        Text: fmt.Sprintf("API error: %d - %s", resp.StatusCode(), resp.String()),
                                                },
                                        },
                                }, nil
                        }</span>

                        <span class="cov0" title="0">var journalEntry bokio.JournalEntry
                        if err := json.Unmarshal(resp.Body(), &amp;journalEntry); err != nil </span><span class="cov0" title="0">{
                                return &amp;mcp.CallToolResultFor[CreateJournalEntryResult]{
                                        Content: []mcp.Content{
                                                &amp;mcp.TextContent{
                                                        Text: fmt.Sprintf("Failed to parse response: %v", err),
                                                },
                                        },
                                }, nil
                        }</span>

                        <span class="cov0" title="0">return &amp;mcp.CallToolResultFor[CreateJournalEntryResult]{
                                Content: []mcp.Content{
                                        &amp;mcp.TextContent{
                                                Text: fmt.Sprintf("Journal entry created successfully: %s (ID: %s)", journalEntry.Title, journalEntry.ID),
                                        },
                                },
                        }, nil</span>
                },
                mcp.Input(
                        mcp.Property("date",
                                mcp.Description("Journal entry date (YYYY-MM-DD)"),
                                                mcp.Required(true),
                        ),
                        mcp.Property("description",
                                mcp.Description("Journal entry description"),
                                mcp.Required(true),
                        ),
                        mcp.Property("reference",
                                mcp.Description("Optional reference number"),
                        ),
                        mcp.Property("lines",
                                mcp.Description("Journal entry lines (must balance, minimum 2)"),
                                mcp.Required(true),
                        ),
                ),
        )
        
        <span class="cov0" title="0">server.AddTools(createJournalEntryTool)

        // Register bokio_reverse_journal_entry tool
        reverseJournalEntryTool := mcp.NewServerTool[ReverseJournalEntryParams, ReverseJournalEntryResult](
                "bokio_reverse_journal_entry",
                "Create a reversing journal entry for an existing entry",
                func(ctx context.Context, session *mcp.ServerSession, params *mcp.CallToolParamsFor[ReverseJournalEntryParams]) (*mcp.CallToolResultFor[ReverseJournalEntryResult], error) </span><span class="cov0" title="0">{
                        // Authentication is handled automatically by AuthenticatedPOST

                        id := params.Arguments.ID
                        if id == "" </span><span class="cov0" title="0">{
                                return &amp;mcp.CallToolResultFor[ReverseJournalEntryResult]{
                                        Content: []mcp.Content{
                                                &amp;mcp.TextContent{
                                                        Text: "Journal entry ID is required",
                                                },
                                        },
                                }, fmt.Errorf("journal entry ID is required")
                        }</span>

                        <span class="cov0" title="0">date := params.Arguments.Date
                        if date == "" </span><span class="cov0" title="0">{
                                return &amp;mcp.CallToolResultFor[ReverseJournalEntryResult]{
                                        Content: []mcp.Content{
                                                &amp;mcp.TextContent{
                                                        Text: "Reversal date is required",
                                                },
                                        },
                                }, fmt.Errorf("reversal date is required")
                        }</span>

                        <span class="cov0" title="0">reversalRequest := map[string]interface{}{
                                "date": date,
                        }

                        if params.Arguments.Description != nil &amp;&amp; *params.Arguments.Description != "" </span><span class="cov0" title="0">{
                                reversalRequest["description"] = *params.Arguments.Description
                        }</span>

                        <span class="cov0" title="0">resp, err := client.AuthenticatedPOST(ctx, "/journal-entries/"+id+"/reverse", reversalRequest)
                        if err != nil </span><span class="cov0" title="0">{
                                return &amp;mcp.CallToolResultFor[ReverseJournalEntryResult]{
                                        Content: []mcp.Content{
                                                &amp;mcp.TextContent{
                                                        Text: fmt.Sprintf("Failed to reverse journal entry: %v", err),
                                                },
                                        },
                                }, nil
                        }</span>

                        <span class="cov0" title="0">if resp.StatusCode() == http.StatusNotFound </span><span class="cov0" title="0">{
                                return &amp;mcp.CallToolResultFor[ReverseJournalEntryResult]{
                                        Content: []mcp.Content{
                                                &amp;mcp.TextContent{
                                                        Text: "Journal entry not found",
                                                },
                                        },
                                }, nil
                        }</span>

                        <span class="cov0" title="0">if resp.StatusCode() != http.StatusCreated &amp;&amp; resp.StatusCode() != http.StatusOK </span><span class="cov0" title="0">{
                                return &amp;mcp.CallToolResultFor[ReverseJournalEntryResult]{
                                        Content: []mcp.Content{
                                                &amp;mcp.TextContent{
                                                        Text: fmt.Sprintf("API error: %d - %s", resp.StatusCode(), resp.String()),
                                                },
                                        },
                                }, nil
                        }</span>

                        <span class="cov0" title="0">var journalEntry bokio.JournalEntry
                        if err := json.Unmarshal(resp.Body(), &amp;journalEntry); err != nil </span><span class="cov0" title="0">{
                                return &amp;mcp.CallToolResultFor[ReverseJournalEntryResult]{
                                        Content: []mcp.Content{
                                                &amp;mcp.TextContent{
                                                        Text: fmt.Sprintf("Failed to parse response: %v", err),
                                                },
                                        },
                                }, nil
                        }</span>

                        <span class="cov0" title="0">return &amp;mcp.CallToolResultFor[ReverseJournalEntryResult]{
                                Content: []mcp.Content{
                                        &amp;mcp.TextContent{
                                                Text: fmt.Sprintf("Journal entry reversed successfully: %s (ID: %s)", journalEntry.Title, journalEntry.ID),
                                        },
                                },
                        }, nil</span>
                },
                mcp.Input(
                        mcp.Property("id",
                                mcp.Description("Original journal entry ID to reverse"),
                                mcp.Required(true),
                        ),
                        mcp.Property("date",
                                mcp.Description("Date for the reversing entry (YYYY-MM-DD)"),
                                                mcp.Required(true),
                        ),
                        mcp.Property("description",
                                mcp.Description("Optional description for the reversing entry"),
                        ),
                ),
        )
        
        <span class="cov0" title="0">server.AddTools(reverseJournalEntryTool)

        // Register bokio_get_accounts tool
        getAccountsTool := mcp.NewServerTool[GetAccountsParams, GetAccountsResult](
                "bokio_get_accounts",
                "Get chart of accounts to see available account codes",
                func(ctx context.Context, session *mcp.ServerSession, params *mcp.CallToolParamsFor[GetAccountsParams]) (*mcp.CallToolResultFor[GetAccountsResult], error) </span><span class="cov0" title="0">{
                        // Authentication is handled automatically by AuthenticatedGET

                        path := "/accounts"
                        if params.Arguments.Type != nil &amp;&amp; *params.Arguments.Type != "" </span><span class="cov0" title="0">{
                                path += "?type=" + *params.Arguments.Type
                        }</span>

                        <span class="cov0" title="0">resp, err := client.AuthenticatedGET(ctx, path)
                        if err != nil </span><span class="cov0" title="0">{
                                return &amp;mcp.CallToolResultFor[GetAccountsResult]{
                                        Content: []mcp.Content{
                                                &amp;mcp.TextContent{
                                                        Text: fmt.Sprintf("Failed to get accounts: %v", err),
                                                },
                                        },
                                }, nil
                        }</span>

                        <span class="cov0" title="0">if resp.StatusCode() != http.StatusOK </span><span class="cov0" title="0">{
                                return &amp;mcp.CallToolResultFor[GetAccountsResult]{
                                        Content: []mcp.Content{
                                                &amp;mcp.TextContent{
                                                        Text: fmt.Sprintf("API error: %d - %s", resp.StatusCode(), resp.String()),
                                                },
                                        },
                                }, nil
                        }</span>

                        <span class="cov0" title="0">var accounts []bokio.Account
                        if err := json.Unmarshal(resp.Body(), &amp;accounts); err != nil </span><span class="cov0" title="0">{
                                return &amp;mcp.CallToolResultFor[GetAccountsResult]{
                                        Content: []mcp.Content{
                                                &amp;mcp.TextContent{
                                                        Text: fmt.Sprintf("Failed to parse response: %v", err),
                                                },
                                        },
                                }, nil
                        }</span>

                        <span class="cov0" title="0">return &amp;mcp.CallToolResultFor[GetAccountsResult]{
                                Content: []mcp.Content{
                                        &amp;mcp.TextContent{
                                                Text: fmt.Sprintf("Found %d accounts", len(accounts)),
                                        },
                                },
                        }, nil</span>
                },
                mcp.Input(
                        mcp.Property("type",
                                mcp.Description("Filter by account type"),
                                        ),
                ),
        )
        
        <span class="cov0" title="0">server.AddTools(getAccountsTool)

        return nil</span>
}





// parseCreateJournalEntryRequestFromParams parses the new typed parameters into a CreateJournalEntryRequest
func parseCreateJournalEntryRequestFromParams(params CreateJournalEntryParams) (*bokio.CreateJournalEntryRequest, error) <span class="cov0" title="0">{
        if params.Date == "" </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("date is required")
        }</span>

        <span class="cov0" title="0">if params.Description == "" </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("description is required")
        }</span>

        <span class="cov0" title="0">if len(params.Lines) &lt; 2 </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("at least 2 journal lines are required")
        }</span>

        <span class="cov0" title="0">items := make([]bokio.JournalEntryItem, len(params.Lines))
        for i, lineParams := range params.Lines </span><span class="cov0" title="0">{
                if lineParams.AccountCode == "" </span><span class="cov0" title="0">{
                        return nil, fmt.Errorf("account_code is required for line %d", i)
                }</span>

                // Parse account code to int32
                <span class="cov0" title="0">accountCode, err := strconv.ParseInt(lineParams.AccountCode, 10, 32)
                if err != nil </span><span class="cov0" title="0">{
                        return nil, fmt.Errorf("invalid account_code for line %d: %v", i, err)
                }</span>

                <span class="cov0" title="0">item := bokio.JournalEntryItem{
                        Account: int32(accountCode),
                }

                // Check for debit or credit (exactly one should be provided)
                hasDebit := lineParams.Debit != nil
                hasCredit := lineParams.Credit != nil

                if hasDebit </span><span class="cov0" title="0">{
                        item.Debit = lineParams.Debit.Amount
                }</span>

                <span class="cov0" title="0">if hasCredit </span><span class="cov0" title="0">{
                        item.Credit = lineParams.Credit.Amount
                }</span>

                <span class="cov0" title="0">if !hasDebit &amp;&amp; !hasCredit </span><span class="cov0" title="0">{
                        return nil, fmt.Errorf("either debit or credit is required for line %d", i)
                }</span>

                <span class="cov0" title="0">if hasDebit &amp;&amp; hasCredit </span><span class="cov0" title="0">{
                        return nil, fmt.Errorf("cannot have both debit and credit for line %d", i)
                }</span>

                <span class="cov0" title="0">items[i] = item</span>
        }

        <span class="cov0" title="0">request := &amp;bokio.CreateJournalEntryRequest{
                Title: params.Description,
                Date:  params.Date,
                Items: items,
        }

        // Parse date (in a real implementation, convert string to time.Time)
        // For now, we'll leave Date as nil and let the API handle the string

        // Reference field doesn't exist in CreateJournalEntryRequest

        return request, nil</span>
}

// validateJournalEntryBalanceFromTyped validates that debits equal credits for the typed version
func validateJournalEntryBalanceFromTyped(request *bokio.CreateJournalEntryRequest) error <span class="cov0" title="0">{
        totalDebits := make(map[string]float64)
        totalCredits := make(map[string]float64)

        for _, item := range request.Items </span><span class="cov0" title="0">{
                totalDebits["SEK"] += item.Debit
                totalCredits["SEK"] += item.Credit
        }</span>

        // Check that debits equal credits for each currency
        <span class="cov0" title="0">for currency, debitTotal := range totalDebits </span><span class="cov0" title="0">{
                creditTotal, exists := totalCredits[currency]
                if !exists || debitTotal != creditTotal </span><span class="cov0" title="0">{
                        return fmt.Errorf("journal entry does not balance for currency %s: debits=%.2f, credits=%.2f", currency, debitTotal, creditTotal)
                }</span>
        }

        // Check that all currencies in credits are also in debits
        <span class="cov0" title="0">for currency, creditTotal := range totalCredits </span><span class="cov0" title="0">{
                debitTotal, exists := totalDebits[currency]
                if !exists || debitTotal != creditTotal </span><span class="cov0" title="0">{
                        return fmt.Errorf("journal entry does not balance for currency %s: debits=%.2f, credits=%.2f", currency, debitTotal, creditTotal)
                }</span>
        }

        <span class="cov0" title="0">return nil</span>
}</pre>
		
		<pre class="file" id="file12" style="display: none">package tools

import (
        "context"
        "encoding/json"
        "fmt"
        "net/http"
        "os"

        "github.com/klowdo/bokio-mcp/bokio"
        "github.com/modelcontextprotocol/go-sdk/mcp"
)

// ListUploadsParams defines the parameters for listing uploads
type ListUploadsParams struct {
        Page    *int    `json:"page,omitempty"`
        PerPage *int    `json:"per_page,omitempty"`
        Status  *string `json:"status,omitempty"`
}

// ListUploadsResult defines the result of listing uploads
type ListUploadsResult struct {
        Success    bool                   `json:"success"`
        Data       []bokio.Upload         `json:"data,omitempty"`
        Pagination interface{}            `json:"pagination,omitempty"`
        Error      string                 `json:"error,omitempty"`
}

// UploadFileParams defines the parameters for uploading a file
type UploadFileParams struct {
        FilePath    string  `json:"file_path"`
        Description *string `json:"description,omitempty"`
        Category    *string `json:"category,omitempty"`
}

// UploadFileResult defines the result of uploading a file
type UploadFileResult struct {
        Success bool          `json:"success"`
        Data    *bokio.Upload `json:"data,omitempty"`
        Message string        `json:"message,omitempty"`
        Error   string        `json:"error,omitempty"`
}

// GetUploadParams defines the parameters for getting an upload
type GetUploadParams struct {
        ID string `json:"id"`
}

// GetUploadResult defines the result of getting an upload
type GetUploadResult struct {
        Success bool          `json:"success"`
        Data    *bokio.Upload `json:"data,omitempty"`
        Error   string        `json:"error,omitempty"`
}

// DownloadFileParams defines the parameters for downloading a file
type DownloadFileParams struct {
        ID         string `json:"id"`
        OutputPath string `json:"output_path"`
}

// DownloadFileResult defines the result of downloading a file
type DownloadFileResult struct {
        Success    bool   `json:"success"`
        Message    string `json:"message,omitempty"`
        OutputPath string `json:"output_path,omitempty"`
        Size       int    `json:"size,omitempty"`
        Error      string `json:"error,omitempty"`
}

// DeleteUploadParams defines the parameters for deleting an upload
type DeleteUploadParams struct {
        ID string `json:"id"`
}

// DeleteUploadResult defines the result of deleting an upload
type DeleteUploadResult struct {
        Success bool   `json:"success"`
        Message string `json:"message,omitempty"`
        Error   string `json:"error,omitempty"`
}

// RegisterUploadTools registers file upload-related MCP tools
func RegisterUploadTools(server *mcp.Server, client *bokio.Client) error <span class="cov0" title="0">{
        // Register bokio_list_uploads tool
        listUploadsTool := mcp.NewServerTool[ListUploadsParams, ListUploadsResult](
                "bokio_list_uploads",
                "List uploaded files with optional filtering and pagination",
                func(ctx context.Context, session *mcp.ServerSession, params *mcp.CallToolParamsFor[ListUploadsParams]) (*mcp.CallToolResultFor[ListUploadsResult], error) </span><span class="cov0" title="0">{
                        // Authentication is handled automatically by AuthenticatedGET

                        // Build query parameters
                        queryParams := make(map[string]string)
                        
                        if params.Arguments.Page != nil </span><span class="cov0" title="0">{
                                queryParams["page"] = fmt.Sprintf("%d", *params.Arguments.Page)
                        }</span>
                        
                        <span class="cov0" title="0">if params.Arguments.PerPage != nil </span><span class="cov0" title="0">{
                                queryParams["per_page"] = fmt.Sprintf("%d", *params.Arguments.PerPage)
                        }</span>
                        
                        <span class="cov0" title="0">if params.Arguments.Status != nil &amp;&amp; *params.Arguments.Status != "" </span><span class="cov0" title="0">{
                                queryParams["status"] = *params.Arguments.Status
                        }</span>

                        // Construct URL with query parameters
                        <span class="cov0" title="0">path := "/uploads"
                        if len(queryParams) &gt; 0 </span><span class="cov0" title="0">{
                                path += "?"
                                first := true
                                for key, value := range queryParams </span><span class="cov0" title="0">{
                                        if !first </span><span class="cov0" title="0">{
                                                path += "&amp;"
                                        }</span>
                                        <span class="cov0" title="0">path += key + "=" + value
                                        first = false</span>
                                }
                        }

                        <span class="cov0" title="0">resp, err := client.AuthenticatedGET(ctx, path)
                        if err != nil </span><span class="cov0" title="0">{
                                return &amp;mcp.CallToolResultFor[ListUploadsResult]{
                                        Content: []mcp.Content{
                                                &amp;mcp.TextContent{
                                                        Text: fmt.Sprintf("Failed to list uploads: %v", err),
                                                },
                                        },
                                }, nil
                        }</span>

                        <span class="cov0" title="0">if resp.StatusCode() != http.StatusOK </span><span class="cov0" title="0">{
                                return &amp;mcp.CallToolResultFor[ListUploadsResult]{
                                        Content: []mcp.Content{
                                                &amp;mcp.TextContent{
                                                        Text: fmt.Sprintf("API error: %d - %s", resp.StatusCode(), resp.String()),
                                                },
                                        },
                                }, nil
                        }</span>

                        <span class="cov0" title="0">var uploadList bokio.UploadsResponse
                        if err := json.Unmarshal(resp.Body(), &amp;uploadList); err != nil </span><span class="cov0" title="0">{
                                return &amp;mcp.CallToolResultFor[ListUploadsResult]{
                                        Content: []mcp.Content{
                                                &amp;mcp.TextContent{
                                                        Text: fmt.Sprintf("Failed to parse response: %v", err),
                                                },
                                        },
                                }, nil
                        }</span>

                        <span class="cov0" title="0">return &amp;mcp.CallToolResultFor[ListUploadsResult]{
                                Content: []mcp.Content{
                                        &amp;mcp.TextContent{
                                                Text: fmt.Sprintf("Found %d uploads", len(uploadList.Items)),
                                        },
                                },
                        }, nil</span>
                },
                mcp.Input(
                        mcp.Property("page",
                                mcp.Description("Page number for pagination (default: 1)"),
                                        ),
                        mcp.Property("per_page",
                                mcp.Description("Number of items per page (default: 25, max: 100)"),
                                                        ),
                        mcp.Property("status",
                                mcp.Description("Filter by upload status"),
                                        ),
                ),
        )
        
        <span class="cov0" title="0">server.AddTools(listUploadsTool)

        // Register bokio_upload_file tool
        uploadFileTool := mcp.NewServerTool[UploadFileParams, UploadFileResult](
                "bokio_upload_file",
                "Upload a file to Bokio for document management",
                func(ctx context.Context, session *mcp.ServerSession, params *mcp.CallToolParamsFor[UploadFileParams]) (*mcp.CallToolResultFor[UploadFileResult], error) </span><span class="cov0" title="0">{
                        // Authentication is handled automatically by AuthenticatedPOST

                        filePath := params.Arguments.FilePath
                        if filePath == "" </span><span class="cov0" title="0">{
                                return &amp;mcp.CallToolResultFor[UploadFileResult]{
                                        Content: []mcp.Content{
                                                &amp;mcp.TextContent{
                                                        Text: "file_path is required",
                                                },
                                        },
                                }, fmt.Errorf("file_path is required")
                        }</span>

                        // Check if file exists
                        <span class="cov0" title="0">fileInfo, err := os.Stat(filePath)
                        if err != nil </span><span class="cov0" title="0">{
                                if os.IsNotExist(err) </span><span class="cov0" title="0">{
                                        return &amp;mcp.CallToolResultFor[UploadFileResult]{
                                                Content: []mcp.Content{
                                                        &amp;mcp.TextContent{
                                                                        Text: fmt.Sprintf("File not found: %s", filePath),
                                                        },
                                                },
                                        }, nil
                                }</span>
                                <span class="cov0" title="0">return &amp;mcp.CallToolResultFor[UploadFileResult]{
                                        Content: []mcp.Content{
                                                &amp;mcp.TextContent{
                                                        Text: fmt.Sprintf("Error accessing file: %v", err),
                                                },
                                        },
                                }, nil</span>
                        }

                        // Read file content
                        <span class="cov0" title="0">fileContent, err := os.ReadFile(filePath)
                        if err != nil </span><span class="cov0" title="0">{
                                return &amp;mcp.CallToolResultFor[UploadFileResult]{
                                        Content: []mcp.Content{
                                                &amp;mcp.TextContent{
                                                        Text: fmt.Sprintf("Failed to read file: %v", err),
                                                },
                                        },
                                }, nil
                        }</span>

                        // Prepare upload request
                        <span class="cov0" title="0">uploadRequest := map[string]interface{}{
                                "filename":     fileInfo.Name(),
                                "size":         fileInfo.Size(),
                                "content_type": getContentType(filePath),
                                "content":      fileContent, // In a real implementation, this might be base64 encoded
                        }

                        if params.Arguments.Description != nil &amp;&amp; *params.Arguments.Description != "" </span><span class="cov0" title="0">{
                                uploadRequest["description"] = *params.Arguments.Description
                        }</span>

                        <span class="cov0" title="0">if params.Arguments.Category != nil &amp;&amp; *params.Arguments.Category != "" </span><span class="cov0" title="0">{
                                uploadRequest["category"] = *params.Arguments.Category
                        }</span>

                        <span class="cov0" title="0">resp, err := client.AuthenticatedPOST(ctx, "/uploads", uploadRequest)
                        if err != nil </span><span class="cov0" title="0">{
                                return &amp;mcp.CallToolResultFor[UploadFileResult]{
                                        Content: []mcp.Content{
                                                &amp;mcp.TextContent{
                                                        Text: fmt.Sprintf("Failed to upload file: %v", err),
                                                },
                                        },
                                }, nil
                        }</span>

                        <span class="cov0" title="0">if resp.StatusCode() != http.StatusCreated &amp;&amp; resp.StatusCode() != http.StatusOK </span><span class="cov0" title="0">{
                                return &amp;mcp.CallToolResultFor[UploadFileResult]{
                                        Content: []mcp.Content{
                                                &amp;mcp.TextContent{
                                                        Text: fmt.Sprintf("API error: %d - %s", resp.StatusCode(), resp.String()),
                                                },
                                        },
                                }, nil
                        }</span>

                        <span class="cov0" title="0">var upload bokio.Upload
                        if err := json.Unmarshal(resp.Body(), &amp;upload); err != nil </span><span class="cov0" title="0">{
                                return &amp;mcp.CallToolResultFor[UploadFileResult]{
                                        Content: []mcp.Content{
                                                &amp;mcp.TextContent{
                                                        Text: fmt.Sprintf("Failed to parse response: %v", err),
                                                },
                                        },
                                }, nil
                        }</span>

                        <span class="cov0" title="0">return &amp;mcp.CallToolResultFor[UploadFileResult]{
                                Content: []mcp.Content{
                                        &amp;mcp.TextContent{
                                                Text: fmt.Sprintf("File uploaded successfully: %s (ID: %s)", upload.Description, upload.ID),
                                        },
                                },
                        }, nil</span>
                },
                mcp.Input(
                        mcp.Property("file_path",
                                mcp.Description("Path to the file to upload"),
                                mcp.Required(true),
                        ),
                        mcp.Property("description",
                                mcp.Description("Optional description for the file"),
                        ),
                        mcp.Property("category",
                                mcp.Description("File category"),
                                mcp.Enum("invoice", "receipt", "contract", "bank_statement", "other"),
                        ),
                ),
        )
        
        <span class="cov0" title="0">server.AddTools(uploadFileTool)

        // Register bokio_get_upload tool
        getUploadTool := mcp.NewServerTool[GetUploadParams, GetUploadResult](
                "bokio_get_upload",
                "Get information about a specific uploaded file",
                func(ctx context.Context, session *mcp.ServerSession, params *mcp.CallToolParamsFor[GetUploadParams]) (*mcp.CallToolResultFor[GetUploadResult], error) </span><span class="cov0" title="0">{
                        // Authentication is handled automatically by AuthenticatedGET

                        id := params.Arguments.ID
                        if id == "" </span><span class="cov0" title="0">{
                                return &amp;mcp.CallToolResultFor[GetUploadResult]{
                                        Content: []mcp.Content{
                                                &amp;mcp.TextContent{
                                                        Text: "Upload ID is required",
                                                },
                                        },
                                }, fmt.Errorf("upload ID is required")
                        }</span>

                        <span class="cov0" title="0">resp, err := client.AuthenticatedGET(ctx, "/uploads/"+id)
                        if err != nil </span><span class="cov0" title="0">{
                                return &amp;mcp.CallToolResultFor[GetUploadResult]{
                                        Content: []mcp.Content{
                                                &amp;mcp.TextContent{
                                                        Text: fmt.Sprintf("Failed to get upload: %v", err),
                                                },
                                        },
                                }, nil
                        }</span>

                        <span class="cov0" title="0">if resp.StatusCode() == http.StatusNotFound </span><span class="cov0" title="0">{
                                return &amp;mcp.CallToolResultFor[GetUploadResult]{
                                        Content: []mcp.Content{
                                                &amp;mcp.TextContent{
                                                        Text: "Upload not found",
                                                },
                                        },
                                }, nil
                        }</span>

                        <span class="cov0" title="0">if resp.StatusCode() != http.StatusOK </span><span class="cov0" title="0">{
                                return &amp;mcp.CallToolResultFor[GetUploadResult]{
                                        Content: []mcp.Content{
                                                &amp;mcp.TextContent{
                                                        Text: fmt.Sprintf("API error: %d - %s", resp.StatusCode(), resp.String()),
                                                },
                                        },
                                }, nil
                        }</span>

                        <span class="cov0" title="0">var upload bokio.Upload
                        if err := json.Unmarshal(resp.Body(), &amp;upload); err != nil </span><span class="cov0" title="0">{
                                return &amp;mcp.CallToolResultFor[GetUploadResult]{
                                        Content: []mcp.Content{
                                                &amp;mcp.TextContent{
                                                        Text: fmt.Sprintf("Failed to parse response: %v", err),
                                                },
                                        },
                                }, nil
                        }</span>

                        <span class="cov0" title="0">return &amp;mcp.CallToolResultFor[GetUploadResult]{
                                Content: []mcp.Content{
                                        &amp;mcp.TextContent{
                                                Text: fmt.Sprintf("Upload: %s (ID: %s)", upload.Description, upload.ID),
                                        },
                                },
                        }, nil</span>
                },
                mcp.Input(
                        mcp.Property("id",
                                mcp.Description("Upload ID"),
                                mcp.Required(true),
                        ),
                ),
        )
        
        <span class="cov0" title="0">server.AddTools(getUploadTool)

        // Register bokio_download_file tool
        downloadFileTool := mcp.NewServerTool[DownloadFileParams, DownloadFileResult](
                "bokio_download_file",
                "Download a file from Bokio",
                func(ctx context.Context, session *mcp.ServerSession, params *mcp.CallToolParamsFor[DownloadFileParams]) (*mcp.CallToolResultFor[DownloadFileResult], error) </span><span class="cov0" title="0">{
                        // Authentication is handled automatically by AuthenticatedGET

                        id := params.Arguments.ID
                        if id == "" </span><span class="cov0" title="0">{
                                return &amp;mcp.CallToolResultFor[DownloadFileResult]{
                                        Content: []mcp.Content{
                                                &amp;mcp.TextContent{
                                                        Text: "Upload ID is required",
                                                },
                                        },
                                }, fmt.Errorf("upload ID is required")
                        }</span>

                        <span class="cov0" title="0">outputPath := params.Arguments.OutputPath
                        if outputPath == "" </span><span class="cov0" title="0">{
                                return &amp;mcp.CallToolResultFor[DownloadFileResult]{
                                        Content: []mcp.Content{
                                                &amp;mcp.TextContent{
                                                        Text: "Output path is required",
                                                },
                                        },
                                }, fmt.Errorf("output path is required")
                        }</span>

                        <span class="cov0" title="0">resp, err := client.AuthenticatedGET(ctx, "/uploads/"+id+"/download")
                        if err != nil </span><span class="cov0" title="0">{
                                return &amp;mcp.CallToolResultFor[DownloadFileResult]{
                                        Content: []mcp.Content{
                                                &amp;mcp.TextContent{
                                                        Text: fmt.Sprintf("Failed to download file: %v", err),
                                                },
                                        },
                                }, nil
                        }</span>

                        <span class="cov0" title="0">if resp.StatusCode() == http.StatusNotFound </span><span class="cov0" title="0">{
                                return &amp;mcp.CallToolResultFor[DownloadFileResult]{
                                        Content: []mcp.Content{
                                                &amp;mcp.TextContent{
                                                        Text: "Upload not found",
                                                },
                                        },
                                }, nil
                        }</span>

                        <span class="cov0" title="0">if resp.StatusCode() != http.StatusOK </span><span class="cov0" title="0">{
                                return &amp;mcp.CallToolResultFor[DownloadFileResult]{
                                        Content: []mcp.Content{
                                                &amp;mcp.TextContent{
                                                        Text: fmt.Sprintf("API error: %d - %s", resp.StatusCode(), resp.String()),
                                                },
                                        },
                                }, nil
                        }</span>

                        // Write file content to output path
                        <span class="cov0" title="0">if err := os.WriteFile(outputPath, resp.Body(), 0644); err != nil </span><span class="cov0" title="0">{
                                return &amp;mcp.CallToolResultFor[DownloadFileResult]{
                                        Content: []mcp.Content{
                                                &amp;mcp.TextContent{
                                                        Text: fmt.Sprintf("Failed to write file: %v", err),
                                                },
                                        },
                                }, nil
                        }</span>

                        <span class="cov0" title="0">return &amp;mcp.CallToolResultFor[DownloadFileResult]{
                                Content: []mcp.Content{
                                        &amp;mcp.TextContent{
                                                Text: fmt.Sprintf("File downloaded successfully to: %s", outputPath),
                                        },
                                },
                        }, nil</span>
                },
                mcp.Input(
                        mcp.Property("id",
                                mcp.Description("Upload ID"),
                                mcp.Required(true),
                        ),
                        mcp.Property("output_path",
                                mcp.Description("Path where to save the downloaded file"),
                                mcp.Required(true),
                        ),
                ),
        )
        
        <span class="cov0" title="0">server.AddTools(downloadFileTool)

        // Register bokio_delete_upload tool
        deleteUploadTool := mcp.NewServerTool[DeleteUploadParams, DeleteUploadResult](
                "bokio_delete_upload",
                "Delete an uploaded file",
                func(ctx context.Context, session *mcp.ServerSession, params *mcp.CallToolParamsFor[DeleteUploadParams]) (*mcp.CallToolResultFor[DeleteUploadResult], error) </span><span class="cov0" title="0">{
                        // Authentication is handled automatically by AuthenticatedDELETE

                        id := params.Arguments.ID
                        if id == "" </span><span class="cov0" title="0">{
                                return &amp;mcp.CallToolResultFor[DeleteUploadResult]{
                                        Content: []mcp.Content{
                                                &amp;mcp.TextContent{
                                                        Text: "Upload ID is required",
                                                },
                                        },
                                }, fmt.Errorf("upload ID is required")
                        }</span>

                        <span class="cov0" title="0">resp, err := client.AuthenticatedDELETE(ctx, "/uploads/"+id)
                        if err != nil </span><span class="cov0" title="0">{
                                return &amp;mcp.CallToolResultFor[DeleteUploadResult]{
                                        Content: []mcp.Content{
                                                &amp;mcp.TextContent{
                                                        Text: fmt.Sprintf("Failed to delete upload: %v", err),
                                                },
                                        },
                                }, nil
                        }</span>

                        <span class="cov0" title="0">if resp.StatusCode() == http.StatusNotFound </span><span class="cov0" title="0">{
                                return &amp;mcp.CallToolResultFor[DeleteUploadResult]{
                                        Content: []mcp.Content{
                                                &amp;mcp.TextContent{
                                                        Text: "Upload not found",
                                                },
                                        },
                                }, nil
                        }</span>

                        <span class="cov0" title="0">if resp.StatusCode() != http.StatusOK &amp;&amp; resp.StatusCode() != http.StatusNoContent </span><span class="cov0" title="0">{
                                return &amp;mcp.CallToolResultFor[DeleteUploadResult]{
                                        Content: []mcp.Content{
                                                &amp;mcp.TextContent{
                                                        Text: fmt.Sprintf("API error: %d - %s", resp.StatusCode(), resp.String()),
                                                },
                                        },
                                }, nil
                        }</span>

                        <span class="cov0" title="0">return &amp;mcp.CallToolResultFor[DeleteUploadResult]{
                                Content: []mcp.Content{
                                        &amp;mcp.TextContent{
                                                Text: "Upload deleted successfully",
                                        },
                                },
                        }, nil</span>
                },
                mcp.Input(
                        mcp.Property("id",
                                mcp.Description("Upload ID"),
                                mcp.Required(true),
                        ),
                ),
        )
        
        <span class="cov0" title="0">server.AddTools(deleteUploadTool)

        return nil</span>
}

// getContentType returns the MIME type based on file extension
func getContentType(filePath string) string <span class="cov0" title="0">{
        // Basic content type detection based on file extension
        // In a real implementation, you might use a more sophisticated library
        switch </span>{
        case len(filePath) &gt;= 4 &amp;&amp; filePath[len(filePath)-4:] == ".pdf":<span class="cov0" title="0">
                return "application/pdf"</span>
        case len(filePath) &gt;= 4 &amp;&amp; filePath[len(filePath)-4:] == ".jpg" || filePath[len(filePath)-5:] == ".jpeg":<span class="cov0" title="0">
                return "image/jpeg"</span>
        case len(filePath) &gt;= 4 &amp;&amp; filePath[len(filePath)-4:] == ".png":<span class="cov0" title="0">
                return "image/png"</span>
        case len(filePath) &gt;= 4 &amp;&amp; filePath[len(filePath)-4:] == ".txt":<span class="cov0" title="0">
                return "text/plain"</span>
        case len(filePath) &gt;= 5 &amp;&amp; filePath[len(filePath)-5:] == ".docx":<span class="cov0" title="0">
                return "application/vnd.openxmlformats-officedocument.wordprocessingml.document"</span>
        case len(filePath) &gt;= 5 &amp;&amp; filePath[len(filePath)-5:] == ".xlsx":<span class="cov0" title="0">
                return "application/vnd.openxmlformats-officedocument.spreadsheetml.sheet"</span>
        default:<span class="cov0" title="0">
                return "application/octet-stream"</span>
        }
}</pre>
		
		</div>
	</body>
	<script>
	(function() {
		var files = document.getElementById('files');
		var visible;
		files.addEventListener('change', onChange, false);
		function select(part) {
			if (visible)
				visible.style.display = 'none';
			visible = document.getElementById(part);
			if (!visible)
				return;
			files.value = part;
			visible.style.display = 'block';
			location.hash = part;
		}
		function onChange() {
			select(files.value);
			window.scrollTo(0, 0);
		}
		if (location.hash != "") {
			select(location.hash.substr(1));
		}
		if (!visible) {
			select("file0");
		}
	})();
	</script>
</html>
