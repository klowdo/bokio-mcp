package tools

import (
	"context"
	"encoding/json"
	"fmt"
	"net/http"
	"strconv"

	"github.com/klowdo/bokio-mcp/bokio"
	"github.com/modelcontextprotocol/go-sdk/mcp"
)

// ListCustomersParams defines the parameters for listing customers
type ListCustomersParams struct {
	Page    *int    `json:"page,omitempty"`
	PerPage *int    `json:"per_page,omitempty"`
	Search  *string `json:"search,omitempty"`
}

// ListCustomersResult defines the result of listing customers
type ListCustomersResult struct {
	Success    bool                   `json:"success"`
	Data       []bokio.Customer       `json:"data,omitempty"`
	Pagination interface{}            `json:"pagination,omitempty"`
	Error      string                 `json:"error,omitempty"`
}

// GetCustomerParams defines the parameters for getting a customer
type GetCustomerParams struct {
	ID string `json:"id"`
}

// GetCustomerResult defines the result of getting a customer
type GetCustomerResult struct {
	Success bool            `json:"success"`
	Data    *bokio.Customer `json:"data,omitempty"`
	Error   string          `json:"error,omitempty"`
}

// CreateCustomerParams defines the parameters for creating a customer
type CreateCustomerParams struct {
	Name               string         `json:"name"`
	Email              *string        `json:"email,omitempty"`
	Phone              *string        `json:"phone,omitempty"`
	OrganizationNumber *string        `json:"organization_number,omitempty"`
	VATNumber          *string        `json:"vat_number,omitempty"`
	Address            *AddressParams `json:"address,omitempty"`
	PaymentTerms       *int           `json:"payment_terms,omitempty"`
}

// AddressParams defines the parameters for an address
type AddressParams struct {
	Street     *string `json:"street,omitempty"`
	PostalCode *string `json:"postal_code,omitempty"`
	City       *string `json:"city,omitempty"`
	Country    *string `json:"country,omitempty"`
}

// CreateCustomerResult defines the result of creating a customer
type CreateCustomerResult struct {
	Success bool            `json:"success"`
	Data    *bokio.Customer `json:"data,omitempty"`
	Message string          `json:"message,omitempty"`
	Error   string          `json:"error,omitempty"`
}

// UpdateCustomerParams defines the parameters for updating a customer
type UpdateCustomerParams struct {
	ID                 string         `json:"id"`
	Name               *string        `json:"name,omitempty"`
	Email              *string        `json:"email,omitempty"`
	Phone              *string        `json:"phone,omitempty"`
	OrganizationNumber *string        `json:"organization_number,omitempty"`
	VATNumber          *string        `json:"vat_number,omitempty"`
	Address            *AddressParams `json:"address,omitempty"`
	PaymentTerms       *int           `json:"payment_terms,omitempty"`
}

// UpdateCustomerResult defines the result of updating a customer
type UpdateCustomerResult struct {
	Success bool            `json:"success"`
	Data    *bokio.Customer `json:"data,omitempty"`
	Message string          `json:"message,omitempty"`
	Error   string          `json:"error,omitempty"`
}

// RegisterCustomerTools registers customer-related MCP tools
func RegisterCustomerTools(server *mcp.Server, client *bokio.AuthClient) error {
	// Register bokio_list_customers tool
	listCustomersTool := mcp.NewServerTool[ListCustomersParams, ListCustomersResult](
		"bokio_list_customers",
		"List customers with optional filtering and pagination",
		func(ctx context.Context, session *mcp.ServerSession, params *mcp.CallToolParamsFor[ListCustomersParams]) (*mcp.CallToolResultFor[ListCustomersResult], error) {
			// Authentication is handled automatically by AuthenticatedGET

			// Build query parameters
			queryParams := make(map[string]string)

			if params.Arguments.Page != nil {
				queryParams["page"] = fmt.Sprintf("%d", *params.Arguments.Page)
			}

			if params.Arguments.PerPage != nil {
				queryParams["per_page"] = fmt.Sprintf("%d", *params.Arguments.PerPage)
			}

			if params.Arguments.Search != nil && *params.Arguments.Search != "" {
				queryParams["search"] = *params.Arguments.Search
			}

			// Construct URL with query parameters
			path := "/customers"
			if len(queryParams) > 0 {
				path += "?"
				first := true
				for key, value := range queryParams {
					if !first {
						path += "&"
					}
					path += key + "=" + value
					first = false
				}
			}

			resp, err := client.AuthenticatedGET(ctx, path)
			if err != nil {
				return &mcp.CallToolResultFor[ListCustomersResult]{
					Content: []mcp.Content{
						&mcp.TextContent{
							Text: fmt.Sprintf("Failed to list customers: %v", err),
						},
					},
				}, nil
			}

			if resp.StatusCode() != http.StatusOK {
				return &mcp.CallToolResultFor[ListCustomersResult]{
					Content: []mcp.Content{
						&mcp.TextContent{
							Text: fmt.Sprintf("API error: %d - %s", resp.StatusCode(), resp.String()),
						},
					},
				}, nil
			}

			var customerList bokio.CustomersResponse
			if err := json.Unmarshal(resp.Body(), &customerList); err != nil {
				return &mcp.CallToolResultFor[ListCustomersResult]{
					Content: []mcp.Content{
						&mcp.TextContent{
							Text: fmt.Sprintf("Failed to parse response: %v", err),
						},
					},
				}, nil
			}

			return &mcp.CallToolResultFor[ListCustomersResult]{
				Content: []mcp.Content{
					&mcp.TextContent{
						Text: fmt.Sprintf("Found %d customers", len(customerList.Items)),
					},
				},
			}, nil
		},
		mcp.Input(
			mcp.Property("page",
				mcp.Description("Page number for pagination (default: 1)"),
			),
			mcp.Property("per_page",
				mcp.Description("Number of items per page (default: 25, max: 100)"),
			),
			mcp.Property("search",
				mcp.Description("Search customers by name or email"),
			),
		),
	)

	server.AddTools(listCustomersTool)

	// Register bokio_get_customer tool
	getCustomerTool := mcp.NewServerTool[GetCustomerParams, GetCustomerResult](
		"bokio_get_customer",
		"Get a specific customer by ID",
		func(ctx context.Context, session *mcp.ServerSession, params *mcp.CallToolParamsFor[GetCustomerParams]) (*mcp.CallToolResultFor[GetCustomerResult], error) {
			// Authentication is handled automatically by AuthenticatedGET

			id := params.Arguments.ID
			if id == "" {
				return &mcp.CallToolResultFor[GetCustomerResult]{
					Content: []mcp.Content{
						&mcp.TextContent{
							Text: "Customer ID is required",
						},
					},
				}, fmt.Errorf("customer ID is required")
			}

			resp, err := client.AuthenticatedGET(ctx, "/customers/"+id)
			if err != nil {
				return &mcp.CallToolResultFor[GetCustomerResult]{
					Content: []mcp.Content{
						&mcp.TextContent{
							Text: fmt.Sprintf("Failed to get customer: %v", err),
						},
					},
				}, nil
			}

			if resp.StatusCode() == http.StatusNotFound {
				return &mcp.CallToolResultFor[GetCustomerResult]{
					Content: []mcp.Content{
						&mcp.TextContent{
							Text: "Customer not found",
						},
					},
				}, nil
			}

			if resp.StatusCode() != http.StatusOK {
				return &mcp.CallToolResultFor[GetCustomerResult]{
					Content: []mcp.Content{
						&mcp.TextContent{
							Text: fmt.Sprintf("API error: %d - %s", resp.StatusCode(), resp.String()),
						},
					},
				}, nil
			}

			var customer bokio.Customer
			if err := json.Unmarshal(resp.Body(), &customer); err != nil {
				return &mcp.CallToolResultFor[GetCustomerResult]{
					Content: []mcp.Content{
						&mcp.TextContent{
							Text: fmt.Sprintf("Failed to parse response: %v", err),
						},
					},
				}, nil
			}

			return &mcp.CallToolResultFor[GetCustomerResult]{
				Content: []mcp.Content{
					&mcp.TextContent{
						Text: fmt.Sprintf("Customer: %s (ID: %s)", customer.Name, customer.ID),
					},
				},
			}, nil
		},
		mcp.Input(
			mcp.Property("id",
				mcp.Description("Customer ID"),
				mcp.Required(true),
			),
		),
	)

	server.AddTools(getCustomerTool)

	// Register bokio_create_customer tool
	createCustomerTool := mcp.NewServerTool[CreateCustomerParams, CreateCustomerResult](
		"bokio_create_customer",
		"Create a new customer",
		func(ctx context.Context, session *mcp.ServerSession, params *mcp.CallToolParamsFor[CreateCustomerParams]) (*mcp.CallToolResultFor[CreateCustomerResult], error) {
			// Authentication is handled automatically by AuthenticatedPOST

			// Parse and validate the request
			request, err := parseCreateCustomerRequestFromParams(params.Arguments)
			if err != nil {
				return &mcp.CallToolResultFor[CreateCustomerResult]{
					Content: []mcp.Content{
						&mcp.TextContent{
							Text: fmt.Sprintf("Invalid request: %v", err),
						},
					},
				}, fmt.Errorf("invalid request: %w", err)
			}

			resp, err := client.AuthenticatedPOST(ctx, "/customers", request)
			if err != nil {
				return &mcp.CallToolResultFor[CreateCustomerResult]{
					Content: []mcp.Content{
						&mcp.TextContent{
							Text: fmt.Sprintf("Failed to create customer: %v", err),
						},
					},
				}, nil
			}

			if resp.StatusCode() != http.StatusCreated && resp.StatusCode() != http.StatusOK {
				return &mcp.CallToolResultFor[CreateCustomerResult]{
					Content: []mcp.Content{
						&mcp.TextContent{
							Text: fmt.Sprintf("API error: %d - %s", resp.StatusCode(), resp.String()),
						},
					},
				}, nil
			}

			var customer bokio.Customer
			if err := json.Unmarshal(resp.Body(), &customer); err != nil {
				return &mcp.CallToolResultFor[CreateCustomerResult]{
					Content: []mcp.Content{
						&mcp.TextContent{
							Text: fmt.Sprintf("Failed to parse response: %v", err),
						},
					},
				}, nil
			}

			return &mcp.CallToolResultFor[CreateCustomerResult]{
				Content: []mcp.Content{
					&mcp.TextContent{
						Text: fmt.Sprintf("Customer created successfully: %s (ID: %s)", customer.Name, customer.ID),
					},
				},
			}, nil
		},
		mcp.Input(
			mcp.Property("name",
				mcp.Description("Customer name"),
				mcp.Required(true),
			),
			mcp.Property("email",
				mcp.Description("Customer email address"),
				),
			mcp.Property("phone",
				mcp.Description("Customer phone number"),
			),
			mcp.Property("organization_number",
				mcp.Description("Organization number"),
			),
			mcp.Property("vat_number",
				mcp.Description("VAT number"),
			),
			mcp.Property("address",
				mcp.Description("Customer address"),
			),
			mcp.Property("payment_terms",
				mcp.Description("Payment terms in days"),
				),
		),
	)

	server.AddTools(createCustomerTool)

	// Register bokio_update_customer tool
	updateCustomerTool := mcp.NewServerTool[UpdateCustomerParams, UpdateCustomerResult](
		"bokio_update_customer",
		"Update an existing customer",
		func(ctx context.Context, session *mcp.ServerSession, params *mcp.CallToolParamsFor[UpdateCustomerParams]) (*mcp.CallToolResultFor[UpdateCustomerResult], error) {
			// Authentication is handled automatically by AuthenticatedPATCH

			id := params.Arguments.ID
			if id == "" {
				return &mcp.CallToolResultFor[UpdateCustomerResult]{
					Content: []mcp.Content{
						&mcp.TextContent{
							Text: "Customer ID is required",
						},
					},
				}, fmt.Errorf("customer ID is required")
			}

			// Parse update request (only include provided fields)
			updateRequest := buildUpdateCustomerRequest(params.Arguments)

			resp, err := client.AuthenticatedPATCH(ctx, "/customers/"+id, updateRequest)
			if err != nil {
				return &mcp.CallToolResultFor[UpdateCustomerResult]{
					Content: []mcp.Content{
						&mcp.TextContent{
							Text: fmt.Sprintf("Failed to update customer: %v", err),
						},
					},
				}, nil
			}

			if resp.StatusCode() == http.StatusNotFound {
				return &mcp.CallToolResultFor[UpdateCustomerResult]{
					Content: []mcp.Content{
						&mcp.TextContent{
							Text: "Customer not found",
						},
					},
				}, nil
			}

			if resp.StatusCode() != http.StatusOK {
				return &mcp.CallToolResultFor[UpdateCustomerResult]{
					Content: []mcp.Content{
						&mcp.TextContent{
							Text: fmt.Sprintf("API error: %d - %s", resp.StatusCode(), resp.String()),
						},
					},
				}, nil
			}

			var customer bokio.Customer
			if err := json.Unmarshal(resp.Body(), &customer); err != nil {
				return &mcp.CallToolResultFor[UpdateCustomerResult]{
					Content: []mcp.Content{
						&mcp.TextContent{
							Text: fmt.Sprintf("Failed to parse response: %v", err),
						},
					},
				}, nil
			}

			return &mcp.CallToolResultFor[UpdateCustomerResult]{
				Content: []mcp.Content{
					&mcp.TextContent{
						Text: fmt.Sprintf("Customer updated successfully: %s (ID: %s)", customer.Name, customer.ID),
					},
				},
			}, nil
		},
		mcp.Input(
			mcp.Property("id",
				mcp.Description("Customer ID"),
				mcp.Required(true),
			),
			mcp.Property("name",
				mcp.Description("Customer name"),
			),
			mcp.Property("email",
				mcp.Description("Customer email address"),
				),
			mcp.Property("phone",
				mcp.Description("Customer phone number"),
			),
			mcp.Property("organization_number",
				mcp.Description("Organization number"),
			),
			mcp.Property("vat_number",
				mcp.Description("VAT number"),
			),
			mcp.Property("address",
				mcp.Description("Customer address"),
			),
			mcp.Property("payment_terms",
				mcp.Description("Payment terms in days"),
				),
		),
	)

	server.AddTools(updateCustomerTool)

	return nil
}





// parseCreateCustomerRequestFromParams parses the new typed parameters into a CreateCustomerRequest
func parseCreateCustomerRequestFromParams(params CreateCustomerParams) (*bokio.CreateCustomerRequest, error) {
	if params.Name == "" {
		return nil, fmt.Errorf("customer name is required")
	}

	request := &bokio.CreateCustomerRequest{
		Name: params.Name,
	}

	// Optional fields
	if params.Email != nil {
		request.Email = *params.Email
	}

	if params.Phone != nil {
		request.Phone = *params.Phone
	}

	if params.OrganizationNumber != nil {
		request.OrgNumber = *params.OrganizationNumber
	}

	if params.VATNumber != nil {
		request.VatNumber = *params.VATNumber
	}

	if params.PaymentTerms != nil {
		request.PaymentTerms = strconv.Itoa(*params.PaymentTerms)
	}

	if params.Address != nil {
		address := &bokio.Address{}
		if params.Address.Street != nil {
			address.Line1 = *params.Address.Street
		}
		if params.Address.PostalCode != nil {
			address.PostalCode = *params.Address.PostalCode
		}
		if params.Address.City != nil {
			address.City = *params.Address.City
		}
		if params.Address.Country != nil {
			address.Country = *params.Address.Country
		}
		request.Address = address
	}

	return request, nil
}

// buildUpdateCustomerRequest builds an update request from typed parameters
func buildUpdateCustomerRequest(params UpdateCustomerParams) map[string]interface{} {
	updateRequest := make(map[string]interface{})

	if params.Name != nil && *params.Name != "" {
		updateRequest["name"] = *params.Name
	}

	if params.Email != nil {
		updateRequest["email"] = *params.Email
	}

	if params.Phone != nil {
		updateRequest["phone"] = *params.Phone
	}

	if params.OrganizationNumber != nil {
		updateRequest["organization_number"] = *params.OrganizationNumber
	}

	if params.VATNumber != nil {
		updateRequest["vat_number"] = *params.VATNumber
	}

	if params.PaymentTerms != nil {
		updateRequest["payment_terms"] = *params.PaymentTerms
	}

	if params.Address != nil {
		address := &bokio.Address{}
		if params.Address.Street != nil {
			address.Line1 = *params.Address.Street
		}
		if params.Address.PostalCode != nil {
			address.PostalCode = *params.Address.PostalCode
		}
		if params.Address.City != nil {
			address.City = *params.Address.City
		}
		if params.Address.Country != nil {
			address.Country = *params.Address.Country
		}
		updateRequest["address"] = address
	}

	return updateRequest
}
