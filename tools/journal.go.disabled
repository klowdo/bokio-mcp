package tools

import (
	"context"
	"encoding/json"
	"fmt"
	"net/http"
	"strconv"

	"github.com/klowdo/bokio-mcp/bokio"
	"github.com/klowdo/bokio-mcp/bokio/generated/company"
	"github.com/modelcontextprotocol/go-sdk/mcp"
)

// ListJournalEntriesParams defines the parameters for listing journal entries
type ListJournalEntriesParams struct {
	Page        *int    `json:"page,omitempty"`
	PerPage     *int    `json:"per_page,omitempty"`
	FromDate    *string `json:"from_date,omitempty"`
	ToDate      *string `json:"to_date,omitempty"`
	AccountCode *string `json:"account_code,omitempty"`
}

// ListJournalEntriesResult defines the result of listing journal entries
type ListJournalEntriesResult struct {
	Success    bool        `json:"success"`
	Data       interface{} `json:"data,omitempty"`
	Pagination interface{} `json:"pagination,omitempty"`
	Error      string      `json:"error,omitempty"`
}

// JournalEntryLineParams defines the parameters for a journal entry line
type JournalEntryLineParams struct {
	AccountCode string           `json:"account_code"`
	Description *string          `json:"description,omitempty"`
	Debit       *MoneyParams     `json:"debit,omitempty"`
	Credit      *MoneyParams     `json:"credit,omitempty"`
}

// CreateJournalEntryParams defines the parameters for creating a journal entry
type CreateJournalEntryParams struct {
	Date        string                    `json:"date"`
	Description string                    `json:"description"`
	Reference   *string                   `json:"reference,omitempty"`
	Lines       []JournalEntryLineParams  `json:"lines"`
}

// CreateJournalEntryResult defines the result of creating a journal entry
type CreateJournalEntryResult struct {
	Success bool        `json:"success"`
	Data    interface{} `json:"data,omitempty"`
	Message string      `json:"message,omitempty"`
	Error   string      `json:"error,omitempty"`
}

// ReverseJournalEntryParams defines the parameters for reversing a journal entry
type ReverseJournalEntryParams struct {
	ID          string  `json:"id"`
	Date        string  `json:"date"`
	Description *string `json:"description,omitempty"`
}

// ReverseJournalEntryResult defines the result of reversing a journal entry
type ReverseJournalEntryResult struct {
	Success bool        `json:"success"`
	Data    interface{} `json:"data,omitempty"`
	Message string               `json:"message,omitempty"`
	Error   string               `json:"error,omitempty"`
}

// GetAccountsParams defines the parameters for getting accounts
type GetAccountsParams struct {
	Type *string `json:"type,omitempty"`
}

// GetAccountsResult defines the result of getting accounts
type GetAccountsResult struct {
	Success bool        `json:"success"`
	Data    interface{} `json:"data,omitempty"`
	Error   string      `json:"error,omitempty"`
}

// RegisterJournalTools registers journal entry-related MCP tools
func RegisterJournalTools(server *mcp.Server, client *bokio.AuthClient) error {
	// Register bokio_list_journal_entries tool
	listJournalEntriesTool := mcp.NewServerTool[ListJournalEntriesParams, ListJournalEntriesResult](
		"bokio_list_journal_entries",
		"List journal entries with optional filtering and pagination",
		func(ctx context.Context, session *mcp.ServerSession, params *mcp.CallToolParamsFor[ListJournalEntriesParams]) (*mcp.CallToolResultFor[ListJournalEntriesResult], error) {
			// Authentication is handled automatically by AuthenticatedGET

			// Build query parameters
			queryParams := make(map[string]string)

			if params.Arguments.Page != nil {
				queryParams["page"] = fmt.Sprintf("%d", *params.Arguments.Page)
			}

			if params.Arguments.PerPage != nil {
				queryParams["per_page"] = fmt.Sprintf("%d", *params.Arguments.PerPage)
			}

			if params.Arguments.FromDate != nil && *params.Arguments.FromDate != "" {
				queryParams["from_date"] = *params.Arguments.FromDate
			}

			if params.Arguments.ToDate != nil && *params.Arguments.ToDate != "" {
				queryParams["to_date"] = *params.Arguments.ToDate
			}

			if params.Arguments.AccountCode != nil && *params.Arguments.AccountCode != "" {
				queryParams["account_code"] = *params.Arguments.AccountCode
			}

			// Construct URL with query parameters
			path := "/journal-entries"
			if len(queryParams) > 0 {
				path += "?"
				first := true
				for key, value := range queryParams {
					if !first {
						path += "&"
					}
					path += key + "=" + value
					first = false
				}
			}

			resp, err := client.AuthenticatedGET(ctx, path)
			if err != nil {
				return &mcp.CallToolResultFor[ListJournalEntriesResult]{
					Content: []mcp.Content{
						&mcp.TextContent{
							Text: fmt.Sprintf("Failed to list journal entries: %v", err),
						},
					},
				}, nil
			}

			if resp.StatusCode() != http.StatusOK {
				return &mcp.CallToolResultFor[ListJournalEntriesResult]{
					Content: []mcp.Content{
						&mcp.TextContent{
							Text: fmt.Sprintf("API error: %d - %s", resp.StatusCode(), resp.String()),
						},
					},
				}, nil
			}

			var journalEntries bokio.JournalEntriesResponse
			if err := json.Unmarshal(resp.Body(), &journalEntries); err != nil {
				return &mcp.CallToolResultFor[ListJournalEntriesResult]{
					Content: []mcp.Content{
						&mcp.TextContent{
							Text: fmt.Sprintf("Failed to parse response: %v", err),
						},
					},
				}, nil
			}

			return &mcp.CallToolResultFor[ListJournalEntriesResult]{
				Content: []mcp.Content{
					&mcp.TextContent{
						Text: fmt.Sprintf("Found %d journal entries", len(journalEntries.Items)),
					},
				},
			}, nil
		},
		mcp.Input(
			mcp.Property("page",
				mcp.Description("Page number for pagination (default: 1)"),
					),
			mcp.Property("per_page",
				mcp.Description("Number of items per page (default: 25, max: 100)"),
							),
			mcp.Property("from_date",
				mcp.Description("Filter entries from this date (YYYY-MM-DD)"),
					),
			mcp.Property("to_date",
				mcp.Description("Filter entries to this date (YYYY-MM-DD)"),
					),
			mcp.Property("account_code",
				mcp.Description("Filter by account code"),
			),
		),
	)

	server.AddTools(listJournalEntriesTool)

	// Register bokio_create_journal_entry tool
	createJournalEntryTool := mcp.NewServerTool[CreateJournalEntryParams, CreateJournalEntryResult](
		"bokio_create_journal_entry",
		"Create a new journal entry with debit and credit lines",
		func(ctx context.Context, session *mcp.ServerSession, params *mcp.CallToolParamsFor[CreateJournalEntryParams]) (*mcp.CallToolResultFor[CreateJournalEntryResult], error) {
			// Authentication is handled automatically by AuthenticatedPOST

			// Parse and validate the request
			request, err := parseCreateJournalEntryRequestFromParams(params.Arguments)
			if err != nil {
				return &mcp.CallToolResultFor[CreateJournalEntryResult]{
					Content: []mcp.Content{
						&mcp.TextContent{
							Text: fmt.Sprintf("Invalid request: %v", err),
						},
					},
				}, fmt.Errorf("invalid request: %w", err)
			}

			// Validate that the entry balances
			if err := validateJournalEntryBalanceFromTyped(request); err != nil {
				return &mcp.CallToolResultFor[CreateJournalEntryResult]{
					Content: []mcp.Content{
						&mcp.TextContent{
							Text: fmt.Sprintf("Journal entry validation failed: %v", err),
						},
					},
				}, nil
			}

			resp, err := client.AuthenticatedPOST(ctx, "/journal-entries", request)
			if err != nil {
				return &mcp.CallToolResultFor[CreateJournalEntryResult]{
					Content: []mcp.Content{
						&mcp.TextContent{
							Text: fmt.Sprintf("Failed to create journal entry: %v", err),
						},
					},
				}, nil
			}

			if resp.StatusCode() != http.StatusCreated && resp.StatusCode() != http.StatusOK {
				return &mcp.CallToolResultFor[CreateJournalEntryResult]{
					Content: []mcp.Content{
						&mcp.TextContent{
							Text: fmt.Sprintf("API error: %d - %s", resp.StatusCode(), resp.String()),
						},
					},
				}, nil
			}

			var journalEntry bokio.JournalEntry
			if err := json.Unmarshal(resp.Body(), &journalEntry); err != nil {
				return &mcp.CallToolResultFor[CreateJournalEntryResult]{
					Content: []mcp.Content{
						&mcp.TextContent{
							Text: fmt.Sprintf("Failed to parse response: %v", err),
						},
					},
				}, nil
			}

			return &mcp.CallToolResultFor[CreateJournalEntryResult]{
				Content: []mcp.Content{
					&mcp.TextContent{
						Text: fmt.Sprintf("Journal entry created successfully: %s (ID: %s)", journalEntry.Title, journalEntry.ID),
					},
				},
			}, nil
		},
		mcp.Input(
			mcp.Property("date",
				mcp.Description("Journal entry date (YYYY-MM-DD)"),
						mcp.Required(true),
			),
			mcp.Property("description",
				mcp.Description("Journal entry description"),
				mcp.Required(true),
			),
			mcp.Property("reference",
				mcp.Description("Optional reference number"),
			),
			mcp.Property("lines",
				mcp.Description("Journal entry lines (must balance, minimum 2)"),
				mcp.Required(true),
			),
		),
	)

	server.AddTools(createJournalEntryTool)

	// Register bokio_reverse_journal_entry tool
	reverseJournalEntryTool := mcp.NewServerTool[ReverseJournalEntryParams, ReverseJournalEntryResult](
		"bokio_reverse_journal_entry",
		"Create a reversing journal entry for an existing entry",
		func(ctx context.Context, session *mcp.ServerSession, params *mcp.CallToolParamsFor[ReverseJournalEntryParams]) (*mcp.CallToolResultFor[ReverseJournalEntryResult], error) {
			// Authentication is handled automatically by AuthenticatedPOST

			id := params.Arguments.ID
			if id == "" {
				return &mcp.CallToolResultFor[ReverseJournalEntryResult]{
					Content: []mcp.Content{
						&mcp.TextContent{
							Text: "Journal entry ID is required",
						},
					},
				}, fmt.Errorf("journal entry ID is required")
			}

			date := params.Arguments.Date
			if date == "" {
				return &mcp.CallToolResultFor[ReverseJournalEntryResult]{
					Content: []mcp.Content{
						&mcp.TextContent{
							Text: "Reversal date is required",
						},
					},
				}, fmt.Errorf("reversal date is required")
			}

			reversalRequest := map[string]interface{}{
				"date": date,
			}

			if params.Arguments.Description != nil && *params.Arguments.Description != "" {
				reversalRequest["description"] = *params.Arguments.Description
			}

			resp, err := client.AuthenticatedPOST(ctx, "/journal-entries/"+id+"/reverse", reversalRequest)
			if err != nil {
				return &mcp.CallToolResultFor[ReverseJournalEntryResult]{
					Content: []mcp.Content{
						&mcp.TextContent{
							Text: fmt.Sprintf("Failed to reverse journal entry: %v", err),
						},
					},
				}, nil
			}

			if resp.StatusCode() == http.StatusNotFound {
				return &mcp.CallToolResultFor[ReverseJournalEntryResult]{
					Content: []mcp.Content{
						&mcp.TextContent{
							Text: "Journal entry not found",
						},
					},
				}, nil
			}

			if resp.StatusCode() != http.StatusCreated && resp.StatusCode() != http.StatusOK {
				return &mcp.CallToolResultFor[ReverseJournalEntryResult]{
					Content: []mcp.Content{
						&mcp.TextContent{
							Text: fmt.Sprintf("API error: %d - %s", resp.StatusCode(), resp.String()),
						},
					},
				}, nil
			}

			var journalEntry bokio.JournalEntry
			if err := json.Unmarshal(resp.Body(), &journalEntry); err != nil {
				return &mcp.CallToolResultFor[ReverseJournalEntryResult]{
					Content: []mcp.Content{
						&mcp.TextContent{
							Text: fmt.Sprintf("Failed to parse response: %v", err),
						},
					},
				}, nil
			}

			return &mcp.CallToolResultFor[ReverseJournalEntryResult]{
				Content: []mcp.Content{
					&mcp.TextContent{
						Text: fmt.Sprintf("Journal entry reversed successfully: %s (ID: %s)", journalEntry.Title, journalEntry.ID),
					},
				},
			}, nil
		},
		mcp.Input(
			mcp.Property("id",
				mcp.Description("Original journal entry ID to reverse"),
				mcp.Required(true),
			),
			mcp.Property("date",
				mcp.Description("Date for the reversing entry (YYYY-MM-DD)"),
						mcp.Required(true),
			),
			mcp.Property("description",
				mcp.Description("Optional description for the reversing entry"),
			),
		),
	)

	server.AddTools(reverseJournalEntryTool)

	// Register bokio_get_accounts tool
	getAccountsTool := mcp.NewServerTool[GetAccountsParams, GetAccountsResult](
		"bokio_get_accounts",
		"Get chart of accounts to see available account codes",
		func(ctx context.Context, session *mcp.ServerSession, params *mcp.CallToolParamsFor[GetAccountsParams]) (*mcp.CallToolResultFor[GetAccountsResult], error) {
			// Authentication is handled automatically by AuthenticatedGET

			path := "/accounts"
			if params.Arguments.Type != nil && *params.Arguments.Type != "" {
				path += "?type=" + *params.Arguments.Type
			}

			resp, err := client.AuthenticatedGET(ctx, path)
			if err != nil {
				return &mcp.CallToolResultFor[GetAccountsResult]{
					Content: []mcp.Content{
						&mcp.TextContent{
							Text: fmt.Sprintf("Failed to get accounts: %v", err),
						},
					},
				}, nil
			}

			if resp.StatusCode() != http.StatusOK {
				return &mcp.CallToolResultFor[GetAccountsResult]{
					Content: []mcp.Content{
						&mcp.TextContent{
							Text: fmt.Sprintf("API error: %d - %s", resp.StatusCode(), resp.String()),
						},
					},
				}, nil
			}

			var accounts []bokio.Account
			if err := json.Unmarshal(resp.Body(), &accounts); err != nil {
				return &mcp.CallToolResultFor[GetAccountsResult]{
					Content: []mcp.Content{
						&mcp.TextContent{
							Text: fmt.Sprintf("Failed to parse response: %v", err),
						},
					},
				}, nil
			}

			return &mcp.CallToolResultFor[GetAccountsResult]{
				Content: []mcp.Content{
					&mcp.TextContent{
						Text: fmt.Sprintf("Found %d accounts", len(accounts)),
					},
				},
			}, nil
		},
		mcp.Input(
			mcp.Property("type",
				mcp.Description("Filter by account type"),
					),
		),
	)

	server.AddTools(getAccountsTool)

	return nil
}





// parseCreateJournalEntryRequestFromParams parses the new typed parameters into a CreateJournalEntryRequest
func parseCreateJournalEntryRequestFromParams(params CreateJournalEntryParams) (*bokio.CreateJournalEntryRequest, error) {
	if params.Date == "" {
		return nil, fmt.Errorf("date is required")
	}

	if params.Description == "" {
		return nil, fmt.Errorf("description is required")
	}

	if len(params.Lines) < 2 {
		return nil, fmt.Errorf("at least 2 journal lines are required")
	}

	items := make([]bokio.JournalEntryItem, len(params.Lines))
	for i, lineParams := range params.Lines {
		if lineParams.AccountCode == "" {
			return nil, fmt.Errorf("account_code is required for line %d", i)
		}

		// Parse account code to int32
		accountCode, err := strconv.ParseInt(lineParams.AccountCode, 10, 32)
		if err != nil {
			return nil, fmt.Errorf("invalid account_code for line %d: %v", i, err)
		}

		item := bokio.JournalEntryItem{
			Account: int32(accountCode),
		}

		// Check for debit or credit (exactly one should be provided)
		hasDebit := lineParams.Debit != nil
		hasCredit := lineParams.Credit != nil

		if hasDebit {
			item.Debit = lineParams.Debit.Amount
		}

		if hasCredit {
			item.Credit = lineParams.Credit.Amount
		}

		if !hasDebit && !hasCredit {
			return nil, fmt.Errorf("either debit or credit is required for line %d", i)
		}

		if hasDebit && hasCredit {
			return nil, fmt.Errorf("cannot have both debit and credit for line %d", i)
		}

		items[i] = item
	}

	request := &bokio.CreateJournalEntryRequest{
		Title: params.Description,
		Date:  params.Date,
		Items: items,
	}

	// Parse date (in a real implementation, convert string to time.Time)
	// For now, we'll leave Date as nil and let the API handle the string

	// Reference field doesn't exist in CreateJournalEntryRequest

	return request, nil
}

// validateJournalEntryBalanceFromTyped validates that debits equal credits for the typed version
func validateJournalEntryBalanceFromTyped(request *bokio.CreateJournalEntryRequest) error {
	totalDebits := make(map[string]float64)
	totalCredits := make(map[string]float64)

	for _, item := range request.Items {
		totalDebits["SEK"] += item.Debit
		totalCredits["SEK"] += item.Credit
	}

	// Check that debits equal credits for each currency
	for currency, debitTotal := range totalDebits {
		creditTotal, exists := totalCredits[currency]
		if !exists || debitTotal != creditTotal {
			return fmt.Errorf("journal entry does not balance for currency %s: debits=%.2f, credits=%.2f", currency, debitTotal, creditTotal)
		}
	}

	// Check that all currencies in credits are also in debits
	for currency, creditTotal := range totalCredits {
		debitTotal, exists := totalDebits[currency]
		if !exists || debitTotal != creditTotal {
			return fmt.Errorf("journal entry does not balance for currency %s: debits=%.2f, credits=%.2f", currency, debitTotal, creditTotal)
		}
	}

	return nil
}
